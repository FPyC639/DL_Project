{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: dynamic programming, recursion, memoization\n\n### Task", "fingerprint": null, "seed": "int main() {\n\t// your code goes here\nstring s1,s2;\ncin>>s1>>s2;\nint m,n;\nm=s1.length();\nn=s2.length();\ncout<<editDistance(s1,s2,m,n);\n\treturn 0;\n}", "id": 0, "concepts": ["dynamic programming", "recursion", "memoization"], "instruction": "Implement a C++ function to calculate the `n`th term in the Fibonacci sequence using dynamic programming with memoization. The function should be recursive and utilize memoization to store previously computed values to avoid repeated computations."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: sensor reading and processing, software design for efficient and accurate detection\n\n### Task", "fingerprint": null, "seed": "void read_sensors() { \n    num_hits = 0;   // global variable\n    num_hits += digitalRead(radar);\n    num_hits += digitalRead(pir1); \n    num_hits += digitalRead(pir2); \n    digitalWrite (led, (num_hits==0));  // active low\n}", "id": 1, "concepts": ["sensor reading and processing", "software design for efficient and accurate detection"], "instruction": "Implement a C++ function that processes sensor readings and returns the detected values. The sensor readings are represented as a list of floating-point numbers. The function should process the readings and return a list of detected values. The detection algorithm is based on the following criteria:\n1. The detected value should be greater than 100.\n2. The detected value should be less than 200.\n3. The detected value should be the maximum value in the readings.\n\nThe function should be designed to be efficient and accurate in detecting the values."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: hard\nconcepts: bilinear interpolation, 2D image processing, data type handling\n\n### Task", "fingerprint": null, "seed": "inline double getBilinearInterpolatedValue(const Mat &img, const Vector2d &pt)\n{\n    uchar *d = &img.data[int(pt(1, 0)) * img.step + int(pt(0, 0))];\n    double xx = pt(0, 0) - floor(pt(0, 0));\n    double yy = pt(1, 0) - floor(pt(1, 0));\n    return ((1 - xx) * (1 - yy) * double(d[0]) +\n            xx * (1 - yy) * double(d[1]) +\n            (1 - xx) * yy * double(d[img.step]) +\n            xx * yy * double(d[img.step + 1])) / 255.0;\n}", "id": 2, "concepts": ["bilinear interpolation", "2D image processing", "data type handling"], "instruction": "Implement a C++ function to perform bilinear interpolation on a 2D image represented as a 2D array of pixel values. The function should accept a 2D array of pixel values and the desired output size as input, and return a new 2D array of pixel values that has been resized using bilinear interpolation."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: easy\nconcepts: variable declaration, user input with `cin`, arithmetic operations, for loop for iteration\n\n### Task", "fingerprint": null, "seed": "int main() {\n\tfloat acum;\n\tfloat dato;\n\tint i;\n\tint n;\n\tfloat prom;\n\tcout << \"Ingrese la cantidad de alumnos:\" << endl;\n\tcin >> n;\n\tacum = 0;\n\tfor (i=1;i<=n;i++) {\n\t\tcout << \"Ingrese la edad \" << i << \":\" << endl;\n\t\tcin >> dato;\n\t\tacum = acum+dato;\n\t}\n\tprom = acum/n;\n\tcout << \"El promedio de las edades del grupo de \" << n << \" alumnos es: \" << prom << endl;\n\treturn 0;\n}", "id": 3, "concepts": ["variable declaration", "user input with `cin`", "arithmetic operations", "for loop for iteration"], "instruction": "Implement a C++ class with a method `compute_factorial` that takes an integer as input and returns its factorial. Declare a variable `result` and initialize it to 1. Use a for loop to iterate from 2 to the given number, multiplying `result` by the current number at each iteration. Return `result` after the loop."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: string processing, character counting, frequency table construction\n\n### Task", "fingerprint": null, "seed": "int main(){\n\tstring N;\n\tcin>>N;\n\tint d[10]={0};\n\tint len=N.length();\n\tfor(int i=0;i<len;i++)\n\t\td[N[i]-'0']++;\n\t\n\tfor(int i=0;i<10;i++){\n\t\tif(d[i]!=0)\n\t\t\tcout<<i<<\":\"<<d[i]<<endl;\n\t}\n\treturn 0;\n}", "id": 4, "concepts": ["string processing", "character counting", "frequency table construction"], "instruction": "Develop a C++ function that takes a string and returns the frequency of each character as a dictionary. The function should ignore whitespace characters and case sensitivity.\n\nFor example, given the string \"Hello, World!\", the function should return a dictionary such as `{'h': 1, 'e': 1, 'l': 3, 'o': 2, ',': 1, 'w': 1, 'r': 1, 'd': 1, '!': 1}`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: easy\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task", "fingerprint": null, "seed": "inline bool e_server_msg_type_Parse(\n    const ::std::string& name, e_server_msg_type* value) {\n  return ::google::protobuf::internal::ParseNamedEnum<e_server_msg_type>(\n    e_server_msg_type_descriptor(), name, value);\n}", "id": 5, "concepts": ["regular expression for pattern matching", "dictionary lookup for suffix mapping", "error handling with exceptions"], "instruction": "Implement a C++ program that takes a regular expression as an input and returns a dictionary mapping each suffix of the regular expression to a list of corresponding substrings that match that suffix. Handle any possible errors that might occur during the execution.\n\nFor example, if the input regular expression is `'(a|b)*c'`, the output dictionary should be:\n\n```\n{\n    'c': ['c'],\n    'b*c': ['bc', 'c'],\n    '(a|b)*c': ['abc', 'ac', 'bc', 'c']\n}\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: easy\nconcepts: graph representation with adjacency list, edge addition, edge structure definition\n\n### Task", "fingerprint": null, "seed": "void add(int u,int v,int w){e[++ecnt]={v,w,head[u]};head[u]=ecnt;}", "id": 6, "concepts": ["graph representation with adjacency list", "edge addition", "edge structure definition"], "instruction": "Implement a C++ class `Graph` that represents a weighted, directed graph. The class should have the following properties:\n\n- The graph is represented as an adjacency list with an `unordered_map` of `Node` objects. Each `Node` object has a value and a list of outgoing edges. Each edge is represented by a `pair` of `Node` objects, where the first element is the source and the second element is the destination. The edge also has a weight, represented as an integer.\n\n- The class should have a method `add_edge(source, destination, weight)` that adds a new edge to the graph.\n\n- The class should have a method `get_adjacency_list()` that returns a list of all edges in the graph.\n\n- The class should have a method `get_nodes()` that returns a list of all nodes in the graph."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: medium\nconcepts: summation of odd numbers from 1 to 100, loop structure, variable initialization and incrementation\n\n### Task", "fingerprint": null, "seed": "int main()\n{\n    int s;\n\tfor(int a=1; a<=100;a=a+2)\n\t{\n\t\t\ts=s+a;\n\t\t\t\n\t}\tprintf(\"Tong so le den so 100 la: %d \\n\",s);\n\treturn 0;\n  \n\n}", "id": 7, "concepts": ["summation of odd numbers from 1 to 100", "loop structure", "variable initialization and incrementation"], "instruction": "Write a C++ program to calculate the sum of all odd numbers from 1 to 100, including 1 and 100. The program should use a loop structure to iterate through the odd numbers, initializing the sum variable to 0 and incrementing it by the current odd number in each iteration.\n\nThe program should print the final sum at the end."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: low voltage detection, blynk push notification, flag-based notification control\n\n### Task", "fingerprint": null, "seed": "void low_volt_alert()                              // Function to send blynk push notifiction if low voltage is detected\n{\n  if(lowvoltagenotificationflag == true && underVoltageAlertOnOffState == 0 && blynkConnectionStatusForNotification == true){ \n    Serial.println(\"Sending Under voltage Blynk notification\");\n    Blynk.notify(\"Low Voltage Detected!\");\n    lowvoltagenotificationflag = false;\n  }\n}", "id": 8, "concepts": ["low voltage detection", "blynk push notification", "flag-based notification control"], "instruction": "Implement a C++ class to monitor and detect low voltage using a Blynk app. The class should maintain a flag `low_voltage` that indicates if the voltage is below a certain threshold. The class should also provide a method `check_voltage(voltage)` to update the `low_voltage` flag based on the input voltage. When `low_voltage` is set to True, the class should push a notification to the Blynk app to inform the user."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: hard\nconcepts: setup function for initialization, library usage, VCC object creation\n\n### Task", "fingerprint": null, "seed": "void setup(){\n  //setup all VCC main settings\n  VCC.setup();\n\n}", "id": 9, "concepts": ["setup function for initialization", "library usage", "VCC object creation"], "instruction": "Implement a C++ function `get_vcc_object()` that creates and initializes a VCC object for a given image using the VCC library. The function should take the image path as an input and return the initialized VCC object.\n\nThe function should:\n\n- Initialize the VCC library with `vccInitialize()` and check for errors.\n- Create a VCC image object with `vccCreateImageFromFile()` and check for errors.\n- Create a VCC object with `vccCreate()` and check for errors.\n- Set the image on the VCC object with `vccSetImage()` and check for errors.\n- Return the initialized VCC object.\n\nYou can use the following code as a reference:\n\n```cpp\nVCC *get_vcc_object(const std::string &image_path) {\n    VCC *vcc = NULL;\n    if (vccInitialize() != VCC_SUCCESS) {\n        throw std::runtime_error(\"Failed to initialize VCC library\");\n    }\n    VCCImage *image = vccCreateImageFromFile(image_path.c_str());\n    if (image == NULL) {\n        throw std::runtime_error(\"Failed to create VCC image object\");\n    }\n    vcc = vccCreate();\n    if (vcc == NULL) {\n        throw std::runtime_error(\"Failed to create VCC object\");\n    }\n    if (vccSetImage(vcc, image) != VCC_SUCCESS) {\n        throw std::runtime_error(\"Failed to set image on VCC object\");\n    }\n    return vcc;\n}\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: switch-case statement for command processing, bitmask operations for flag management, error handling and return\n\n### Task", "fingerprint": null, "seed": "static int8_t CDC_Control_FS(uint8_t cmd, uint8_t* pbuf, uint16_t length)\r\n{\r\n    /* USER CODE BEGIN 5 */\r\n    switch (cmd)\r\n    {\r\n    case CDC_SEND_ENCAPSULATED_COMMAND:\r\n\r\n        break;\r\n\r\n    case CDC_GET_ENCAPSULATED_RESPONSE:\r\n\r\n        break;\r\n\r\n    case CDC_SET_COMM_FEATURE:\r\n\r\n        break;\r\n\r\n    case CDC_GET_COMM_FEATURE:\r\n\r\n        break;\r\n\r\n    case CDC_CLEAR_COMM_FEATURE:\r\n\r\n        break;\r\n\r\n        /*******************************************************************************/\r\n        /* Line Coding Structure                                                       */\r\n        /*-----------------------------------------------------------------------------*/\r\n        /* Offset | Field       | Size | Value  | Description                          */\r\n        /* 0      | dwDTERate   |   4  | Number |Data terminal rate, in bits per second*/\r\n        /* 4      | bCharFormat |   1  | Number | Stop bits                            */\r\n        /*                                        0 - 1 Stop bit                       */\r\n        /*                                        1 - 1.5 Stop bits                    */\r\n        /*                                        2 - 2 Stop bits                      */\r\n        /* 5      | bParityType |  1   | Number | Parity                               */\r\n        /*                                        0 - None                             */\r\n        /*                                        1 - Odd                              */\r\n        /*                                        2 - Even                             */\r\n        /*                                        3 - Mark                             */\r\n        /*                                        4 - Space                            */\r\n        /* 6      | bDataBits  |   1   | Number Data bits (5, 6, 7, 8 or 16).          */\r\n        /*******************************************************************************/\r\n    case CDC_SET_LINE_CODING:\r\n\r\n        break;\r\n\r\n    case CDC_GET_LINE_CODING:\r\n\r\n        break;\r\n\r\n    case CDC_SET_CONTROL_LINE_STATE:\r\n\r\n        break;\r\n\r\n    case CDC_SEND_BREAK:\r\n\r\n        break;\r\n\r\n    default:\r\n        break;\r\n    }\r\n\r\n    return (USBD_OK);\r\n    /* USER CODE END 5 */\r\n}", "id": 10, "concepts": ["switch-case statement for command processing", "bitmask operations for flag management", "error handling and return"], "instruction": "Implement a C++ class `CommandProcessor` that processes commands in a specific format. Each command is a string consisting of a single-character command ID followed by a sequence of 2-digit hex numbers (e.g., 'A123456789'). The class should store the command ID and the hex numbers as a list of integers. It needs to support the following operations:\n\n- `process_command(command)`: processes a given command in the specified format. It should extract the command ID and the hex numbers, store them internally, and return the command ID.\n- `get_command_id()`: returns the last processed command ID.\n- `get_numbers()`: returns the last processed hex numbers as a list of integers.\n- `get_number_count()`: returns the number of processed hex numbers.\n- `get_number_at(index)`: returns the hex number at the given index.\n- `set_number_at(index, value)`: sets the hex number at the given index to the given value.\n- `clear()`: clears all stored command information.\n\nUsing the class, write assertions to verify the correctness of the operations.\n\n```cpp\nprocessor = CommandProcessor()\nassert processor.process_command('A123456789') == 'A'\nassert processor.get_command_id() == 'A'\nassert processor.get_numbers() == [0x12345678, 0x90000000]\nassert processor.get_number_count() == 2\nassert processor.get_number_at(1) == 0x90000000\nprocessor.set_number_at(1, 0xABCDEF01)\nassert processor.get_number_at(1) == 0xABCDEF01\nprocessor.clear()\nassert processor.get_command_id() == ''\nassert processor.get_numbers() == []\nassert processor.get_number_count() == 0\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: comparator function for sorting, comparison-based programming\n\n### Task", "fingerprint": null, "seed": "bool cmp(const eg& e1,const eg&e2)\n{\n    return e1.v<e2.v;\n}", "id": 11, "concepts": ["comparator function for sorting", "comparison-based programming"], "instruction": "Implement a C++ function `sort_by_frequency(items)` to sort a list of items based on their frequency in the list. The most frequent element should come first, and elements with the same frequency should be sorted in the order they appear in the original list. Write assertions to ensure the function correctly sorts the following test cases:\n\n```cpp\nassert sort_by_frequency([1, 2, 3, 2, 1]) == [1, 2, 1, 2, 3]\nassert sort_by_frequency([1, 2, 3, 4]) == [1, 2, 3, 4]\nassert sort_by_frequency(['a', 'b', 'c', 'a', 'b']) == ['a', 'b', 'a', 'b', 'c']\nassert sort_by_frequency([1, 1, 2, 2, 3, 3]) == [1, 1, 2, 2, 3, 3]\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: function pointer casting, function call with arguments\n\n### Task", "fingerprint": null, "seed": "void fpcM_Execute(void* pProc) {\n    fpcEx_Execute((base_process_class*)pProc);\n}", "id": 12, "concepts": ["function pointer casting", "function call with arguments"], "instruction": "Given a function `foo` with the following signature:\n\n```cpp\nint foo(int a, int b, int c);\n```\n\nCreate a C++ function `call_foo` that accepts a function pointer `f` and three arguments `x`, `y`, and `z`, and returns the result of calling `f` with `x`, `y`, and `z`. The function pointer `f` should be cast to a pointer to the `foo` function type.\n\nFor example, given the following implementation of `foo`:\n\n```cpp\nint foo(int a, int b, int c) {\n  return a + b * c;\n}\n```\n\nThe following call to `call_foo` should return the same result as calling `foo` directly:\n\n```cpp\nassert call_foo(&foo, 1, 2, 3) == foo(1, 2, 3);\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: medium\nconcepts: IR signal encoding, remote control communication, bit-length specification\n\n### Task", "fingerprint": null, "seed": "void loop() {\n        // The transmitter sends in this example the signal A90 (hex. dezimal form) in the encoding \"RC5\"\n        // It will be transmitted 3 times after that it will make a 5 second break\n    for (int i = 0; i < 3; i++) {\n        // irsend.sendRC5(0xA90, 12); // [0xA90] signal | [12] Bit-length signal (hex A90=1010 1001 0000)\n        irsend.sendSAMSUNG(0xE0E0F00F,32); // Parametros: Tecla MUTE sacada del receptor, numero de bits del codigo de Samsung\n        delay(40);\n    }\n    delay(5000); // 5 second break between the sending impulses\n}", "id": 13, "concepts": ["IR signal encoding", "remote control communication", "bit-length specification"], "instruction": "Write a C++ program to simulate encoding and decoding of infrared (IR) signals for a remote control. The program should accept a raw sequence of 0s and 1s as input and output the corresponding encoded signal as a sequence of bytes, using the following encoding scheme:\n\n- Each bit is represented by a 500ms pulse, followed by a 500ms space.\n- A logical 1 is represented by a 2500ms pulse, followed by a 500ms space.\n- A logical 0 is represented by a 500ms pulse, followed by a 500ms space.\n- The encoded signal is output as a sequence of bytes, where each byte represents 8 bits of the encoded signal.\n\nFor example, the input sequence `10111000` should be encoded as `0b01100000`, which is `0x60` in hexadecimal.\n\nThe program should also be able to decode the encoded signal back into its original binary sequence."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: medium\nconcepts: computational physics simulation, two-dimensional array handling, vectorization with OpenMP\n\n### Task", "fingerprint": null, "seed": "void Exact_Source(float *b, int Nx) \n{ \n\tint i,j; \n\tfloat x, y, h; \n\th = 1.0/(Nx+1); \n\t#pragma acc parallel loop gang present(b) \n\tfor(i=0;i<Nx;++i) \n\t{ \n\t\tx = (i+1)*h; \n\t\t#pragma acc loop vector \n\t\tfor(j=0;j<Nx;++j) \n\t\t{ \n\t\t\t//k = j + i*(N-1); \n\t\t\ty = (j+1)*h; \n\t\t\tb[Nx*i+j] = -(1.0+4.0)*h*h*M_PI*M_PI*sin(M_PI*x)*sin(2*M_PI*y); \n\t\t} \n\t} \n}", "id": 14, "concepts": ["computational physics simulation", "two-dimensional array handling", "vectorization with OpenMP"], "instruction": "Implement a C++ program to simulate the movement of a particle in a two-dimensional space according to the following rules:\n\n- The particle starts at the origin (0, 0) and moves in the positive x-direction with a constant velocity of 1 unit/timestep.\n- At each timestep, there is a 20% chance that the particle will reverse its direction and move in the negative x-direction.\n- At each timestep, there is a 10% chance that the particle will move in the positive y-direction, and a 10% chance that it will move in the negative y-direction.\n- At each timestep, there is a 5% chance that the particle will move in any of the four diagonal directions.\n\nThe program should simulate the movement of the particle for a specified number of timesteps and store the trajectory (the sequence of locations) in a two-dimensional array.\n\nFor efficiency, utilize OpenMP to vectorize the simulation process across multiple threads."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: easy\nconcepts: bfs implementation, 3-dimensional matrix traversal, queue usage for level traversal\n\n### Task", "fingerprint": null, "seed": "int main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\n\tcin >> m >> n >> h; totalnum = m * n * h;\n\tfor (int k = 1; k <= h; k++) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t\tcin >> map1[i][j][k];\n\t\t\t\tif (map1[i][j][k] == '1') {\n\t\t\t\t\tq.push({ i,j,k });\n\t\t\t\t\ttomato++;\n\t\t\t\t}\n\t\t\t\telse if (map1[i][j][k] == '-') {\n\t\t\t\t\tchar s;\n\t\t\t\t\tcin >> s;\n\t\t\t\t\ttotalnum--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile (!q.empty()) {\n\t\tbool flag = true;\n\t\tint qs = q.size();\n\t\tcnt++;\n\t\twhile (qs--) {\n\t\t\tint x = q.front().x;\n\t\t\tint y = q.front().y;\n\t\t\tint z = q.front().z;\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\tint nx = x + dr[i];\n\t\t\t\tint ny = y + dc[i];\n\t\t\t\tint nz = z + dz[i];\n\t\t\t\tif (nx <= 0 || nx > n || ny <= 0 || ny > m || nz <= 0 || nz > h) continue;\n\n\t\t\t\tif (map1[nx][ny][nz] == '0') {\n\t\t\t\t\ttomato++;\n\t\t\t\t\tmap1[nx][ny][nz] = '1';\n\t\t\t\t\tq.push({ nx,ny, nz });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (totalnum != tomato) {\n\t\tcout << \"-1\\n\";\n\t\treturn 0;\n\t}\n\tcout << cnt << '\\n';\n\treturn 0;\n}", "id": 15, "concepts": ["bfs implementation", "3-dimensional matrix traversal", "queue usage for level traversal"], "instruction": "Implement a C++ class named `Grid` that represents a 3-dimensional integer matrix. The class should have the following methods:\n- `Grid(matrix)`: initialize the class with a 3-dimensional matrix.\n- `get_size()`: return the size of the matrix as a tuple of three integers (rows, columns, depth).\n- `get_value(x, y, z)`: return the value at the given coordinates.\n- `bfs(start_x, start_y, start_z, target)`: perform a breadth-first search from the given coordinates to find a specific value in the matrix. Returns a tuple of three integers (x, y, z) representing the coordinates of the target value, or (-1, -1, -1) if the target is not found."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: hard\nconcepts: string manipulation, linked list traversal, insertion\n\n### Task", "fingerprint": null, "seed": "void p3(Node *h){\n\tNode *p = h;\n\twhile(p){\n\t\tNode *pn = p->next;\n\t\tif(pn == NULL || pn->c != '.') {\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tNode *pnn = pn->next;\n\t\tif(pnn == NULL || pnn->c != '.') {\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tNode *pnnn = pnn->next;\n\t\tif(pnnn == NULL || pnnn->c != '.') {\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n//\t\tcout<<\"p3\"<<endl;\n\t\tNode *node;\n\t\tnode = new Node(' ');\n\t\tp = insert(p,node);\n\t\tnode = new Node(' ');\n\t\tpnnn = insert(pnnn,node);\n\t\tp = pnnn;\n\t}\n}", "id": 16, "concepts": ["string manipulation", "linked list traversal", "insertion"], "instruction": "Implement a C++ function `insert_string(original_string, substring, index)` that inserts `substring` into `original_string` at the specified `index`. The function should return the modified string.\n\nFor example, given `original_string = 'Hello World!'` and `substring = 'Python'`, the function should return `'Hello Python World!'` when `index = 6`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: easy\nconcepts: function definition, member function initialization, argument passing, type specification\n\n### Task", "fingerprint": null, "seed": "void DiscreteMasterProperty__float4___ObjInit_2(DiscreteMasterProperty__float4* __this, ::app::Uno::UX::Property__float4* property, ::app::Fuse::Animations::MixerBase* mixerBase)\n{\n    ::app::Fuse::Animations::MasterProperty__float4___ObjInit_1(__this, property, mixerBase);\n}", "id": 17, "concepts": ["function definition", "member function initialization", "argument passing", "type specification"], "instruction": "Implement a C++ class `Vector` with the following member functions:\n\n- `add(Vector v)`: adds the given vector `v` to the current vector and returns the result as a new vector object\n- `subtract(Vector v)`: subtracts the given vector `v` from the current vector and returns the result as a new vector object\n- `dot(Vector v)`: returns the dot product of the current vector and the given vector `v`\n\nThe class should be initialized with two arguments `x` and `y`, representing the x and y coordinates of the vector, respectively."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: system design, sensor data processing, network command handling\n\n### Task", "fingerprint": null, "seed": "void ticker(){\n    read_sensors();  // read PIR and radar...\n    update_status(); // ...and then compute occupancy status\n    if (network.available())  // this is usually a while() loop  \n        read_command();        \n}", "id": 18, "concepts": ["system design", "sensor data processing", "network command handling"], "instruction": "Develop a system that processes sensor data from multiple sensors and sends commands to actuators based on the data. The system should be designed as a C++ function `handle_sensor_data(sensor_data)` that takes a dictionary of sensor data as input. The keys are sensor IDs, and the values are the sensor values. The function should process the data and generate the appropriate commands for the actuators. The commands should be sent to the actuators using the function `send_command(command)`.\n\nHere are some assumptions to simplify the design:\n- There are three actuators: A, B, and C.\n- Sensor data is always present for the three actuators.\n- The command format is `ACTUATOR_ID:COMMAND_VALUE`.\n- When the sensor data for an actuator is above a certain threshold, the corresponding actuator should be on.\n- When the sensor data for an actuator is below a certain threshold, the corresponding actuator should be off.\n\nHere's an example of how you could design the system:\n\n```cpp\nvoid handle_sensor_data(const std::map<std::string, float> &sensor_data) {\n    for (const auto &sensor : sensor_data) {\n        if (sensor.first == \"A\" && sensor.second > 10.0) {\n            send_command(\"A:ON\");\n        } else if (sensor.first == \"A\" && sensor.second < 5.0) {\n            send_command(\"A:OFF\");\n        } else if (sensor.first == \"B\" && sensor.second > 20.0) {\n            send_command(\"B:ON\");\n        } else if (sensor.first == \"B\" && sensor.second < 15.0) {\n            send_command(\"B:OFF\");\n        } else if (sensor.first == \"C\" && sensor.second > 30.0) {\n            send_command(\"C:ON\");\n        } else if (sensor.first == \"C\" && sensor.second < 25.0) {\n            send_command(\"C:OFF\");\n        }\n    }\n}\n\nvoid send_command(const std::string &command) {\n    std::cout << command << std::endl;\n}\n```\n\nThis system uses a function `handle_sensor_data(sensor_data)` to process sensor data and generate commands. The function iterates through the sensor data, and for each sensor, it checks the value and generates the appropriate command based on the predefined thresholds. The function `send_command(command)` is used to send the generated command to the actuator."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: hard\nconcepts: data transfer between devices, real-time monitoring and control, energy consumption analysis\n\n### Task", "fingerprint": null, "seed": "void sendtoBlynk()                                                           // Here we are sending PZEM data to blynk\n{\n  Blynk.virtualWrite(vPIN_VOLTAGE_1,               voltage_usage_1);\n  Blynk.virtualWrite(vPIN_CURRENT_USAGE_1,         current_usage_1);\n  Blynk.virtualWrite(vPIN_ACTIVE_POWER_1,          active_power_1);\n  Blynk.virtualWrite(vPIN_ACTIVE_ENERGY_1,         active_energy_1);\n  Blynk.virtualWrite(vPIN_FREQUENCY_1,             frequency_1);\n  Blynk.virtualWrite(vPIN_POWER_FACTOR_1,          power_factor_1);\n\n  Blynk.virtualWrite(vPIN_VOLTAGE_2,               voltage_usage_2);\n  Blynk.virtualWrite(vPIN_CURRENT_USAGE_2,         current_usage_2);\n  Blynk.virtualWrite(vPIN_ACTIVE_POWER_2,          active_power_2);\n  Blynk.virtualWrite(vPIN_ACTIVE_ENERGY_2,         active_energy_2);\n  Blynk.virtualWrite(vPIN_FREQUENCY_2,             frequency_2);\n  Blynk.virtualWrite(vPIN_POWER_FACTOR_2,          power_factor_2);\n\n  Blynk.virtualWrite(vPIN_VOLTAGE_3,               voltage_usage_3);\n  Blynk.virtualWrite(vPIN_CURRENT_USAGE_3,         current_usage_3);\n  Blynk.virtualWrite(vPIN_ACTIVE_POWER_3,          active_power_3);\n  Blynk.virtualWrite(vPIN_ACTIVE_ENERGY_3,         active_energy_3);\n  Blynk.virtualWrite(vPIN_FREQUENCY_3,             frequency_3);\n  Blynk.virtualWrite(vPIN_POWER_FACTOR_3,          power_factor_3);\n\n  Blynk.virtualWrite(vPIN_SUM_VOLTAGE,             sum_of_voltage);\n  Blynk.virtualWrite(vPIN_SUM_CURRENT_USAGE,       sum_of_current);\n  Blynk.virtualWrite(vPIN_SUM_ACTIVE_POWER,        sum_of_power);\n  Blynk.virtualWrite(vPIN_SUM_ACTIVE_ENERGY,       sum_of_active_energy);\n  Blynk.virtualWrite(vPIN_SUM_FREQUENCY,           sum_of_frequency);\n  Blynk.virtualWrite(vPIN_SUM_POWER_FACTOR,        sum_of_power_factor);\n\n  Blynk.virtualWrite(VPIN_BUILD_NUMBER,            BUILD_NUMBER);  \n}", "id": 19, "concepts": ["data transfer between devices", "real-time monitoring and control", "energy consumption analysis"], "instruction": "Implement a C++ class `DeviceDataTransfer` to manage the data transfer between two devices. The class should have the following methods:\n\n- `init_transfer(data, chunk_size)`: Initialize the transfer with the data to be sent and the size of each chunk. The data can be a list of numbers or a string.\n- `transfer_chunk()`: Send a chunk of data to the other device. The method should return the chunk of data sent.\n- `receive_chunk(chunk)`: Receive a chunk of data from the other device and update the internal state of the class accordingly.\n- `is_transfer_complete()`: Return a boolean value indicating whether the transfer is complete.\n\nThe class should be able to handle any type of data and support real-time monitoring and control of the transfer process. Additionally, the class should provide methods to analyze the energy consumption of the transfer process."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: date and time formatting, string formatting, time zone consideration\n\n### Task", "fingerprint": null, "seed": "void printDateTime(time_t t, const char *tz)\r\n{\r\n    char buf[32];\r\n    char m[4];    // temporary storage for month string (DateStrings.cpp uses shared buffer)\r\n    strcpy(m, monthShortStr(month(t)));\r\n    sprintf(buf, \"%.2d:%.2d:%.2d %s %.2d %s %d %s\",\r\n        hour(t), minute(t), second(t), dayShortStr(weekday(t)), day(t), m, year(t), tz);\r\n    Serial.println(buf);\r\n}", "id": 20, "concepts": ["date and time formatting", "string formatting", "time zone consideration"], "instruction": "Create a C++ class `DatetimeFormatter` with the following requirements:\n\n1. The class should have two class attributes: `DATE_FORMAT` and `TIME_FORMAT`, which are string formats for date and time, respectively.\n2. The class should have a constructor that takes a datetime object as input and stores it as an instance attribute.\n3. The class should have a `format_datetime` method that returns a formatted string of the stored datetime object using the `DATE_FORMAT` and `TIME_FORMAT` attributes.\n4. The class should have a class method `format_now` that returns a formatted string of the current datetime using the `DATE_FORMAT` and `TIME_FORMAT` attributes.\n\nIn addition, consider time zone when formatting the datetime object."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: recursive algorithm design, string sorting for comparison, string slicing for subproblem creation, memoization for optimization\n\n### Task", "fingerprint": null, "seed": "bool isScramble(string& s1, string& s2) {\n    if (s1.size() != s2.size()) return false;\n    if (s1.size() == 1) return s1 == s2; \n    \n    string combined(s1);\n    combined.append(s2);\n    if (memo.find(combined) != memo.end()) return memo.at(combined);\n    \n    int size = s1.size();\n    \n    int part_length = 1; \n    \n    while (part_length <= size/2) {\n        string s1_k1_p1 = s1.substr(0, part_length); \n        string s1_k1_p2 = s1.substr(part_length);\n        string s1_k2_p1 = s1.substr(size - part_length); \n        string s1_k2_p2 = s1.substr(0, size - part_length); \n        string s2_k1_p1 = s2.substr(0, part_length); \n        string s2_k1_p2 = s2.substr(part_length); \n        string s2_k2_p1 = s2.substr(size - part_length); \n        string s2_k2_p2 = s2.substr(0, size - part_length);\n\n        string sorted_s1_k1_p1 = genSortedString(s1_k1_p1);\n        string sorted_s1_k1_p2 = genSortedString(s1_k1_p2);\n        string sorted_s1_k2_p1 = genSortedString(s1_k2_p1);\n        string sorted_s1_k2_p2 = genSortedString(s1_k2_p2);\n        string sorted_s2_k1_p1 = genSortedString(s2_k1_p1);\n        string sorted_s2_k1_p2 = genSortedString(s2_k1_p2);\n        string sorted_s2_k2_p1 = genSortedString(s2_k2_p1);\n        string sorted_s2_k2_p2 = genSortedString(s2_k2_p2);\n        \n        if (sorted_s1_k1_p1 == sorted_s2_k1_p1 && sorted_s1_k1_p2 == sorted_s2_k1_p2) {\n            if (isScramble(s1_k1_p1, s2_k1_p1) && isScramble(s1_k1_p2, s2_k1_p2)) {\n                return true;\n            }\n        }\n        \n        if (sorted_s1_k2_p1 == sorted_s2_k1_p1 && sorted_s1_k2_p2 == sorted_s2_k1_p2) {\n            if (isScramble(s1_k2_p1, s2_k1_p1) && isScramble(s1_k2_p2, s2_k1_p2)) {\n                return true;\n            }\n        }  \n\n        if (sorted_s1_k1_p1 == sorted_s2_k2_p1 && sorted_s1_k1_p2 == sorted_s2_k2_p2) {\n            if (isScramble(s1_k1_p1, s2_k2_p1) && isScramble(s1_k1_p2, s2_k2_p2)) {\n                return true;\n            }\n        }\n        \n        if (sorted_s1_k2_p1 == sorted_s2_k2_p1 && sorted_s1_k2_p2 == sorted_s2_k2_p2) {\n            if (isScramble(s1_k2_p1, s2_k2_p1) && isScramble(s1_k2_p2, s2_k2_p2)) {\n                return true;\n            }\n        }\n        \n        part_length ++;\n    }\n    \n    memo[combined] = false;\n    return false; \n}", "id": 21, "concepts": ["recursive algorithm design", "string sorting for comparison", "string slicing for subproblem creation", "memoization for optimization"], "instruction": "Implement a C++ class `StringSorter` to sort a list of strings in lexicographical order using a recursive algorithm. The class should have a constructor that takes a list of strings as input and a `sort` method that returns the sorted list of strings. Use the provided `StringSorter` class to create a `StringSorter` object with a list of strings as input, and then call the `sort` method to obtain the sorted list of strings.\n\n```cpp\nStringSorter sorter = StringSorter({\"apple\", \"banana\", \"orange\"});\nstd::vector<std::string> sorted_strings = sorter.sort();\n```\n\nImplement the recursive algorithm in the `sort` method. Use string slicing to create subproblems for each character in the strings, and then apply memoization to optimize the algorithm."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: easy\nconcepts: depth-first search, summation calculation, recursive function call\n\n### Task", "fingerprint": null, "seed": "void dfs(ll i, ll sum,ll arr[])\n{\n    if(i==n)\n    {\n        st[sum]++;\n        return;\n    }\n    dfs(i+1,sum+arr[i],arr);\n    dfs(i+1,sum,arr);\n}", "id": 22, "concepts": ["depth-first search", "summation calculation", "recursive function call"], "instruction": "Implement a C++ program that performs a depth-first search on a graph and calculates the sum of all node values that are reachable from the starting node. The program should take a graph represented as an adjacency list and a starting node as input, and return the sum of all reachable node values.\n\nThe program should have a recursive function `dfs(graph, node)` to perform the depth-first search, and another function `sum_reachable(graph, start)` to calculate the sum of reachable node values. The `dfs` function should return a list of all reachable nodes from the given node, and the `sum_reachable` function should call `dfs` and calculate the sum of all node values in the returned list.\n\nThe program should satisfy the following assertions:\n\n```cpp\ngraph = {\n    0: [1, 2],\n    1: [2],\n    2: [3],\n    3: [4],\n    4: []\n}\n\nassert sum_reachable(graph, 0) == 10\nassert sum_reachable(graph, 1) == 3\nassert sum_reachable(graph, 2) == 4\nassert sum_reachable(graph, 3) == 4\nassert sum_reachable(graph, 4) == 4\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: hard\nconcepts: push button state tracking, relay state toggling, Blynk widget updating, push button debouncing, sequential toggle prevention, sequential button state tracking\n\n### Task", "fingerprint": null, "seed": "void checkPhysicalButton()                                  // Here we are going to check push button pressed or not and change relay state\n{\n  if (digitalRead(PUSH_BUTTON_1) == LOW) {\n    if (pushButton1State != LOW && (lowvoltageflag == false && highvoltageflag == false && phasefailureflag == false) ) {                          // pushButton1State is used to avoid sequential toggles  \n      relay1State = !relay1State;                           // Toggle Relay state\n      digitalWrite(RELAY_PIN_1, relay1State);            \n      Blynk.virtualWrite(VPIN_BUTTON_1, relay1State);       // Update Button Widget\n    }\n    pushButton1State = LOW;\n  } else {\n    pushButton1State = HIGH;\n  }\n  \n  if (digitalRead(PUSH_BUTTON_2) == LOW) {\n    if (pushButton2State != LOW && (lowvoltageflag == false && highvoltageflag == false && phasefailureflag == false) ) {                        // pushButton2State is used to avoid sequential toggles     \n      relay2State = !relay2State;                         // Toggle Relay state\n      digitalWrite(RELAY_PIN_2, relay2State);\n      Blynk.virtualWrite(VPIN_BUTTON_2, relay2State);     // Update Button Widget\n    }\n    pushButton2State = LOW;\n  } else {\n    pushButton2State = HIGH;\n  }\n}", "id": 23, "concepts": ["push button state tracking", "relay state toggling", "Blynk widget updating", "push button debouncing", "sequential toggle prevention", "sequential button state tracking"], "instruction": "Implement a C++ function `process_blynk_button_event` that receives a Blynk event from a button widget, toggles a relay state, and updates the Blynk widget with the new state. The function should track the button's current state, prevent sequential toggles, and debounces the button input to avoid false toggles due to electrical noise."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: hard\nconcepts: text processing, linked list manipulation, input-output examples for error handling\n\n### Task", "fingerprint": null, "seed": "void p11(Node *h){\n\tNode *p = h;\n\twhile(p){\n\t\tNode *pn = p->next;\n\t\tif(pn == NULL || pn->c == '\\''){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tNode *pnn = pn->next;\n\t\tif(pnn == NULL || pnn->c != '\\''){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tNode *pnnn = pnn->next;\n\t\tif(pnnn == NULL || pnnn->c != ' '){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n//\t\tcout<<\"p11\"<<endl;\n\t\tNode *node = new Node(' ');\n\t\tpn = insert(pn,node);\n\t\tp = pnnn;\n\t}\n}", "id": 24, "concepts": ["text processing", "linked list manipulation", "input-output examples for error handling"], "instruction": "Implement a C++ function `parse_xml(text)` that parses an XML document and returns a linked list representation of the parsed elements. The function should handle invalid XML documents and raise an exception with a descriptive error message. Write assertions to ensure your function passes the following tests:\n\n```cpp\nassert parse_xml('<a>1</a>') == ['a', '1']\nassert parse_xml('<a>1<b>2</b>3</a>') == ['a', '1', ['b', '2'], '3']\nassert parse_xml('<a>1<b>2</b>3<c>4</c></a>') == ['a', '1', ['b', '2'], '3', ['c', '4']]\ntry:\n    parse_xml('<a>1</b>')\nexcept ValueError as e:\n    assert str(e) == 'Invalid XML document: Unbalanced tags'\ntry:\n    parse_xml('<a>1</a><b>2</b>')\nexcept ValueError as e:\n    assert str(e) == 'Invalid XML document: Multiple root elements'\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: fast exponentiation, modular arithmetic, bitwise operation for exponentiation\n\n### Task", "fingerprint": null, "seed": "int Pow(int x,int k){int t=1;for(;k;k>>=1,x=1ll*x*x%mod) if(k&1) t=1ll*t*x%mod;return t;}", "id": 25, "concepts": ["fast exponentiation", "modular arithmetic", "bitwise operation for exponentiation"], "instruction": "Implement a C++ function `pow_mod` that computes $a^b \\bmod m$ in $O(\\log b)$ time complexity using fast exponentiation and modular arithmetic. You can make assertions for non-negative integer values of `a`, `b`, and `m`, where `a` and `m` are less than $2^{64}$, and `b` is less than $2^{32}$."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: easy\nconcepts: error handling, input validation for error messages\n\n### Task", "fingerprint": null, "seed": "void calc_error(const char *s)\n{\n\tstd::cout << s << std::endl;\n}", "id": 26, "concepts": ["error handling", "input validation for error messages"], "instruction": "Implement a C++ class for error messages that maintains a list of error messages and provides methods to add, retrieve, and clear the errors. Ensure input validation for the error messages to be added, raising exceptions for invalid inputs.\n\nThe class should have the following methods:\n\n1. `add_error(error_message)`: Add an error message to the list of errors. Raise an exception if the input is not a string.\n2. `get_errors()`: Return a list of all error messages.\n3. `clear_errors()`: Clear all error messages.\n\nHere's an example implementation of the class:\n\n```cpp\nclass ErrorMessages {\npublic:\n    void add_error(const std::string& error_message) {\n        if (!error_message.empty()) {\n            errors.push_back(error_message);\n        } else {\n            throw std::invalid_argument(\"Error message cannot be empty\");\n        }\n    }\n\n    std::vector<std::string> get_errors() const {\n        return errors;\n    }\n\n    void clear_errors() {\n        errors.clear();\n    }\n\nprivate:\n    std::vector<std::string> errors;\n};\n```\n\nThe class maintains a list of error messages (`errors`) and provides methods to add, retrieve, and clear the error messages. The `add_error` method checks if the input is a valid string and raises an exception if it is empty. The `get_errors` method returns the list of error messages, and the `clear_errors` method clears the list."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: hard\nconcepts: pattern matching, string interpolation, function composition, error handling with exceptions\n\n### Task", "fingerprint": null, "seed": "void p12(Node *h){\n\tNode *p = h;\n\twhile(p){\n\t\tNode *pn = p->next;\n\t\tif(pn == NULL || pn->c != '\\''){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tNode *pnn = pn->next;\n\t\tif(pnn == NULL || (\n\t\t   pnn->c != 's' &&\n\t\t   pnn->c != 'S' &&\n\t\t   pnn->c != 'm' &&\n\t\t   pnn->c != 'M' &&\n\t\t   pnn->c != 'd' &&\n\t\t   pnn->c != 'D')){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tNode *pnnn = pnn->next;\n\t\tif(pnnn == NULL || pnnn->c != ' '){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n//\t\tcout<<\"p12 \"<<p->c<<endl;\n\t\tNode *node = new Node(' ');\n\t\tp = insert(p,node);\n\t\tp = pnnn;\n\t}\n}", "id": 27, "concepts": ["pattern matching", "string interpolation", "function composition", "error handling with exceptions"], "instruction": "Implement a C++ class that parses a string representation of a time duration into its total number of seconds. The class should have the following methods:\n\n- `parse(string)`: parses the string representation and returns the total number of seconds as an integer. If the input format is invalid, the method should raise a ValueError.\n- `format(seconds)`: formats the given number of seconds into a string representation of the format \"{X.Y}{Unit}\", where \"Unit\" is the appropriate time unit and \"X.Y\" is the rounded time duration. For example, `format(61)` should return `'1.0min'`, and `format(86400)` should return `'1.0day'`.\n\nHere are some examples of valid string representations and their corresponding total seconds:\n\n```\n'15s' -> 15\n'2min' -> 120\n'1h' -> 3600\n'1d' -> 86400\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: Node initialization, topic subscription, callback function, spinning\n\n### Task", "fingerprint": null, "seed": "int main(int argc,char **argv){\n    ros::init(argc,argv,\"listener\");\n    ros::NodeHandle n;\n    ros::Subscriber sub=n.subscribe(\"filePub\",1000,chatterCallback);\n    ros::spin();//\u7b2c\u4e00\u6b21\u64cd\u4f5c\n}", "id": 28, "concepts": ["Node initialization", "topic subscription", "callback function", "spinning"], "instruction": "Implement a C++ function `spin_once` that takes a `Node` object as input and performs the following steps:\n\n1. Initialize the Node's topic subscription list if it is not already initialized.\n2. If the Node has any subscribed topics, retrieve the most recent messages from each topic.\n3. For each topic, invoke the corresponding callback function with the retrieved message.\n\nHere is the implementation:\n\n```cpp\nvoid spin_once(Node& node) {\n    if (node.topic_subscriptions.empty()) {\n        node.topic_subscriptions = node.get_topic_subscriptions();\n    }\n\n    for (auto& [topic, callback] : node.topic_subscriptions) {\n        auto message = node.get_latest_message(topic);\n        callback(message);\n    }\n}\n```\n\nThe `spin_once` function takes a `Node` object as input and performs the following steps:\n\n1. Initializes the Node's topic subscription list if it is not already initialized.\n2. If the Node has any subscribed topics, retrieves the most recent messages from each topic.\n3. For each topic, invokes the corresponding callback function with the retrieved message.\n\nBy implementing this function, you ensure that the Node can receive and process messages from multiple topics efficiently."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: linked list traversal with a pointer, character insertion at a specific position, error handling for null pointers\n\n### Task", "fingerprint": null, "seed": "void p8(Node *h){\n\tNode *p = h;\n\twhile(p){\n\t\tNode *pn = p->next;\n\t\tif(pn == NULL || pn->c != '-'){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tNode *pnn = pn->next;\n\t\tif(pnn == NULL || pnn->c != '-'){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n//\t\tcout<<\"p8\"<<endl;\n\t\tNode *node = new Node(' ');\n\t\tp = insert(p,node);\n\t\tnode = new Node(' ');\n\t\tpnn = insert(pnn,node);\n\t\tp = pnn;\n\t}\n}", "id": 29, "concepts": ["linked list traversal with a pointer", "character insertion at a specific position", "error handling for null pointers"], "instruction": "Implement a C++ class named `LinkedList` with a constructor that takes a string as input and initializes an internal linked list. The class should provide the following methods:\n\n`length()`: Returns the length of the linked list.\n`insert_at(index, char)`: Insert a character at the specified index in the linked list. If the index is out of range, the method should raise an IndexError.\n\nThe linked list should be implemented using a node class that stores a character and a pointer to the next node. The class should throw an exception if the input string is empty.\n\nHere's an example of how to use the class:\n\n```cpp\nLinkedList list(\"Hello\");\nassert list.length() == 5;\nlist.insert_at(2, 'l');\nassert list.length() == 6;\nassert list.get_string() == \"Helloworld\";\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: medium\nconcepts: sparse matrix storage, memory allocation and deallocation, data transfer between host and device, error handling with assertions\n\n### Task", "fingerprint": null, "seed": "int test(int size) {\n    if (size <= 0) return 0;\n\n    double *A = new double[size * size];\n    std::fill(A, A + size * size, 0.0);\n\n    if (size > 1) {\n      A[0] =  2.0;\n      A[1] = -1.0;\n      for (int i = 1; i < size - 1; ++i) {\n        A[i * size + i - 1] = -1.0;\n        A[i * size + i    ] =  2.0;\n        A[i * size + i + 1] = -1.0;\n      }\n      A[size * size - 2] = -1.0;\n      A[size * size - 1] =  2.0;\n    } else if (size == 1) {\n      A[0] = 2.0;\n    }\n\n    int *rowptr, *colidx;\n    double *values;\n    full_to_csr_ref(size, size, A, size, &rowptr, &colidx, &values);\n\n    double *d_A;\n    cudaError_t cudaErr = cudaMalloc(reinterpret_cast<void **>(&d_A), size * size * sizeof(double));\n    assert(cudaErr == cudaSuccess);\n\n    cudaErr = cudaMemcpy(d_A, A, size * size * sizeof(double), cudaMemcpyHostToDevice);\n    assert(cudaErr == cudaSuccess);\n\n    int    *d_rowptr, *d_colidx;\n    double *d_values;\n    full_to_csr(size, size, d_A, size, &d_rowptr, &d_colidx, &d_values);\n\n    // Verify results\n    int    *h_rowptr = new int[size + 1];\n    int    *h_colidx = new int[rowptr[size]];\n    double *h_values = new double[rowptr[size]];\n\n    cudaErr = cudaMemcpy(h_rowptr, d_rowptr, (size + 1) * sizeof(int), cudaMemcpyDeviceToHost);\n    assert(cudaErr == cudaSuccess);\n    cudaErr = cudaMemcpy(h_colidx, d_colidx, h_rowptr[size] * sizeof(int), cudaMemcpyDeviceToHost);\n    assert(cudaErr == cudaSuccess);\n    cudaErr = cudaMemcpy(h_values, d_values, h_rowptr[size] * sizeof(double), cudaMemcpyDeviceToHost);\n    assert(cudaErr == cudaSuccess);\n\n    int errcnt = 0;\n    for (int i = 0; i < size + 1; ++i) {\n      if (rowptr[i] != h_rowptr[i]) errcnt += 1;\n    }\n    for (int i = 0; i < rowptr[size]; ++i) {\n      if (colidx[i] != h_colidx[i]) errcnt += 1;\n    }\n    for (int i = 0; i < rowptr[size]; ++i) {\n      if (values[i] != h_values[i]) errcnt += 1;\n    }\n\n    cudaFree(d_A);\n    cudaFree(d_rowptr);\n    cudaFree(d_colidx);\n    cudaFree(d_values);\n\n    delete[] rowptr;\n    delete[] colidx;\n    delete[] values;\n    delete[] h_rowptr;\n    delete[] h_colidx;\n    delete[] h_values;\n\n    return errcnt;\n}", "id": 30, "concepts": ["sparse matrix storage", "memory allocation and deallocation", "data transfer between host and device", "error handling with assertions"], "instruction": "Implement a C++ program that stores a sparse matrix in a compressed form. The program should handle the allocation and deallocation of memory on the host and device, as well as the transfer of data between them. Ensure proper error handling with assertions to verify the validity of inputs."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: hard\nconcepts: string processing, pattern recognition, pointer manipulation\n\n### Task", "fingerprint": null, "seed": "void p1(Node *h){\n\tNode *p = h;\n\tNode *pn = p->next;\n\tif(pn != NULL && pn->c == '\\\"'){\n//\t\tcout<<\"p1\"<<endl;\n\t\tNode *node;\n\t\tnode = new Node('`');\n\t\tp = insert(p,node);\t\t\n\t\tnode = new Node('`');\n\t\tp = insert(p,node);\n\t\tnode = new Node(' ');\n\t\tp = insert(p,node);\n\n\t\tdel(p);\n\t}\n}", "id": 31, "concepts": ["string processing", "pattern recognition", "pointer manipulation"], "instruction": "Implement a C++ function `find_substring_in_string` that searches for a given substring in a given string. The function should return the starting index of the substring in the string, or -1 if the substring is not found.\n\nThe function should use a pointer approach to avoid the use of built-in functions like `find` or `index`. You can assume that the string and substring are both non-empty.\n\nFor example, given `string = \"hello\"` and `substring = \"ell\"`, the function should return 1 because the substring starts at index 1 in the string."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: hard\nconcepts: static function definition, global variable access, function return value\n\n### Task", "fingerprint": null, "seed": "static int8_t CDC_DeInit_FS(void)\r\n{\r\n    /* USER CODE BEGIN 4 */\r\n    return (USBD_OK);\r\n    /* USER CODE END 4 */\r\n}", "id": 32, "concepts": ["static function definition", "global variable access", "function return value"], "instruction": "Implement a C++ class `FunctionCounter` that counts the number of times a given function is called, regardless of the arguments passed to it. The class should have a static function `count(func)` that takes a function as an argument and returns a new function that counts the number of times the original function is called. The returned function should have a `get_count()` method that returns the number of times it has been called.\n\nFor instance, the following code:\n\n```cpp\ndef func(x, y):\n    return x + y\n\ncounter = FunctionCounter.count(func)\ncounter(1, 2)\ncounter(3, 4)\nprint(counter.get_count())\n```\n\nshould output 2, indicating that the function was called twice."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: tokenization, string manipulation, string interpolation, error handling\n\n### Task", "fingerprint": null, "seed": "int main(int argc, char** argv){\n\tstring a;\n\tNode* h;\n\tchar c[20];\n\tistream *in;\n\tif(argc >= 2) in = new ifstream(argv[1]);\n\telse in = &std::cin;\n\n\tostream *out;\n\tif(argc >= 3) out = new ofstream(argv[2]);\n\telse out = &std::cout;\n\n\twhile(getline(*in,a)){\n\t\th = new Node();\n\t\tinit_List(h,a);\n\t\tp1(h);\n\t\tp2(h);\n\t\tp3(h);\n\t\tp4(h);\n\t\tp5(h);\n\t\tp6(h);\n\t\tp7(h);\n\t\tp8(h);\n\t\tp9(h);\n\t\tp10(h);\n\t\tp11(h);\n\t\tp12(h);\n\t\tmemcpy(c,\"'ll\",3); p13(h,c);\n\t\tmemcpy(c,\"'re\",3); p13(h,c);\n\t\tmemcpy(c,\"'ve\",3); p13(h,c);\n\t\tmemcpy(c,\"n't\",3); p13(h,c);\n\t\tmemcpy(c,\"'LL\",3); p13(h,c);\n\t\tmemcpy(c,\"'RE\",3); p13(h,c);\n\t\tmemcpy(c,\"'VE\",3); p13(h,c);\n\t\tmemcpy(c,\"N'T\",3); p13(h,c);\n\n\t\tmemcpy(c,\" cannot \",8); p14(h,c,8,3);\n\t\tmemcpy(c,\" Cannot \",8); p14(h,c,8,3);\n\t\tmemcpy(c,\" d'ye \",6); p14(h,c,6,2);\n\t\tmemcpy(c,\" D'ye \",6); p14(h,c,6,2);\n\t\tmemcpy(c,\" gimme \",7); p14(h,c,7,3);\n\t\tmemcpy(c,\" Gimme \",7); p14(h,c,7,3);\n\t\tmemcpy(c,\" gonna \",7); p14(h,c,7,3);\n\t\tmemcpy(c,\" Gonna \",7); p14(h,c,7,3);\n\t\tmemcpy(c,\" gotta \",7); p14(h,c,7,3);\n\t\tmemcpy(c,\" Gotta \",7); p14(h,c,7,3);\n\t\tmemcpy(c,\" lemme \",7); p14(h,c,7,3);\n\t\tmemcpy(c,\" Lemme \",7); p14(h,c,7,3);\n\t\tmemcpy(c,\" more'n \",8); p14(h,c,8,4);\n\t\tmemcpy(c,\" More'n \",8); p14(h,c,8,4);\n\t\tmemcpy(c,\" 'tis \",6); p14(h,c,6,2);\n\t\tmemcpy(c,\" 'Tis \",6); p14(h,c,6,2);\n\t\tmemcpy(c,\" 'twas \",7); p14(h,c,7,2);\n\t\tmemcpy(c,\" 'Twas \",7); p14(h,c,7,2);\n\t\tmemcpy(c,\" wanna \",7); p14(h,c,7,3);\n\t\tmemcpy(c,\" Wanna \",7); p14(h,c,7,3);\n\n\t\tp15(h);\n//\t\tcout<<\"ok\"<<endl;\n\t\tNode *p = h->next;\n\t\twhile(p){\n\t\t\tif(p->c == '(') (*out)<<\"-LRB-\";\n\t\t\telse if(p->c == ')') (*out)<<\"-RRB-\";\n\t\t\telse if(p->c == '[') (*out)<<\"-LSB-\";\n\t\t\telse if(p->c == ']') (*out)<<\"-RSB-\";\n\t\t\telse if(p->c == '{') (*out)<<\"-LCB-\";\n\t\t\telse if(p->c == '}') (*out)<<\"-RCB-\";\n\t\t\telse (*out)<<p->c;\n\t\t\tp = p->next;\n\t\t}\n\t\t(*out)<<endl;\n\t\tclean_List(h);\n\t}\n\treturn 0;\n}", "id": 33, "concepts": ["tokenization", "string manipulation", "string interpolation", "error handling"], "instruction": "Implement a C++ function `format_response` that takes a string representing a response from a server and formats it for display. The response is expected to be a JSON string containing an error message and a result, both of which can be empty. If the error message is empty, the function should return the result. If the result is empty, the function should return the error message. If both are empty, the function should return the string `\"No response\"`. If the response is not a valid JSON string, the function should raise a ValueError.\n\nFor example, given `response = '{\"error\": \"\", \"result\": \"success\"}'`, the function should return `'success'`. Given `response = '{\"error\": \"server error\", \"result\": \"\"}'`, the function should return `'server error'`. Given `response = '{\"error\": \"\", \"result\": \"\"}'`, the function should return `'No response'`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: medium\nconcepts: priority scheduling algorithm, context switch, average waiting and turnaround time calculation, time complexity/src/extract-code-samples-from-pdf.py\nimport re\nimport sys\nimport os\nimport json\nimport argparse\n\ndef extract_code_samples(text):\n    \"\"\"\n    Extract code samples from a given text.\n    \"\"\"\n    pattern = r\"```.*```\"\n    matches = re.findall(pattern, text, re.DOTALL)\n    return matches\n\ndef main(args):\n    \"\"\"\n    Main function to extract code samples.\n    \"\"\"\n    file_path = args.file_path\n    output_path = args.output_path\n    with open(file_path, \"r\") as file:\n        text = file.read()\n    code_samples = extract_code_samples(text)\n    if not os.path.exists(output_path):\n        os.makedirs(output_path)\n    for index, code_sample in enumerate(code_samples):\n        file_name = f\"code_sample_{index}.txt\"\n        file_path = os.path.join(output_path, file_name)\n        with open(file_path, \"w\") as file:\n            file.write(code_sample)\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"Extract code samples from a given file.\")\n    parser.add_argument(\"--file_path\", type=str, help=\"Path of the file to extract code samples from.\")\n    parser.add_argument(\"--output_path\", type=str, help=\"Path of the directory to save the extracted code samples.\")\n    args = parser.parse_args()\n    main(args)\n/src/extract-code-samples-from-pdf.sh\n#!/bin/bash\n\npdftotext $1 $1.txt\npython extract-code-samples-from-pdf.py --file_path $1.txt --output_path code_samples\n/src/extract-code-samples-from-pdf.cpp\n#include <iostream>\n#include <regex>\n#include <string>\n#include <vector>\n\nstd::vector<std::string> extractCodeSamples(const std::string& text) {\n    std::vector<std::string> codeSamples;\n    std::regex regex(\"```.*```\");\n    std::sregex_iterator it(text.begin(), text.end(), regex);\n    std::sregex_iterator end;\n    while (it != end) {\n        codeSamples.push_back(it->str());\n        ++it;\n    }\n    return codeSamples;\n}\n\nint main() {\n    std::string text = \"This is a string containing ```code samples``` and other text.\";\n    std::vector<std::string> codeSamples = extractCodeSamples(text);\n    for (const std::string& codeSample : codeSamples) {\n        std::cout << codeSample << std::endl;\n    }\n    return 0;\n}\n\n### Task", "fingerprint": null, "seed": "int main()\n{\n\tint n;\n\tint avgta=0;\n\tint avgwt=0;\n\tcout<<\"Enter number process:\";cin>>n;\n\tPriority*ob=new Priority[n];\n\t\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>ob[i];\n\t}\n\n\tfor(int i=0;i<n;i++)\n \t{\n\t\tfor(int j=i;j<n;j++)\n  \t\t{\n   \t\t\tif(ob[i].pt<ob[j].pt)\n   \t\t\t{\n\t\t\t\tMyswap(ob[i],ob[j]);\n   \t\t\t}\n   \t\t\tif(ob[i].pt==ob[j].pt&&ob[i].bt>ob[j].bt)\n   \t\t\t{\n\t\t\t    Myswap(ob[i],ob[j]);\t\t\n   \t\t\t}\t\n  \t\t}\n \t}\n\n\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tob[i].calc_ct();\n\t\tob[i].calc_ta();\n\t\tob[i].calc_wt();\n\t\tavgta+=ob[i].ta;\n\t\tavgwt+=ob[i].wt;\n\t}\n\n\tfor(int i=0;i<n;i++)\n\t{\t\n\t\tcout<<ob[i];\n \t\tcout<<\"ta: \"<<ob[i].ta<<endl;\n \t\tcout<<\"wt: \"<<ob[i].wt<<endl;\n\t\tcout<<endl;\n\t}\n\n\tcout<<\"Avg wating time: \"<<(avgwt/n)<<endl;\n\tcout<<\"Avg turn around time: \"<<(avgta/n)<<endl;\n\n\tdelete []ob;\n\treturn 0;\n}", "id": 34, "concepts": ["priority scheduling algorithm", "context switch", "average waiting and turnaround time calculation", "time complexity/src/extract-code-samples-from-pdf.py\nimport re\nimport sys\nimport os\nimport json\nimport argparse\n\ndef extract_code_samples(text):\n    \"\"\"\n    Extract code samples from a given text.\n    \"\"\"\n    pattern = r\"```.*```\"\n    matches = re.findall(pattern", "text", "re.DOTALL)\n    return matches\n\ndef main(args):\n    \"\"\"\n    Main function to extract code samples.\n    \"\"\"\n    file_path = args.file_path\n    output_path = args.output_path\n    with open(file_path", "\"r\") as file:\n        text = file.read()\n    code_samples = extract_code_samples(text)\n    if not os.path.exists(output_path):\n        os.makedirs(output_path)\n    for index", "code_sample in enumerate(code_samples):\n        file_name = f\"code_sample_{index}.txt\"\n        file_path = os.path.join(output_path", "file_name)\n        with open(file_path", "\"w\") as file:\n            file.write(code_sample)\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"Extract code samples from a given file.\")\n    parser.add_argument(\"--file_path\"", "type=str", "help=\"Path of the file to extract code samples from.\")\n    parser.add_argument(\"--output_path\"", "type=str", "help=\"Path of the directory to save the extracted code samples.\")\n    args = parser.parse_args()\n    main(args)\n/src/extract-code-samples-from-pdf.sh\n#!/bin/bash\n\npdftotext $1 $1.txt\npython extract-code-samples-from-pdf.py --file_path $1.txt --output_path code_samples\n/src/extract-code-samples-from-pdf.cpp\n#include <iostream>\n#include <regex>\n#include <string>\n#include <vector>\n\nstd::vector<std::string> extractCodeSamples(const std::string& text) {\n    std::vector<std::string> codeSamples;\n    std::regex regex(\"```.*```\");\n    std::sregex_iterator it(text.begin()", "text.end()", "regex);\n    std::sregex_iterator end;\n    while (it != end) {\n        codeSamples.push_back(it->str());\n        ++it;\n    }\n    return codeSamples;\n}\n\nint main() {\n    std::string text = \"This is a string containing ```code samples``` and other text.\";\n    std::vector<std::string> codeSamples = extractCodeSamples(text);\n    for (const std::string& codeSample : codeSamples) {\n        std::cout << codeSample << std::endl;\n    }\n    return 0;\n}"], "instruction": "Implement a C++ function to extract code samples from a given text. The function should use a regular expression to match the code samples, which are enclosed within triple backticks (```). The function should return a vector of strings, where each string represents a single code sample.\n\nTo test the function, create a string containing multiple code samples and verify that the function returns the correct number of code samples and the correct content."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: hard\nconcepts: root mean square calculation, mathematical formula implementation\n\n### Task", "fingerprint": null, "seed": "double rootMeanSquare(double valueSum, int valueCount) {\n  return sqrt(valueSum / valueCount);\n}", "id": 35, "concepts": ["root mean square calculation", "mathematical formula implementation"], "instruction": "Implement a function `rms` in C++ to calculate the root mean square of a given sequence of numbers. The root mean square is defined as the square root of the arithmetic mean of the squares of the numbers. The function should accept any iterable object as the input sequence. If the input is empty, the function should return 0.\n\nFor example, for `rms([1, 2, 3])`, the function should return 1.826."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: medium\nconcepts: breadth-first search (BFS) algorithm for graph traversal, tomato farming simulation\n\n### Task", "fingerprint": null, "seed": "void bfs() {\n\twhile (!q.empty()) {\n\t\tbool flag = true;\n\t\tint qs = q.size();\n\t\tcnt++;\n\t\twhile (qs--) {\n\t\t\tint x = q.front().x;\n\t\t\tint y = q.front().y;\n\t\t\tint z = q.front().z;\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\tint nx = x + dr[i];\n\t\t\t\tint ny = y + dc[i];\n\t\t\t\tint nz = z + dz[i];\n\t\t\t\tif (nx <= 0 || nx > n || ny <= 0 || ny > m || nz <= 0 || nz > h) continue;\n\n\t\t\t\tif (map1[nx][ny][nz] == '0') {\n\t\t\t\t\ttomato++;\n\t\t\t\t\tmap1[nx][ny][nz] = '1';\n\t\t\t\t\tq.push({ nx,ny, nz });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "id": 36, "concepts": ["breadth-first search (BFS) algorithm for graph traversal", "tomato farming simulation"], "instruction": "Your task is to simulate a tomato farming system using a graph-based approach. The farm consists of a set of tomato plants, each of which has a unique ID, and a set of paths connecting them. The paths can be traversed in both directions.\n\nEach plant has a state, which can be either 'seed', 'sprouting', or 'ripe'. The initial state of each plant is 'seed'. A seed can become a sprouting plant if at least one of its paths is occupied by a sprouting or ripe plant. Similarly, a sprouting plant becomes ripe if at least one of its paths is occupied by a ripe plant.\n\nYour program should simulate the growth of plants over time. For each time step, the program should perform the following steps:\n\n1. Identify all plants that can become sprouting based on the current state of their paths.\n2. Update the state of all sprouting plants to 'sprouting'.\n3. Identify all plants that can become ripe based on the current state of their paths.\n4. Update the state of all ripe plants to 'ripe'.\n\nYour program should also support the following operations:\n\n1. `add_plant(id)`: Add a new plant with the given ID to the farm.\n2. `add_path(id1, id2)`: Add a path connecting the two plants with the given IDs.\n3. `remove_plant(id)`: Remove a plant with the given ID from the farm.\n4. `remove_path(id1, id2)`: Remove the path connecting the two plants with the given IDs.\n5. `get_state(id)`: Retrieve the current state of a plant with the given ID.\n\nYour program should handle invalid operations gracefully by throwing appropriate exceptions."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: main loop for continuous operation, RMS measurement and calculation, integer transmission per print\n\n### Task", "fingerprint": null, "seed": "void loop() {\n  measureAndCalculateRMS();\n  sendValuesAsIntegerPerPrint(rmsFrontSensor, rmsBackSensor);\n}", "id": 37, "concepts": ["main loop for continuous operation", "RMS measurement and calculation", "integer transmission per print"], "instruction": "Implement a C++ function to continuously measure the RMS (root mean square) value of a voltage signal and print the result every 100 milliseconds. The RMS value is calculated as the square root of the mean of the squares of the values in the signal. Since the signal is continuous, it is transmitted as a sequence of integers. Each integer represents a 10-millisecond segment of the signal."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: product management system, user interface handling, program flow control\n\n### Task", "fingerprint": null, "seed": "int main() {\n    ProductManager manager;\n\n    while (manager.canAddProduct()) {\n        handleUI(manager);\n    }\n}", "id": 38, "concepts": ["product management system", "user interface handling", "program flow control"], "instruction": "Design a C++ program to simulate a simplified product management system. The system should allow users to perform the following operations:\n\n- Add a new product with a unique ID and a name\n- Remove an existing product by ID\n- Update an existing product's name by ID\n- Retrieve a product's information by ID\n- List all products in the system\n\nYour program should handle invalid user inputs and ensure data consistency by using appropriate data structures and error handling."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: layout and formatting for tabular data, indexing and iteration for array access\n\n### Task", "fingerprint": null, "seed": "void DisplayItem(InventoryItem* const e)\n{\n   for(int index = 0; index < 5; index++)\n   {\n\t   cout << setw(5) << index + 1\n\t\t   << setw(20) << e[index].getDescription()\n\t\t   << setw(20) << e[index].getUnits() << endl;\n   }\n}", "id": 40, "concepts": ["layout and formatting for tabular data", "indexing and iteration for array access"], "instruction": "Create a C++ function `create_matrix(rows, cols, val)` to construct a matrix of size `rows x cols` with each element initialized to `val`. The function should satisfy the following assertions:\n\n```cpp\nassert create_matrix(2, 3, 5) == [[5, 5, 5], [5, 5, 5]]\nassert create_matrix(1, 1, 1) == [[1]]\nassert create_matrix(0, 0, 0) == []\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: graph traversal, depth-first search, breadth-first search, count paths from one node to another\n\n### Task", "fingerprint": null, "seed": "int main()\r\n{\r\n\tint T;\r\n\tcin >> T;\r\n\twhile (T--) {\r\n\t\tint N, M;\r\n\t\tcin >> N >> M;\r\n\t\tint u, v;\r\n\t\tGraph g(N);\r\n\t\twhile (M--) {\r\n\t\t\tcin >> u >> v;\r\n\t\t\tg.addEdge(u, v);\r\n\t\t}\r\n\t\tint s, e;\r\n\t\tcin >> s >> e;\r\n\t\tcout << g.countPaths(s, e) << endl;\r\n\t}\r\n\treturn 0;\r\n}", "id": 41, "concepts": ["graph traversal", "depth-first search", "breadth-first search", "count paths from one node to another"], "instruction": "Implement a C++ class `Graph` with the following methods:\n\n- `add_edge(u, v)`: Add an edge from node `u` to node `v` to the graph.\n- `count_paths(u, v)`: Return the number of paths from node `u` to node `v` in the graph, where a path is a sequence of nodes that starts from `u` and ends at `v` and follows the edges.\n\nYour implementation should support the following assertions:\n\n```cpp\ngraph = Graph()\ngraph.add_edge(0, 1)\ngraph.add_edge(1, 2)\ngraph.add_edge(2, 3)\ngraph.add_edge(3, 4)\nassert graph.count_paths(0, 4) == 1\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: event-driven programming, state-machine design, sensor handling\n\n### Task", "fingerprint": null, "seed": "void update_status() {    \n    if (!occupied && auto_mode)\n        if (num_hits > 1)    // at least two sensors fired - occupy the room\n            occupy_room();\n    if (num_hits > 0)        // at least one fired; so the room is in use\n          tick_counter = 0;  // keep resetting it, if there is any motion\n    tick_counter++;          // Note: the sensors can keep tick_counter perpetually zero! So,\n    status_counter++;        // you need a separate status_counter\n\n    if (status_counter == status_ticks) { \n        send_status();\n        status_counter = 0;\n    }\n    if (tick_counter == buzzer_ticks) {\n        if (occupied && auto_mode)\n            warn();  // warn about the imminent release\n    }\n    else        \n    if (tick_counter >= release_ticks){\n         tick_counter = 0;\n         if (occupied && auto_mode)\n            release_room();  \n    }  \n}", "id": 42, "concepts": ["event-driven programming", "state-machine design", "sensor handling"], "instruction": "Implement a C++ class `TemperatureSensor` with the following requirements:\n- Handle the following temperature sensor events: `RISING_EDGE`, `FALLING_EDGE`, `HIGH_TEMP`, `LOW_TEMP`, `HIGH_TEMP_FOR_LONG_TIME`, `LOW_TEMP_FOR_LONG_TIME`, `NO_TEMP_FOR_LONG_TIME`.\n- Maintain the current state of the sensor, including the current temperature and the duration since the last temperature change.\n- Define state transitions based on the sensor events and the current state.\n- Provide the current state of the sensor as a string representation."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: hard\nconcepts: beeping mechanism for different modes, active-low buzzer control, switch-case to handle different actions\n\n### Task", "fingerprint": null, "seed": "void beeper (int mode) {\n    switch (mode) {\n      case 0: // useful before entering T.update loop\n          digitalWrite(buzzer, LOW);  // active low\n          delay(200);  \n          digitalWrite(buzzer, HIGH);\n          break;\n      case 1:\n          T.pulse(buzzer, 4000, HIGH); // active low\n          break;\n      default:\n          T.pulse(buzzer, 200, HIGH); // active low\n          break;\n    }\n}", "id": 43, "concepts": ["beeping mechanism for different modes", "active-low buzzer control", "switch-case to handle different actions"], "instruction": "Implement a C++ function `beep(mode)` that controls a beeping mechanism with a buzzer. The buzzer must beep in different modes depending on the input:\n- mode 0: beep once\n- mode 1: beep twice\n- mode 2: beep three times\n\nThe buzzer is active-low, which means a low logical level turns it on. Design the function to handle these different modes using a switch-case statement."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: recursive function, base case, modulo operation, Euclidean algorithm\n\n### Task", "fingerprint": null, "seed": "int gcd(int a,int b)\n{\n    if(b==0)\n    {\n        return a;\n    }\n\n    return(gcd(b,a%b));\n}", "id": 44, "concepts": ["recursive function", "base case", "modulo operation", "Euclidean algorithm"], "instruction": "Implement a C++ function `gcd_recursive` to find the greatest common divisor (GCD) of two positive integers using recursion. The function should satisfy the following assertions:\n\n```cpp\nassert gcd_recursive(12, 16) == 4\nassert gcd_recursive(1071, 462) == 21\nassert gcd_recursive(117, 45) == 9\n```\n\nThe function should use the Euclidean algorithm, which states that the GCD of two numbers is the same as the GCD of the smaller number and the remainder when the larger number is divided by the smaller number. This algorithm can be expressed recursively."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: medium\nconcepts: looping through code, updating a network\n\n### Task", "fingerprint": null, "seed": "void loop() {\n    T.update();   \n    mesh.update();   // keep the network updated\n}", "id": 45, "concepts": ["looping through code", "updating a network"], "instruction": "Given the following code snippet, complete the implementation of the function `update_network` to update the network based on the provided instructions.\n\nThe function should take a list of instructions and a dictionary representing a network as inputs. The instructions are represented as a list of lists, where each inner list contains the following elements:\n\n- source: the source node in the network\n- action: either \"add\" or \"remove\"\n- target: the target node in the network\n\nThe function should loop through the instructions and perform the specified action on the network, either adding or removing the appropriate edge.\n\nThe network is represented as a dictionary, where the keys are nodes and the values are lists of neighboring nodes.\n\nFor example, given the instructions `instructions = [[\"A\", \"add\", \"B\"], [\"A\", \"remove\", \"B\"]]` and the network `network = {\"A\": [\"B\", \"C\"]}`, the function should update the network as follows:\n\n- After the first instruction, the network becomes `{\"A\": [\"B\", \"C\"], \"B\": [\"A\"]}`\n- After the second instruction, the network becomes `{\"A\": [\"C\"]}`\n\nYour task is to complete the implementation of the function `update_network` to update the network based on the provided instructions."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: hard\nconcepts: command-line argument parsing, JSON configuration parsing, graphical output, error handling, usage information generation\n\n### Task", "fingerprint": null, "seed": "int main(int argc, char** argv)\r\n{\r\n\r\n\tint next_option;\r\n\r\n\t/* A string listing valid short options letters.  */\r\n\tconst char* const short_options = \"hc:sxgvna:\";\r\n\t/* An array describing valid long options.  */\r\n\tconst struct option long_options[] =\r\n\t{\r\n\t{ \"help\", 0, NULL, 'h' },\r\n\t{ \"config\", 1, NULL, 'c' },\r\n\t{ \"standard\", 0, NULL, 's' },\r\n\t{ \"xml\", 0, NULL, 'x' },\r\n\t{ \"graphic\", 0, NULL, 'g' },\r\n\t{ \"verbose\", 0, NULL, 'v' },\r\n\t{ \"height\", 1, NULL, 'e' },\r\n\t{ \"width\", 1, NULL, 'w' },\r\n\t{ \"rough\", 1, NULL, 'r' },\r\n\t{ \"seed\", 1, NULL, 'd' },\r\n\t{ \"offset\", 1, NULL, 'f' },\r\n\t{ \"plate\", 1, NULL, 'p' },\r\n\t{ \"erosion\", 1, NULL, 'o' },\r\n\t{ \"negative\", 0, NULL, 'n' },\r\n\t{ \"randomseed\", 1, NULL, 'a' },\r\n\t{ NULL, 0, NULL, 0 } /* Required at end of array.  */\r\n\t};\r\n\r\n\t/* Remember the name of the program, to incorporate in messages.\r\n\t The name is stored in argv[0].  */\r\n\tchar* program_name = argv[0];\r\n\r\n\tif (fopen(config_file.c_str(), \"r\"))\r\n\t\tread_json_config();\r\n\r\n\tdo\r\n\t{\r\n\r\n\t\tnext_option = getopt_long(argc, argv, short_options, long_options,\r\n\t\t\t\tNULL);\r\n\t\tswitch (next_option)\r\n\t\t{\r\n\t\tcase 'h': /* -h or --help */\r\n\t\t\t/* User has requested usage information.  Print it to standard\r\n\t\t\t output, and exit with exit code zero (normal termination).  */\r\n\t\t\tprint_usage(stdout, 0, program_name);\r\n\t\t\tbreak;\r\n\r\n\t\t\tcase 'c': //config file\r\n\r\n\t\t\t\t\tif(strcmp(config_file.c_str(),optarg) != 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tconfig_file = optarg;\r\n\t\t\t\t\t\tread_json_config();\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 's': /* -s --standard */\r\n\r\n\t\t\t\t\t//Use default output format\r\n\t\t\t\t\t//do nothing\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'x': /* -x --xml*/\r\n\r\n\t\t\t\t\t//Use xml output format\r\n\t\t\t\t\toutput_format = STANDARD_XML;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'g': /* -g --graphical*/\r\n\r\n\t\t\t\t\t//Display the map as 3d opengl representation\r\n\t\t\t\t\toutput_format = OPENGL_VIEW;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'v': /* -v or --verbose */\r\n\t\t\t\t\tverbose = 1;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'e': /* --height use next argument as crop height */\r\n\r\n\t\t\t\t\tcrop_height = atoi(optarg);\r\n\t\t\t\t\tif(crop_height < 1)\r\n\t\t\t\t\tprint_usage(stderr, 1, program_name);\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'w': /* --width use next argument as crop width */\r\n\r\n\t\t\t\t\tcrop_width = atoi(optarg);\r\n\t\t\t\t\tif(crop_width < 1)\r\n\t\t\t\t\tprint_usage(stderr, 1, program_name);\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'r': /* --rough roughness ratio */\r\n\r\n\t\t\t\t\toffset_dr = atof(optarg);\r\n\t\t\t\t\tif(offset_dr<0 || offset_dr>1)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tprint_usage(stderr, 1, program_name);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'd': /* --seed value */\r\n\r\n\t\t\t\t\tseed = atoi(optarg);\r\n\t\t\t\t\tif(seed<0)\r\n\t\t\t\t\tprint_usage(stderr, 1, program_name);\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'f': /* --offset value */\r\n\r\n\t\t\t\t\trandom_offset = atoi(optarg);\r\n\t\t\t\t\tif(random_offset<0)\r\n\t\t\t\t\tprint_usage(stderr, 1, program_name);\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'p': /* --plate  vonornoi interpolation value */\r\n\r\n\t\t\t\t\tvoronoi_alpha = atof(optarg);\r\n\t\t\t\t\tif(voronoi_alpha<0 || voronoi_alpha>1)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tprint_usage(stderr, 1, program_name);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'o': /* --erosion number of erosion iterations */\r\n\r\n\t\t\t\t\terosion_steps = atoi(optarg);\r\n\t\t\t\t\tif(erosion_steps<0)\r\n\t\t\t\t\tprint_usage(stderr, 1, program_name);\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'n': /* allow negative values */\r\n\r\n\t\t\t\t\tneg = true;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'a': /* random seed value */\r\n\r\n//\t\t\tsrand ( time(NULL) );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase '?': /* The user specified an invalid option.  */\r\n\t\t\t\t\t/* Print usage information to standard error, and exit with exit\r\n\t\t\t\t\t code one (indicating abnormal termination).  */\r\n\t\t\t\t\tprint_usage(stderr, 1, program_name);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase -1: /* Done with options.  */\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault: /* Something else: unexpected.  */\r\n\t\t\t\t\tabort();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t} while (next_option != -1);\r\n\r\n\tgenerate();\r\n\r\n\treturn 0;\r\n}", "id": 46, "concepts": ["command-line argument parsing", "JSON configuration parsing", "graphical output", "error handling", "usage information generation"], "instruction": "Design a C++ function `draw_plot(args)` that takes command-line arguments and generates a graphical output using the provided configuration. The function should support the following arguments:\n\n- `-c, --config`: JSON configuration file that specifies the data to be plotted, including the title, x-axis label, y-axis label, and data points.\n- `-o, --output`: Path to the output file (PNG or PDF format).\n\nIf no arguments are provided, the function should print usage information. If the configuration file or output file cannot be opened, the function should print an error message and exit with a non-zero status code.\n\nHere's an example usage of the function:\n\n```cpp\ndraw_plot(\n    [\n        \"-c\",\n        \"config.json\",\n        \"-o\",\n        \"plot.png\",\n    ]\n)\n```\n\nThe configuration file `config.json` should have the following format:\n\n```json\n{\n    \"title\": \"My Plot\",\n    \"x_label\": \"X-axis\",\n    \"y_label\": \"Y-axis\",\n    \"data\": [\n        [1, 2],\n        [2, 3],\n        [3, 4]\n    ]\n}\n```\n\nThe function should generate a plot with the title \"My Plot\", x-axis label \"X-axis\", y-axis label \"Y-axis\", and three data points [(1, 2), (2, 3), (3, 4)]. The output will be saved as a PNG or PDF file depending on the extension specified in the `-o` argument."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: value iteration, 2D grid traversal, sample collection, progress tracking, time estimation\n\n### Task", "fingerprint": null, "seed": "int main(int argc, char *argv[]) {\n    SwarmValues *v = new SwarmValues();\n    v->proj_weight = 0;\n    v->align_weight = 0;\n    v->noise_weight = 1-v->proj_weight-v->align_weight;\n\n    environment_food_init(200);\n    Environment *env = new Environment();\n    env->onDraw = &environment_food_onDraw;\n    env->onFrame = &environment_food_onFrame;\n\n/*\n    //environment_food_init(200);\n    Environment *env = new Environment();\n    env->onDraw = &environment_displacement_onDraw;\n    env->onFrame = &environment_displacement_onFrame;\n*/\n    Simulation *s = new Simulation(50, v);\n    s->reset();\n    s->setEnvironment(env); //uncomment this to add an environment\n\n    //s->runSimulation(10000);\n\n    double i, j;\n    int k;\n    double step = 0.04;\n    #define SAMPLE_NUMBER 7\n    #define RUN_TIME 1000\n\n    float progress = 0.0;\n    float progress_step_size = 1.0/(float)( ((1/step)*(1/step))/2);\n    //                                      ^Points in a grid      \n\n    long start_time = time(NULL);\n\n    cerr << endl;\n    cerr << \"                                                                   \\r\";\n\n        cout << \"  [\" << endl; //Grid start\n        for(i=0.0; i<1.0; i+=step) {\n            cout << \"    [\" << endl; //Row start\n            for(j=0.0; j<1.0; j+=step) {\n                long long value_a[SAMPLE_NUMBER] = {0};\n                if(i+j<=1.0) {\n                    //long runCount = 0;\n                    for(k=0; k<SAMPLE_NUMBER; k++) {\n                        s->reset();\n                        srand(time(NULL) ^ (k<<8) ^ ((int)i<<16) ^ ((int)j<<24));\n                        v->proj_weight = i;\n                        v->align_weight = j;\n                        v->noise_weight = 1 - v->proj_weight - v->align_weight;\n                        s->setSwarmValues(v);\n                        //environment_displacement_init(200);\n                        environment_food_init(200);\n                        s->setScore(0);\n                        s->runSimulation(RUN_TIME);\n                        environment_food_destroy();\n                        //if(s->getScore() >=0) {\n                           // runCount++;\n                            value_a[k] = s->getScore();\n                        //}\n                        //environment_displacement_destroy();\n                    }\n                    sort(value_a, value_a+SAMPLE_NUMBER);\n                    cout << \"      [\"; //COL start\n                    for(int a=0; a<SAMPLE_NUMBER; a++) {\n                        cout<<value_a[a];\n                        if(a != SAMPLE_NUMBER-1) cout << \",\";\n                    }\n                    cout << \"],\" << endl; //COL end\n\n                    //Give an indication of the progress so far\n                    progress += progress_step_size;\n\n                    long time_taken = time(NULL)-start_time;\n                    long total_time_prediction = time_taken * 1/progress;\n\n                    // Carriage return (\\r) makes it re-write the line again\n                    // with the up to date information\n                    cerr << \"\\r Progress: \";\n\n                    fprintf(stderr, \"%5.2f\", progress*100 );\n                    cerr << \"%   Remaining: \" \n                            << ((total_time_prediction-time_taken)/60.0)\n                            << \"min       \\r\";\n                } else {\n                    cout << \"      [],\" << endl;\n                }\n                //cout << value << \" \";\n            }\n            cout << \"      []\" << endl; //To fix the floating comma in the row\n            cout << \"    ],\" << endl; //ROW end\n        }\n        cout << \"    []\" << endl; //To fix the floating comma in the column\n        cout << \"  ]\" << endl; // end GRID\n\n\n    //Print info on the time taken\n    cerr << endl << endl;\n    long time_taken = time(NULL)-start_time;\n    int hours = floor(time_taken/(60*60));\n    int mins = floor((time_taken%60)/(60));\n    int secs = floor((time_taken%(60*60)));\n    cerr << \"Time taken: \"\n            << hours << \"h \"\n            << mins  << \"m \"\n            << secs   << \"s\"\n            << \"  (\" << time_taken << \"s)\"\n            << endl;\n\n    delete s;\n    delete v;\n    delete env;\n}", "id": 47, "concepts": ["value iteration", "2D grid traversal", "sample collection", "progress tracking", "time estimation"], "instruction": "Implement a C++ function `collect_samples(grid, start, end)` to collect samples from a 2D grid. Given a `grid` containing 0s and 1s, where 0 represents a sample and 1 represents an obstacle, you need to collect all the samples from `start` to `end` in the grid. Your path should avoid obstacles and collect as many samples as possible. You can move in four directions: up, down, left, and right. Use value iteration to update the number of samples collected at each cell and track your progress."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: hard\nconcepts: operator overloading for `++` and custom type `Elev`, encapsulation and abstraction\n\n### Task", "fingerprint": null, "seed": "int main(int argc, char *argv[]) {\n    Elev elev;\n    cout << elev.GetAge() << endl;\n    ++elev;\n    cout << elev.GetAge() << endl;\n    elev++;\n    cout << elev.GetAge() << endl;\n    return 0;\n}", "id": 48, "concepts": ["operator overloading for `++` and custom type `Elev`", "encapsulation and abstraction"], "instruction": "Implement a custom `Elev` class with a `floor` attribute and a `++` operator overload to increment the `floor` by 1. Design the `Elev` class to encapsulate the `floor` attribute and provide a getter method to access the current floor, but not a setter method. The `++` operator overload should be implemented as a prefix increment (e.g., `++elev`) and should return a reference to the `Elev` object itself."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: hard\nconcepts: node insertion, node deletion, special character handling, text formatting\n\n### Task", "fingerprint": null, "seed": "void p2(Node *h){\n\tNode *p = h;\n\twhile(p){\n\t\tNode *pn = p->next;\n\t\tif(pn == NULL || (pn->c != '(' &&\n\t\t   pn->c != '[' &&\n\t\t   pn->c != ' ' &&\n\t\t   pn->c != '{' &&\n\t\t   pn->c != '<')){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tNode *pnn = pn->next;\n\t\tif(pnn == NULL || pnn->c != '\\\"'){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n//\t\tcout<<\"p2\"<<endl;\n\t\tNode *node;\n\t\tnode = new Node(' ');\n\t\tpn = insert(pn,node);\n\t\tnode = new Node('`');\n\t\tpn = insert(pn,node);\n\t\tnode = new Node('`');\n\t\tpn = insert(pn,node);\n\t\tnode = new Node(' ');\n\t\tpn = insert(pn,node);\n\t\t\n\t\tdel(pn);\n\t\tp = pn;\n\t}\n}", "id": 49, "concepts": ["node insertion", "node deletion", "special character handling", "text formatting"], "instruction": "Implement a C++ program that performs the following tasks:\n1. Read a text file and store each line as a separate node in a linked list.\n2. Each node should contain a line number, the line itself, and a pointer to the next node.\n3. The program should provide an interface to insert a new line at a given position, delete a line at a given position, and save the updated list back to the original text file.\n4. The program should handle special characters like newlines, tabs, and other whitespace characters to maintain the original formatting."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: hard\nconcepts: API function call for USB initialization, memory allocation for data buffers, return value handling for status\n\n### Task", "fingerprint": null, "seed": "static int8_t CDC_Init_FS(void)\r\n{\r\n    /* USER CODE BEGIN 3 */\r\n    /* Set Application Buffers */\r\n    USBD_CDC_SetTxBuffer(&hUsbDeviceFS, UserTxBufferFS, 0);\r\n    USBD_CDC_SetRxBuffer(&hUsbDeviceFS, UserRxBufferFS);\r\n    return (USBD_OK);\r\n    /* USER CODE END 3 */\r\n}", "id": 50, "concepts": ["API function call for USB initialization", "memory allocation for data buffers", "return value handling for status"], "instruction": "Implement a C++ class `USBDevice` that represents a USB device connected to the system. The class should have the following methods:\n\n- `initialize()`: Initializes the USB device. This method should call the API function `libusb_init` to initialize the device and return the result as an integer status code.\n- `allocate_data_buffer(size)`: Allocates a buffer of the specified size in bytes for data transfer. This method should call the API function `libusb_alloc_transfer` to allocate the buffer and return a pointer to the buffer as an integer pointer.\n- `deallocate_data_buffer(pointer)`: Deallocates the data buffer pointed to by the specified pointer. This method should call the API function `libusb_free_transfer` to deallocate the buffer.\n\nHere are some sample assertions to test the `initialize` method:\n\n```cpp\ndevice = USBDevice()\nstatus = device.initialize()\nassert status == 0\nstatus = device.initialize()\nassert status == 0\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: medium\nconcepts: setup function for initialization, state preparation, dependency resolution\n\n### Task", "fingerprint": null, "seed": "void setup()\n{\n}", "id": 51, "concepts": ["setup function for initialization", "state preparation", "dependency resolution"], "instruction": "Implement a C++ program that defines a class named `Component` with a constructor and a `setup` function. The `setup` function should run the following steps in order:\n1. Retrieve the list of dependencies from the class attributes\n2. Sort the dependencies based on their order\n3. Initialize each component in the sorted order\n\nFor example, assume that `ComponentA` depends on `ComponentB` and `ComponentC` in that order. The `setup` function should initialize `ComponentB` first, then `ComponentC`, and finally `ComponentA`.\n\nHere's a sample implementation of the `Component` class in C++:\n\n```cpp\nclass Component {\npublic:\n    Component() {}\n    virtual void setup() = 0;\n\nprotected:\n    std::vector<Component*> dependencies;\n};\n```\n\nNow let's implement the `ComponentA`, `ComponentB`, and `ComponentC` classes that inherit from the base `Component` class. We'll also define the `setup` function for each component:\n\n```cpp\nclass ComponentA : public Component {\npublic:\n    ComponentA() {}\n    void setup() override {\n        for (Component* dependency : dependencies) {\n            dependency->setup();\n        }\n        // Do component-specific setup tasks\n    }\n};\n\nclass ComponentB : public Component {\npublic:\n    ComponentB() {}\n    void setup() override {\n        for (Component* dependency : dependencies) {\n            dependency->setup();\n        }\n        // Do component-specific setup tasks\n    }\n};\n\nclass ComponentC : public Component {\npublic:\n    ComponentC() {}\n    void setup() override {\n        for (Component* dependency : dependencies) {\n            dependency->setup();\n        }\n        // Do component-specific setup tasks\n    }\n};\n```\n\nNotice that each `setup` function calls `setup` on each dependency before performing component-specific tasks. This ensures that dependencies are initialized before the component itself.\n\nNow let's create instances of the components and define their dependencies:\n\n```cpp\nComponentA* componentA = new ComponentA();\nComponentB* componentB = new ComponentB();\nComponentC* componentC = new ComponentC();\n\ncomponentA->dependencies.push_back(componentB);\ncomponentA->dependencies.push_back(componentC);\n```\n\nFinally, we can invoke the `setup` function on the top-level component, which will recursively initialize all the dependencies:\n\n```cpp\ncomponentA->setup();\n```\n\nBy following these steps, we ensure that the components are initialized in the correct order, resolving any dependencies."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: function pointer call, parameter passing and processing, bitwise operation for masking\n\n### Task", "fingerprint": null, "seed": "void fpcM_PauseDisable(void* pProc, u8 param_2) {\n    fpcPause_Disable((process_node_class*)pProc, param_2 & 0xFF);\n}", "id": 52, "concepts": ["function pointer call", "parameter passing and processing", "bitwise operation for masking"], "instruction": "Implement a C++ function `call_function_with_mask` that takes a pointer to a function `func` and two integer arguments `x` and `mask`. The function should call `func` with the argument `(x & mask)`, where `&` denotes the bitwise AND operation.\n\nFor example, if `func` is a function that adds two numbers, and `x = 5` and `mask = 3`, the function should call `func` with the argument `(5 & 3) = 1`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: hard\nconcepts: C++ class definition, function signature, object initialization\n\n### Task", "fingerprint": null, "seed": "void DiscreteMasterProperty__bool___ObjInit_2(DiscreteMasterProperty__bool* __this, ::app::Uno::UX::Property__bool* property, ::app::Fuse::Animations::MixerBase* mixerBase)\n{\n    ::app::Fuse::Animations::MasterProperty__bool___ObjInit_1(__this, property, mixerBase);\n}", "id": 53, "concepts": ["C++ class definition", "function signature", "object initialization"], "instruction": "Implement a C++ function `is_valid_parenthesis_sequence(s)` to determine if a given string `s` of opening and closing parenthesis is valid. A string is valid if each opening parenthesis has a corresponding closing parenthesis.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert is_valid_parenthesis_sequence('(())') == true\nassert is_valid_parenthesis_sequence('(()))') == false\nassert is_valid_parenthesis_sequence('(()') == false\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: discrete master property implementation, mixer handle management, float value handling, property update\n\n### Task", "fingerprint": null, "seed": "void DiscreteMasterProperty__float__OnComplete(DiscreteMasterProperty__float* __this)\n{\n    float nv = __this->RestValue();\n    float str = 0.5f;\n\n    for (::app::Uno::Collections::List1_Enumerator__Fuse_Animations_MixerHandle_float_ enum_123 = ::uPtr< ::app::Uno::Collections::List__Fuse_Animations_MixerHandle_float_*>(__this->Handles)->GetEnumerator(); enum_123.MoveNext(); )\n    {\n        ::app::Fuse::Animations::MixerHandle__float* v = enum_123.Current();\n\n        if (::uPtr< ::app::Fuse::Animations::MixerHandle__float*>(v)->HasValue() && (::uPtr< ::app::Fuse::Animations::MixerHandle__float*>(v)->Strength > str))\n        {\n            nv = ::uPtr< ::app::Fuse::Animations::MixerHandle__float*>(v)->Value;\n            str = v->Strength;\n        }\n    }\n\n    ::uPtr< ::app::Uno::UX::Property__float*>(__this->Property)->Set(nv, (::uObject*)__this);\n}", "id": 54, "concepts": ["discrete master property implementation", "mixer handle management", "float value handling", "property update"], "instruction": "Implement a C++ function to modify the volume of a mixer handle. The handle has a `value` property that represents its volume level, ranging from 0.0 to 1.0. The function should take the handle and a target volume level as input, and update the `value` property accordingly.\n\nThe function should also consider the handle's `master` property, which represents the volume level of a mixer's master handle. If the target volume level is greater than the master's volume level, the function should update the `value` property to match the master's volume level.\n\nThe function should also account for the discrete master property, which indicates that the master handle only has a limited number of volume levels. In this case, the function should round the target volume level to the nearest discrete level."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: signal processing, square root approximation, array manipulation, RMS calculation\n\n### Task", "fingerprint": null, "seed": "float getFilteredSignal(int pin_x, int pin_y, int pin_z)\n{\n  float instant_value_x = analogRead(pin_x) - mean_x;\n  float instant_value_y = analogRead(pin_y) - mean_y;\n  float instant_value_z = analogRead(pin_z) - mean_z;\n\n  float instant_value = sqrt(pow(instant_value_x,2) + pow(instant_value_y,2) + pow(instant_value_z,2));\n  accel_values_put(instant_value);\n  float result = RMS(accel_values);\n\n  return result;\n}", "id": 55, "concepts": ["signal processing", "square root approximation", "array manipulation", "RMS calculation"], "instruction": "Implement a C++ function `rms_signal_processing(data, sample_rate)` to process a signal in the time domain by calculating the root mean square (RMS) of the data. The function should take two arguments: `data`, a 1D `numpy` array of floats representing the signal, and `sample_rate`, an integer representing the sampling frequency of the signal. The function should return a single float representing the RMS of the signal."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: hard\nconcepts: I/O control, relay activation, room occupancy state tracking\n\n### Task", "fingerprint": null, "seed": "void release_room() {\n    if (!NORELAY)  \n        digitalWrite(relay, LOW);  // active high  \n    occupied = false; \n    send_status(); \n}", "id": 56, "concepts": ["I/O control", "relay activation", "room occupancy state tracking"], "instruction": "Develop a C++ function `relay_control(rooms, room_occupancy, time_slots)` that controls the state of a relay based on room occupancy. The function takes the following arguments:\n\n- `rooms`: a list of room names (strings)\n- `room_occupancy`: a list of booleans representing the current occupancy state of each room\n- `time_slots`: a list of time slots (integers)\n\nThe function should return a list of booleans representing the state of the relay for each time slot. The relay should be activated when at least one room is occupied.\n\nImplement the function in a way that minimizes I/O operations and ensures that the relay state is updated only when necessary."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: game loop, game state management, game logic implementation\n\n### Task", "fingerprint": null, "seed": "int main()\n{    \n    Game game;\n    if(!game.init())\n        return EXIT_FAILURE;    \n\n    return game.run();\n}", "id": 57, "concepts": ["game loop", "game state management", "game logic implementation"], "instruction": "Implement a C++ class that models a game of life using a two-dimensional grid with each cell being either alive or dead. You should provide methods to initialize the grid, update the state of the game based on the rules of life, and render the grid as a string representation.\n\nLife is a cellular automaton, and its rules are as follows:\n1. Any live cell with fewer than two live neighbors dies, as if by underpopulation.\n2. Any live cell with two or three live neighbors lives on to the next generation.\n3. Any live cell with more than three live neighbors dies, as if by overpopulation.\n4. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n\nThe game should run in a loop, updating the state of the game based on the rules of life, and you can utilize the `time` module to add a delay between each iteration."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: USB receive callback function, character parsing, string manipulation, error handling with beeps\n\n### Task", "fingerprint": null, "seed": "static int8_t CDC_Receive_FS(uint8_t* Buf, uint32_t *Len)\r\n{\r\n    /* USER CODE BEGIN 6 */\r\n    uint8_t n = *Len;\r\n    uint8_t i;\r\n    for (i = 0; i < n; i++)\r\n    {\r\n        if (Buf[i] == '\\r')\r\n        {\r\n            //slcan_parse_str(slcan_str, slcan_str_index);\r\n            //slcan_str_index = 0;\r\n\r\n            auto result = slcan_parse_str(slcan_str, slcan_str_index);\r\n            slcan_str_index = 0;\r\n\r\n            if(result == -1)\r\n            {\r\n                CDC_Transmit_FS((uint8_t *)\"\\a\", 1);\r\n            }\r\n            else if(result == 0)\r\n            {\r\n                CDC_Transmit_FS((uint8_t *)\"\\r\", 1);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            slcan_str[slcan_str_index++] = Buf[i];\r\n        }\r\n    }\r\n\r\n\r\n    // prepare for next read\r\n    //USBD_CDC_SetRxBuffer(hUsbDevice_0, UserRxBufferFS);\r\n    //USBD_CDC_ReceivePacket(hUsbDevice_0);\r\n\r\n    USBD_CDC_SetRxBuffer(&hUsbDeviceFS, &Buf[0]);\r\n    USBD_CDC_ReceivePacket(&hUsbDeviceFS);\r\n    return (USBD_OK);\r\n    /* USER CODE END 6 */\r\n}", "id": 58, "concepts": ["USB receive callback function", "character parsing", "string manipulation", "error handling with beeps"], "instruction": "Implement a C++ function `usb_receive_callback` that handles incoming USB data. The function should parse each character from the data and perform the following actions:\n\n- If the character is an uppercase letter, append it to the result string.\n- If the character is a lowercase letter, append it to the result string and generate a beep sound.\n- If the character is a digit, append the digit to the result string and generate a beep sound.\n- If the character is a whitespace, append it to the result string and generate a beep sound.\n- If the character is a special character, append it to the result string and generate two beep sounds.\n- If the character is an unknown character, generate three beep sounds.\n\nThe function should return the resulting string."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: easy\nconcepts: memory management in linked lists, freeing memory to avoid memory leaks, error handling with exceptions\n\n### Task", "fingerprint": null, "seed": "void clean_List(Node *h){\n\tNode *p;\n\twhile(h){\n\t\tp = h->next;\n\t\tdelete h;\n\t\th = p;\n\t}\n}", "id": 60, "concepts": ["memory management in linked lists", "freeing memory to avoid memory leaks", "error handling with exceptions"], "instruction": "Implement a C++ class `LinkedList` with methods `push_back`, `push_front`, `pop_back`, and `pop_front` to add and remove nodes in a linked list. The class should use a private member variable `head` to store the head node of the linked list. The class should also handle memory management to avoid memory leaks. Ensure the class is exception-safe to handle errors gracefully."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: hard\nconcepts: pin mode configuration, signal inversion, device initialization, serial communication, random number generation, timer scheduling, state management\n\n### Task", "fingerprint": null, "seed": "void setup() {\n    pinMode(led, OUTPUT);   \n    pinMode(relay, OUTPUT); \n    pinMode(buzzer, OUTPUT); \n    if (!NORELAY)\n        digitalWrite(relay, HIGH);    // active high; start with relay operated   \n    digitalWrite(led, HIGH);      // active low       \n    digitalWrite(buzzer, HIGH);   // active low   \n    pinMode(dhtsensor, INPUT);     \n    pinMode(radar, INPUT);   \n    pinMode(pir1, INPUT);           \n    pinMode(pir2, INPUT);      \n    //beeper(0);  // TODO: disable this for production\n    blinker();      \n    \n    Serial.begin(9600);\n    Serial.println(F(\"Occupancy sensor starting...\"));\n    //EEPROM.get(0, mute_buzzer); // TODO: save tick interval also in EEPROM\n    // Set the nodeID manually\n    mesh.setNodeID(nodeID);  // increment this when burning every device\n    status_payload.node_id = nodeID;\n    Serial.print(F(\"Slave Node ID: \"));    \n    Serial.println(nodeID);    \n    Serial.print(F(\"Simulation = \"));Serial.println(SIMULATION);\n    Serial.print(F(\"NORELAY = \"));Serial.println(NORELAY);\n    Serial.println(F(\"Connecting to the mesh...\"));\n    unsigned long ms = millis();\n    bool result = mesh.begin(MESH_DEFAULT_CHANNEL,RF24_1MBPS,8000);    \n    Serial.println(F(\"Time taken: \"));\n    Serial.println(millis()-ms);\n    if (result)\n        Serial.println(F(\"Connected to mesh.\"));\n    else\n        Serial.println(F(\"Connection timed out.\"));    \n    /*\n    int palevel = radio.getPALevel();\n    Serial.print(F(\"Radio PA level: \"));\n    Serial.println(palevel);\n    radio.setPALevel (RF24_PA_LOW);\n    Serial.print(F(\"New PA level: \"));\n    palevel = radio.getPALevel();\n    Serial.println(palevel);     \n    Serial.println(F(\"Joined the meash.\"));\n    */\n    randomSeed(analogRead(FREE_PIN));  // noise from an unconnected pin\n    status_ticks = status_ticks + random(0, 10); // stagger the transmissions\n    Serial.print(F(\"Status tick interval: \"));\n    Serial.println(status_ticks*100U);  // convert to mSec\n    T.every(tick_interval, ticker);     \n    T.every(data_interval, read_temperature);  // just update readings; do not send it\n    T.every(network_check_interval, renew_network); // check connection and renew if necessary\n    occupy_room();    // start life in occupied state (this needs the mesh running)\n}", "id": 61, "concepts": ["pin mode configuration", "signal inversion", "device initialization", "serial communication", "random number generation", "timer scheduling", "state management"], "instruction": "Design a C++ function `initialize_device(device)` that configures a device for serial communication and initializes its internal state. The device should be represented as a dictionary with the following keys: `'pin_mode'`, `'invert_signal'`, `'device_id'`, `'serial_config'`, `'random_seed'`, `'device_state'`, and `'timer_scheduler'`. The function should perform the following steps:\n1. Set the pin mode for each pin in the device's configuration to the specified mode.\n2. Invert the signal for each pin in the device's configuration if specified.\n3. Initialize the device's internal state with the provided device ID, random seed, and serial configuration.\n4. Start the timer scheduler to manage the device's internal clock and schedule the next timer event.\n\nThe function should return the updated device dictionary."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: hard\nconcepts: custom function for reading a line from a stream, handling special cases for first character, inline function definition\n\n### Task", "fingerprint": null, "seed": "inline void getline(std::istream& cin, std::string& s) {\n    char c = cin.get();\n    std::getline(cin, s);\n    if (c != '\\n') s = c + s;\n}", "id": 62, "concepts": ["custom function for reading a line from a stream", "handling special cases for first character", "inline function definition"], "instruction": "Implement a C++ function `read_line_custom(stream)` that reads a line from a stream. The function should return the line as a string. Additionally, you should provide a custom function `read_char_custom(stream)` to read a character from a stream.\n\nThe `read_line_custom` function should handle special cases properly, such as when the first character is a newline or the stream is empty.\n\nThe `read_char_custom` function should be implemented as an inline function."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: easy\nconcepts: sensor data reading, measurement handling, time complexity analysis\n\n### Task", "fingerprint": null, "seed": "void read_temperature() { \n    // Reading the DHT11 takes about 250 milliseconds\n    D.read11(dhtsensor);\n    temperature = D.temperature;\n    humidity = D.humidity;  \n}", "id": 63, "concepts": ["sensor data reading", "measurement handling", "time complexity analysis"], "instruction": "Implement a C++ class that represents a temperature sensor and its data readings. The class should have a constructor that takes a sensor ID and an optional list of temperature readings. The class should have methods to add a new reading, get the latest reading, get the average of the last 10 readings, and get the median of the last 10 readings. Ensure the time complexity of these methods is O(1) or better."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: easy\nconcepts: random number generation, map generation algorithms, noise reduction techniques\n\n### Task", "fingerprint": null, "seed": "void generate()\r\n{\r\n\r\n\t//set crop height and width\r\n\tif (crop_height < 1)\r\n\t\tcrop_height = tmap_size;\r\n\tif (crop_width < 1)\r\n\t\tcrop_width = tmap_size;\r\n\r\n\t//if a crop value is set\r\n\t//set tmap_size to fit the cropped values\r\n\tint max_size = std::max(crop_height, crop_width);\r\n\tint max_size_tmp = max_size - 1;\r\n\r\n\tif ((max_size_tmp & (max_size_tmp - 1)) == 0)\r\n\t{\r\n\t\t//leave set size as highest crop value\r\n\t\ttmap_size = max_size;\r\n\t}\r\n\telse\r\n\t{\r\n\t\t//find smallest value such that (value is power of 2) + 1 and value > max_size\r\n\t\tint t = ceil(log2(max_size)) + 1;\r\n\t\ttmap_size = (1 << t) + 1;\r\n\t}\r\n\r\n\tdouble finish = 0;\r\n\t//display info\r\n\tif (verbose)\r\n\t{\r\n\t\tstd::cout << \"Using \" << config_file << std::endl;\r\n\t\tstd::cout << \"Staring square diamond\" << std::endl;\r\n\t\tstd::cout << \"Size: \" << crop_width << \" x \" << crop_height\r\n\t\t\t\t<< \" original size \" << tmap_size << std::endl;\r\n\t\tstd::cout << \"Starting seed value \" << seed << std::endl;\r\n\t\tstd::cout << \"Starting random offset \" << random_offset << std::endl;\r\n\t\tstd::cout << \"Random offset decrease ratio \" << offset_dr << std::endl;\r\n\r\n\t}\r\n\r\n\t//init map array\r\n\ttmap = new int*[tmap_size];\r\n\tfor (int i = 0; i < tmap_size; ++i)\r\n\t{\r\n\t\ttmap[i] = new int[tmap_size];\r\n\t\tfor (int j = 0; j < tmap_size; j++)\r\n\t\t\ttmap[i][j] = 0;\r\n\t}\r\n\r\n//\tinitialize random seed:\r\n//\tuse for generating a random map every time\r\n//  srand ( time(NULL) );\r\n\t//harcoded for now as produces a nice map for testing\r\n\tsrand(12);\r\n\r\n\t//fill the array with values\r\n\tsquare_diamond();\r\n\r\n\t//interpolate voronoi diagram\r\n\t//TODO: add noise to voronoi\r\n\tif (verbose)\r\n\t{\r\n\t\tstd::cout << \"Voronoi points \" << voronoi_size << std::endl;\r\n\t\t/*\r\n\t\t for (int i = 0; i < voronoi_size; ++i) {\r\n\t\t std::cout << \"\\t\" << voronoi_points[i][0] << \",\" << voronoi_points[i][1] << std::endl;\r\n\t\t }\r\n\t\t */\r\n\t}\r\n\tvoronoi();\r\n\r\n\terosion();\r\n\r\n\tif (!neg)\r\n\t\tclear_neg();\r\n\r\n//\t\tfinish = clock() - start;\r\n\tif (verbose)\r\n\t\tstd::cout << \"Finished square diamond \" << (finish / 1000000)\r\n\t\t\t\t<< std::endl;\r\n\tdouble sqadia = (finish / 1000000);\r\n\r\n\tif (normalise)\r\n\t{\r\n\t\tif (verbose)\r\n\t\t\tstd::cout << \"Normalising with value range \" << normalise_min << \"-\"\r\n\t\t\t\t\t<< normalise_max << std::endl;\r\n\t\tnormalise_map();\r\n\t}\r\n\r\n\tif (output_format == STANDRARD_HEIGHTS)\r\n\t{\r\n\t\tprint_map(fopen(output_file.c_str(), \"w\"));\r\n\t}\r\n\telse if (output_format == STANDARD_XML)\r\n\t{\r\n\t\tprint_map_xml(fopen(output_file.c_str(), \"w\"));\r\n\t}\r\n\r\n\tif (scale > 0 && crop_height > 256 && crop_width > 256)\r\n\t{\r\n\r\n//\t\t\tstart = clock();\r\n\t\tif (verbose)\r\n\t\t\tstd::cout << \"Generating rivers\" << std::endl;\r\n\t\trivers();\r\n//\t\t\tfinish = clock() - start;\r\n\t\tif (verbose)\r\n\t\t\tstd::cout << \"Done \" << (finish / 1000000) << std::endl;\r\n\t\tdouble rivers_time = (finish / 1000000);\r\n\t\tprint_rivers(0);\r\n\r\n//\t\t\tstart = clock();\r\n\t\tif (verbose)\r\n\t\t\tstd::cout << \"Generating vegetation\" << std::endl;\r\n\t\tvegetation(verbose);\r\n//\t\t\tfinish = clock() - start;\r\n\t\tif (verbose)\r\n\t\t\tstd::cout << \"Done \" << (finish / 1000000) << std::endl;\r\n\t\tdouble veg_time = (finish / 1000000);\r\n\t\tprint_vegetation(0);\r\n\r\n\t\tif (verbose)\r\n\t\t\tstd::cout << \"Generating settlements\" << std::endl;\r\n\t\tsettlements();\r\n//\t\t\tfinish = clock() - start;\r\n\t\tif (verbose)\r\n\t\t\tstd::cout << \"Done \" << (finish / 1000000) << std::endl;\r\n\t\tdouble settlement_time = (finish / 1000000);\r\n\t\tprint_settlements(0);\r\n\r\n\t\tstd::cout << crop_height << \"\\t\"\r\n\t\t\t\t<< (sqadia + rivers_time + veg_time + settlement_time) << \"\\t\"\r\n\t\t\t\t<< sqadia << \"\\t \" << rivers_time << \"\\t\" << veg_time << \"\\t\"\r\n\t\t\t\t<< settlement_time << std::endl;\r\n\t}\r\n\r\n\tstd::cout << \"Drawing contours\" << std::endl;\r\n\tcontour_map(32, 32, verbose);\r\n\tprint_contour(0);\r\n\tprint_kf(0);\r\n\r\n}", "id": 64, "concepts": ["random number generation", "map generation algorithms", "noise reduction techniques"], "instruction": "Develop a C++ class that generates a two-dimensional array representing a terrain map. The class should have a method `generate_map(width, height, seed)`, where `width` and `height` are the dimensions of the map, and `seed` is a positive integer used to seed the random number generator. The generated map should be a 2D array with `height` rows and `width` columns, where each element represents the height of the terrain at that position.\n\nThe map generation algorithm should follow the following steps:\n\n1. Initialize the map with all elements set to zero.\n2. Generate a random number between 0 and 1 for each element in the map.\n3. Iterate through the map and add the random number to the element at the current position.\n4. Repeat steps 2 and 3 for a given number of iterations (e.g., 4).\n5. Apply noise reduction techniques to smooth out the map. One technique is to replace each element with the average of its neighbors, excluding elements outside the map.\n\nHere's an example implementation of the map generation algorithm in Python:\n\n```python\nimport random\n\nclass TerrainGenerator:\n    def __init__(self, seed):\n        self.rng = random.Random(seed)\n\n    def generate_map(self, width, height, iterations=4):\n        map = [[0 for _ in range(width)] for _ in range(height)]\n        for _ in range(iterations):\n            for i in range(height):\n                for j in range(width):\n                    map[i][j] += self.rng.random()\n        for _ in range(iterations):\n            for i in range(height):\n                for j in range(width):\n                    neighbors = [map[i][j]]\n                    if i > 0:\n                        neighbors.append(map[i - 1][j])\n                    if i < height - 1:\n                        neighbors.append(map[i + 1][j])\n                    if j > 0:\n                        neighbors.append(map[i][j - 1])\n                    if j < width - 1:\n                        neighbors.append(map[i][j + 1])\n                    map[i][j] = sum(neighbors) / len(neighbors)\n\n        return map\n```\n\nThe map generation algorithm starts with a basic random noise, and then applies a number of iterations to smooth out the noise and produce a more natural-looking map. The noise reduction technique used here is to replace each element with the average of its neighbors, excluding elements outside the map. This technique helps reduce the amount of noise and produces a more realistic-looking map.\n\nNote that the map generation algorithm can be further improved by using more sophisticated techniques, such as Perlin noise or diamond-square algorithm, to produce more realistic-looking maps."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: hard\nconcepts: formula calculation, round function, ternary operator for short-circuiting\n\n### Task", "fingerprint": null, "seed": "void solve()\r\n{\r\n    double k1, k2, k3, v;\r\n    cin >> k1 >> k2 >> k3 >> v;\r\n\r\n    const int DISTANCE = 100,RECORD = 958;\r\n\r\n    double speed = k1*k2*k3*v;\r\n    int time = round(100*DISTANCE/speed);\r\n\r\n    cout << (time < RECORD ? \"Yes\" : \"No\") << \"\\n\";\r\n}", "id": 65, "concepts": ["formula calculation", "round function", "ternary operator for short-circuiting"], "instruction": "Implement a C++ function `evaluate_formula` that evaluates the following formula:\n\n$$\nf(x, y) = \\begin{cases}\n    \\frac{x}{2} - \\frac{y}{2} & \\text{if } x \\geq y \\\\\n    \\frac{x}{2} + \\frac{y}{2} & \\text{if } x < y\n\\end{cases}\n$$\n\nThe function should take two arguments, `x` and `y`, represent the values of $x$ and $y$, respectively.\nIt should use the `round` function to round the result to the nearest integer. If `x` and `y` are equal, the function should return 0."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: easy\nconcepts: command parsing, lookup table usage, conditional branching, error handling\n\n### Task", "fingerprint": null, "seed": "int setColor(String command)    {\n    // Look through the list of colors to find the one that was requested\n    for(int iColor = 0; iColor < NUM_COLORS; iColor++)\n    {\n        if(command == colorName[iColor]) {\n            // When it matches, look up the RGB values for that color in the table,\n            // and write the red, green, and blue values.\n            RGB.control(true);\n            RGB.color(colorRGB[iColor][0], colorRGB[iColor][1], colorRGB[iColor][2]);\n\n            analogWrite(pinRed,colorRGB[iColor][0]);\n            analogWrite(pinGreen,colorRGB[iColor][1]);\n            analogWrite(pinBlue,colorRGB[iColor][2]);\n            return 0;\n        }\n    }\n\n    return -1;\n}", "id": 66, "concepts": ["command parsing", "lookup table usage", "conditional branching", "error handling"], "instruction": "Implement a C++ class `CommandParser` to parse and execute a given command in the format \"action:param1,param2,param3\", where \"action\" can be \"add\" or \"remove\" and \"param1\", \"param2\", and \"param3\" are integers. The class should have two methods: `parse(command)` and `execute()`. The `parse` method should parse the given command into an action and parameters, and store the parsed values in the class. The `execute` method should execute the parsed action, calling the appropriate method based on the action (\"add\" or \"remove\"). If the action is invalid or the parameters are invalid, `execute` should raise an exception. Ensure the class can handle multiple commands in sequence.\n\n```cpp\ncommand_parser = CommandParser()\ncommand_parser.parse(\"add:1,2,3\")\ncommand_parser.execute()\ncommand_parser.parse(\"remove:1,2,3\")\ncommand_parser.execute()\ncommand_parser.parse(\"invalid:1,2,3\")\ntry:\n    command_parser.execute()\nexcept Exception as e:\n    print(e)\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: hard\nconcepts: array implementation, data structure design, error handling\n\n### Task", "fingerprint": null, "seed": "int main(int argc, char const *argv[])\n{\n\tgoodGrowArray<double> a(4);\n\t\n\ta.insertStart(10.1);\n\ta.insertStart(20.1);\n\ta.insertStart(30.1);\n\ta.insertStart(40.1);\n\ta.insert(2, 1111);\n\ta.remove(3);\n\tint len = a.getlen();\n\tint capacity = a.getCapacity();\n\tdouble* data = a.getData();\n\tcout << len << \" \" << capacity << endl;\n\tfor(int i=0; i<len; i++){\n\t\tcout << data[i] <<\" \";\n\t}\n\tcout << endl;\n\treturn 0;\n}", "id": 67, "concepts": ["array implementation", "data structure design", "error handling"], "instruction": "Implement a C++ class `Array` that stores a fixed-size array of integers. The class should have the following methods:\n\n- `Array(size)`: Initializes the array with the specified size.\n- `get(index)`: Returns the value at the specified index.\n- `set(index, value)`: Sets the value at the specified index.\n- `insert(index, value)`: Inserts a value at the specified index, shifting the subsequent values to the right.\n- `remove(index)`: Removes the value at the specified index, shifting the subsequent values to the left.\n\nAdditionally, the class should handle the following exceptions:\n\n- `IndexError`: Raised when an invalid index is provided.\n- `ValueError`: Raised when the value is not an integer.\n\nHere's an example of how to use the `Array` class:\n\n```cpp\narray = Array(5)  # Create an array with size 5\narray.set(0, 10)  # Set the value at index 0 to 10\narray.set(1, 20)  # Set the value at index 1 to 20\narray.insert(1, 15)  # Insert 15 at index 1, shifting the other values to the right\narray.remove(2)  # Remove the value at index 2, shifting the other values to the left\nprint(array.get(0))  # Print the value at index 0\nprint(array.get(1))  # Print the value at index 1\n```\n\nThe expected output is:\n\n```\n10\n15\n```\n\nNote that the value at index 2 is removed, so the value at index 1 is now at index 2."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: string parsing, float representation, decimal point handling\n\n### Task", "fingerprint": null, "seed": "char checkForFloat(char *s) {\n    char decimalPoint = false;\n    int i;\n    for(i=0; s[i] != '\\0'; i++) {\n        switch(s[i]) {\n            case '.':\n                if(decimalPoint) return false;\n                decimalPoint = true;\n                break;\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n                break;\n            default:\n                return false;\n        }\n    }\n    return true;\n}", "id": 68, "concepts": ["string parsing", "float representation", "decimal point handling"], "instruction": "Implement a C++ function `parse_float_str` that parses a string representation of a floating-point number to its actual value. The function should handle the following cases:\n\n- The string may or may not contain a decimal point.\n- The string may or may not contain a sign (+ or -).\n- The string may or may not contain leading or trailing spaces.\n- The string may or may not contain leading or trailing zeros.\n- The string may or may not contain an exponent (e.g., 1e-3).\n\nYour function should handle all valid floating-point numbers and raise an exception for invalid inputs."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitmasking, function pointer casting, bit flag manipulation\n\n### Task", "fingerprint": null, "seed": "void fpcM_PauseEnable(void* pProc, u8 param_2) {\n    fpcPause_Enable((process_node_class*)pProc, param_2 & 0xFF);\n}", "id": 69, "concepts": ["bitmasking", "function pointer casting", "bit flag manipulation"], "instruction": "Implement a C++ program that performs bit-level operations on integers. The program consists of two functions: `bitmask` and `bitflag`. The `bitmask` function takes three arguments: an integer `value`, a mask `mask`, and an operation `op` (which can be either 'and', 'or', or 'xor'). The function applies the specified operation on `value` and `mask` and returns the result. The `bitflag` function takes two arguments: an integer `value` and a flag `flag` (which can be either 'set' or 'clear'). The function sets or clears the flag bit in `value` and returns the updated integer.\n\nFor example, given `value = 0b1010`, `mask = 0b1100`, and `op = 'and'`, the `bitmask` function should return `0b1000`. Similarly, given `value = 0b1010` and `flag = 'set'`, the `bitflag` function should return `0b1011`.\n\nThis task requires understanding of bitmasking and function pointer casting, as well as bit flag manipulation."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: hard\nconcepts: linked list creation, pointer manipulation, string processing\n\n### Task", "fingerprint": null, "seed": "void init_List(Node *h, const string &a){\n\tNode *p = h;\n\tfor(int i = 0; i < a.size(); i ++){\n\t\tNode *current = new Node(a[i]);\n\t\tp->next = current;\n\t\tp = current;\n\t}\n}", "id": 70, "concepts": ["linked list creation", "pointer manipulation", "string processing"], "instruction": "Implement a C++ class `LinkedList` to create a linked list with the following methods:\n\n- `add(data)`: Add a new node to the end of the linked list with the given data.\n- `remove(index)`: Remove the node at the given index from the linked list.\n- `get(index)`: Return the data of the node at the given index from the linked list.\n- `reverse()`: Reverse the linked list in-place.\n- `to_string()`: Return a string representation of the linked list, formatted as `[data1, data2, data3]`.\n\nThe class should store the head and tail pointers of the linked list, and the linked list nodes should contain data and pointers to the next and previous nodes."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: function definition, comparison function for sorting\n\n### Task", "fingerprint": null, "seed": "bool comp(ll i,ll j)\n{\n    return i>j;\n}", "id": 71, "concepts": ["function definition", "comparison function for sorting"], "instruction": "Implement a C++ class that represents a binary search tree (BST). The class should have the following methods:\n\n- `insert(value)`: inserts a new node with the given value into the BST.\n- `find(value)`: searches for a node with the given value in the BST and returns it.\n- `delete(value)`: removes a node with the given value from the BST.\n\nFor `insert` and `delete` methods, you can use the standard BST insertion and deletion algorithms. For `find`, you can implement a recursive function that searches for a node with the given value in the BST.\n\n```cpp\nclass BSTNode {\n  public:\n    BSTNode(int val) : value(val), left(nullptr), right(nullptr) {}\n    int value;\n    BSTNode *left;\n    BSTNode *right;\n};\n\nclass BST {\n  public:\n    BST() : root(nullptr) {}\n    void insert(int value);\n    BSTNode *find(int value);\n    void remove(int value);\n  private:\n    BSTNode *root;\n};\n\nvoid BST::insert(int value) {\n  if (root == nullptr) {\n    root = new BSTNode(value);\n  } else {\n    BSTNode *current = root;\n    while (true) {\n      if (value < current->value) {\n        if (current->left == nullptr) {\n          current->left = new BSTNode(value);\n          break;\n        } else {\n          current = current->left;\n        }\n      } else {\n        if (current->right == nullptr) {\n          current->right = new BSTNode(value);\n          break;\n        } else {\n          current = current->right;\n        }\n      }\n    }\n  }\n}\n\nBSTNode *BST::find(int value) {\n  BSTNode *current = root;\n  while (current != nullptr) {\n    if (current->value == value) {\n      return current;\n    } else if (value < current->value) {\n      current = current->left;\n    } else {\n      current = current->right;\n    }\n  }\n  return nullptr;\n}\n\nvoid BST::remove(int value) {\n  BSTNode *current = root;\n  BSTNode *parent = nullptr;\n  while (current != nullptr) {\n    if (current->value == value) {\n      break;\n    }\n    parent = current;\n    if (value < current->value) {\n      current = current->left;\n    } else {\n      current = current->right;\n    }\n  }\n  if (current == nullptr) {\n    return;\n  }\n  if (current->left == nullptr) {\n    if (parent == nullptr) {\n      root = current->right;\n    } else if (current->value < parent->value) {\n      parent->left = current->right;\n    } else {\n      parent->right = current->right;\n    }\n  } else {\n    BSTNode *successor = current->left;\n    BSTNode *successorParent = current;\n    while (successor->right != nullptr) {\n      successorParent = successor;\n      successor = successor->right;\n    }\n    if (successorParent != current) {\n      successorParent->right = successor->left;\n      successor->left = current->left;\n    }\n    if (parent == nullptr) {\n      root = successor;\n    } else if (current->value < parent->value) {\n      parent->left = successor;\n    } else {\n      parent->right = successor;\n    }\n    successor->right = current->right;\n  }\n  delete current;\n}\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: hard\nconcepts: root mean square calculation, power calculation, array processing\n\n### Task", "fingerprint": null, "seed": "float RMS(float values[])\n{\n  float result;\n  result = 0;\n  \n  for(int i = 0; i < RMS_window; i++)\n  {\n    result += pow(values[i], 2);\n  }\n\n  result = sqrt(result/10);\n\n  return result;\n}", "id": 72, "concepts": ["root mean square calculation", "power calculation", "array processing"], "instruction": "Develop a C++ function `calculate_rms` that calculates the RMS value of a given array of numbers. The RMS value is defined as the square root of the arithmetic mean of the squares of the numbers in the array. The function should handle both positive and negative numbers, and handle the case when the array is empty. The function should use the `sqrt` function from the standard library to calculate the square root. Write assertions to ensure the function works correctly.\n\nFor example, given `array = [1, -2, 3, -4]`, the function should return `sqrt((1**2 + (-2)**2 + 3**2 + (-4)**2) / 4)`, which is approximately `2.291`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: easy\nconcepts: voltage monitoring, high-voltage detection, flag setting, serial output\n\n### Task", "fingerprint": null, "seed": "void high_voltage_check()\n{\n  if(voltage_usage_1 > HIGH_VOLTAGE_1_CUTOFF || voltage_usage_2 > HIGH_VOLTAGE_2_CUTOFF || voltage_usage_3 > HIGH_VOLTAGE_3_CUTOFF){\n    Serial.println(\"High voltage detected...\");\n    highvoltageflag = true;\n    swith_off();\n  } else {\n     highvoltageflag = false;\n  }\n}", "id": 73, "concepts": ["voltage monitoring", "high-voltage detection", "flag setting", "serial output"], "instruction": "Develop a C++ program to monitor the voltage of a system and detect high-voltage anomalies. The program should continuously read the voltage values from a sensor and compare them with a predefined threshold. If the voltage exceeds the threshold, a flag should be set to indicate a high-voltage anomaly. The program should also output the measured voltage values and the corresponding anomaly status over a serial connection."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: network management, address renewal, connection check\n\n### Task", "fingerprint": null, "seed": "bool renew_network() {\n    if (mesh.checkConnection()) {\n        return (true);\n    }\n    else {\n        Serial.println(F(\"Renewing network address...\"));\n        unsigned int addr = mesh.renewAddress(3000UL);  \n        if (addr != 0) {        \n            Serial.print(F(\"New address: \"));\n            Serial.println(addr);\n            return (true);\n        }\n    }   \n    return (false);\n}", "id": 74, "concepts": ["network management", "address renewal", "connection check"], "instruction": "Implement a C++ class `NetworkManager` that manages network connections. The class should have two main methods: `connect()` and `renew_address()`. `connect()` establishes a connection with a remote server and returns a unique connection ID. `renew_address()` renews the IP address of an existing connection. Both methods should support concurrent access from multiple threads.\n\nAdditionally, define a method `check_connection(connection_id)` to check the status of a connection. The function should return `True` if the connection is still active, and `False` otherwise.\n\nHere's an example of how you can implement the `NetworkManager` class in C++:\n\n```cpp\nclass NetworkManager {\nprivate:\n    mutex connection_mutex;\n    map<int, string> connections;\n\npublic:\n    int connect() {\n        unique_lock<mutex> lock(connection_mutex);\n\n        static int connection_id = 0;\n        string ip_address = \"192.168.0.\" + to_string(connection_id);\n\n        connections[connection_id] = ip_address;\n        connection_id++;\n\n        return connection_id - 1;\n    }\n\n    void renew_address(int connection_id) {\n        unique_lock<mutex> lock(connection_mutex);\n\n        if (connections.find(connection_id) != connections.end()) {\n            string ip_address = \"192.168.0.\" + to_string(connection_id);\n            connections[connection_id] = ip_address;\n        }\n    }\n\n    bool check_connection(int connection_id) {\n        unique_lock<mutex> lock(connection_mutex);\n\n        return connections.find(connection_id) != connections.end();\n    }\n};\n```\n\nThis code snippet demonstrates how you can implement the `NetworkManager` class in C++ to manage network connections. The `connect()` method establishes a connection with a remote server and returns a unique connection ID. The `renew_address()` method renews the IP address of an existing connection. The `check_connection()` method checks the status of a connection and returns `true` if the connection is still active, and `false` otherwise. Both `connect()` and `renew_address()` methods support concurrent access from multiple threads by using a `mutex` object.\n\nNote that this implementation is simplified for illustration purposes and does not handle all possible edge cases. In a real-world scenario, you would need to consider additional considerations such as handling connection timeouts, handling multiple remote servers, and handling network errors."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: hard\nconcepts: modbus communication with a PZEM device, error handling for failed modbus read, 8-bit integer arithmetic for voltage and current calculations, power factor calculation, serial output formatting\n\n### Task", "fingerprint": null, "seed": "void pzemdevice3()                                                            // Function to get PZEM device 1 data\n{\n  Serial.println(\"====================================================\");     // PZEM Device 1 data fetching code starts here\n  Serial.println(\"Now checking PZEM Device 3\");\n  uint8_t result3;\n\n  ESP.wdtDisable();                                                           // Disable watchdog during modbus read or else ESP crashes when no slave connected\n  result3 = node3.readInputRegisters(0x0000, 10);\n  ESP.wdtEnable(1);                                                           // Enable watchdog during modbus read\n\n  if (result3 == node3.ku8MBSuccess)\n  {\n    voltage_usage_3      = (node3.getResponseBuffer(0x00) / 10.0f);\n    current_usage_3      = (node3.getResponseBuffer(0x01) / 1000.000f);\n    active_power_3       = (node3.getResponseBuffer(0x03) / 10.0f);\n    active_energy_3      = (node3.getResponseBuffer(0x05) / 1000.0f);\n    frequency_3          = (node3.getResponseBuffer(0x07) / 10.0f);\n    power_factor_3       = (node3.getResponseBuffer(0x08) / 100.0f);\n\n    Serial.print(\"VOLTAGE:           \");   Serial.println(voltage_usage_3);       // V\n    Serial.print(\"CURRENT_USAGE:     \");   Serial.println(current_usage_3, 3);    // A\n    Serial.print(\"ACTIVE_POWER:      \");   Serial.println(active_power_3);        // W\n    Serial.print(\"ACTIVE_ENERGY:     \");   Serial.println(active_energy_3, 3);    // kWh\n    Serial.print(\"FREQUENCY:         \");   Serial.println(frequency_3);           // Hz\n    Serial.print(\"POWER_FACTOR:      \");   Serial.println(power_factor_3);\n    Serial.println(\"====================================================\");\n  }\n  else {\n    Serial.println(\"Failed to read PZEM Device 3\");\n    Serial.println(\"PZEM Device 3 Data\");\n    voltage_usage_3      = 0;                                                     // Assigning 0 if it fails to read PZEM device\n    current_usage_3      = 0;\n    active_power_3       = 0;\n    active_energy_3      = 0;\n    frequency_3          = 0;\n    power_factor_3       = 0;\n    Serial.print(\"VOLTAGE:           \");   Serial.println(voltage_usage_3);       // V\n    Serial.print(\"CURRENT_USAGE:     \");   Serial.println(current_usage_3, 3);    // A\n    Serial.print(\"ACTIVE_POWER:      \");   Serial.println(active_power_3);        // W\n    Serial.print(\"ACTIVE_ENERGY:     \");   Serial.println(active_energy_3, 3);    // kWh\n    Serial.print(\"FREQUENCY:         \");   Serial.println(frequency_3);           // Hz\n    Serial.print(\"POWER_FACTOR:      \");   Serial.println(power_factor_3);\n    Serial.println(\"====================================================\");\n    swith_off();\n  }\n}", "id": 75, "concepts": ["modbus communication with a PZEM device", "error handling for failed modbus read", "8-bit integer arithmetic for voltage and current calculations", "power factor calculation", "serial output formatting"], "instruction": "Implement a C++ class `PZEM` that can communicate with a PZEM 004T electricity meter using the Modbus protocol. The class should have methods to read the device's voltage, current, active power, and power factor. It should also handle the case where a Modbus read fails by returning -1. Additionally, perform 8-bit integer arithmetic to calculate the voltage and current values. Finally, format the output of the class's methods to display 2 decimal places."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: medium\nconcepts: node insertion, pattern matching, text processing\n\n### Task", "fingerprint": null, "seed": "void p6(Node *h){\n\tNode *p = h;\n\twhile(p){\n\t\tNode *pn = p->next;\n\t\tif(pn == NULL || (pn->c != '?' && pn->c != '!')){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n//\t\tcout<<\"p6\"<<endl;\n\t\tNode *node = new Node(' ');\n\t\tp = insert(p,node);\n\t\tnode = new Node(' ');\n\t\tpn = insert(pn,node);\n\t\tp = pn;\n\t}\n}", "id": 76, "concepts": ["node insertion", "pattern matching", "text processing"], "instruction": "Implement a C++ program to process a text file line by line, searching for patterns that match a particular regular expression. For each match, insert a new line before the matched line with the following format: \"{match_index}: {match_text}\". The match_index should start at 1 and increase by 1 for each match. The match_text should be the original matched text.\n\nThe program should take two arguments: the input file path and the regular expression to match. The program should read the input file line by line and search for matches using the provided regular expression. For each match, it should insert a new line before the matched line with the format \"{match_index}: {match_text}\". The match_index should start at 1 and increase by 1 for each match. The match_text should be the original matched text.\n\nThe program should write the updated content back to the input file, overwriting the original content."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: hard\nconcepts: sparse table, lca, binary lifting, fast query\n\n### Task", "fingerprint": null, "seed": "int askdist(int u,int v)\n{\n\tint res=0;\n\tif(deep[u]<deep[v]) std::swap(u,v);\n\tfor(int i=19;~i;i--) if(deep[fa[u][i]]>=deep[v]) res=mul(res+val[u][i]),u=fa[u][i];\n\tif(u==v) return res;\n\tfor(int i=19;~i;i--)\n\t\tif(fa[u][i]!=fa[v][i]) res=(res+val[u][i]+val[v][i])%mod,u=fa[u][i],v=fa[v][i];\n\tres=mul(res+val[u][0]+val[v][0]);\n\treturn res;\n}", "id": 77, "concepts": ["sparse table", "lca", "binary lifting", "fast query"], "instruction": "Implement a C++ program that performs the following operations, each in $O(\\log n)$ time:\n\n- Build a data structure that supports the following operations:\n  - Given a weighted tree $T$, preprocess it to support subsequent queries.\n  - Given a node $u$ and an integer $k$, return the $k$-th ancestor of $u$ in the tree.\n- Given a sparse table that supports the following operations:\n  - Given an array $A$, preprocess it to support subsequent queries.\n  - Given a range $[l, r]$, return the minimum value in $A[l \\ldots r]$.\n- Given a tree $T$ with $n$ nodes, preprocess it to support subsequent queries.\n  - Given a node $u$, return its lowest common ancestor (LCA) with any other node $v$.\n  - Given a node $u$ and an integer $k$, return the $k$-th ancestor of $u$ in the tree."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: sparse matrix storage conversion, memory management, pointer arithmetic, row-major matrix traversal\n\n### Task", "fingerprint": null, "seed": "void full_to_csr_ref(\n    int m, int n,\n    double *A, int lda,\n    int **rowptr, int **colidx, double **values) {\n    *rowptr = new int[m + 1];\n\n    int zero = 0;\n    std::fill(*rowptr, *rowptr + m + 1, zero);\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            rowptr[0][j + 1] += (A[i * lda + j]) ?1 :0;\n        }\n    }\n\n    for (int i = 0; i < m; ++i) {\n        rowptr[0][i + 1] += rowptr[0][i];\n    }\n\n    *colidx = new int[rowptr[0][m]];\n    *values = new double[rowptr[0][m]];\n\n    int pos = 0;\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (A[i * lda + j]) {\n                colidx[0][pos] = j;\n                values[0][pos] = A[i * lda + j];\n                ++pos;\n            }\n        }\n    }\n}", "id": 78, "concepts": ["sparse matrix storage conversion", "memory management", "pointer arithmetic", "row-major matrix traversal"], "instruction": "Implement a C++ function `convert_to_sparse_matrix(matrix)` to convert a 2D matrix into a compressed sparse row (CSR) format. The function should take a 2D matrix as input and return a tuple containing three 1D arrays: `data`, `indices`, and `indptr`. The `data` array stores the non-zero values of the matrix in row-major order, while `indices` stores the corresponding column indices. The `indptr` array indicates the start and end of each row in the `data` and `indices` arrays. Ensure the function correctly handles matrices with different dimensions and memory management."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: hard\nconcepts: timing code execution, benchmarking, measuring performance, printing to the console\n\n### Task", "fingerprint": null, "seed": "void PrintMs(const char* text = \"\") {\n\tstatic long long last = 0;\n\tlong long cur = getTickCount();\n\tif (last == 0) {\n\t\tlast = cur;\n\t\treturn;\n\t}\n\tlong long ms = 0;\n\tms = ((double)(cur - last) / getTickFrequency()) * 1000;\n\tif (*text != 0) {\n\t\tprintf(\"%s = %dms\\n\", text, ms);\n\t}\n\tlast = getTickCount();\n}", "id": 79, "concepts": ["timing code execution", "benchmarking", "measuring performance", "printing to the console"], "instruction": "Implement a C++ function `benchmark` that accepts a callable and a number of repetitions, and returns the average time taken to execute the callable. The function should print the benchmark results to the console.\n\nThe function should employ the `time_this` function to measure the time taken to execute the callable and then calculate the average time by dividing the total time by the number of repetitions. The benchmark results should be printed in the following format:\n\n```\nBenchmark results:\nAverage time taken: {average_time}s\n```\n\nThe `time_this` function should be defined as a nested function inside `benchmark` to ensure it has access to the `time` module.\n\n```cpp\ndef benchmark(func, repetitions):\n    def time_this():\n        start = time.time()\n        func()\n        end = time.time()\n        return end - start\n\n    total_time = 0\n    for _ in range(repetitions):\n        total_time += time_this()\n\n    average_time = total_time / repetitions\n    print(f\"Benchmark results:\\nAverage time taken: {average_time}s\")\n    return average_time\n```\n\n```cpp\ndef benchmark(func, repetitions):\n    def time_this():\n        start = time.time()\n        func()\n        end = time.time()\n        return end - start\n\n    total_time = 0\n    for _ in range(repetitions):\n        total_time += time_this()\n\n    average_time = total_time / repetitions\n    print(f\"Benchmark results:\\nAverage time taken: {average_time}s\")\n    return average_time\n```\n\nThe `benchmark` function accepts a callable and a number of repetitions as inputs, and returns the average time taken to execute the callable. It employs the `time_this` function to measure the time taken to execute the callable and then calculates the average time by dividing the total time by the number of repetitions. The benchmark results are printed in the specified format using string interpolation.\n\nThe `time_this` function is defined as a nested function inside `benchmark` to ensure it has access to the `time` module. It measures the time taken to execute the callable by recording the start time, calling the callable, and calculating the difference between the start time and the current time. This approach ensures accurate measurements of the time taken to execute the callable.\n\nThe `benchmark` function can be used to evaluate the performance of different functions or code snippets by comparing their average time taken to execute. It can help identify the most efficient solution or identify any potential bottlenecks in the code.\n\n```cpp\ndef my_function():\n    pass\n\nbenchmark(my_function, 10)\n```\n\n```cpp\ndef my_function():\n    pass\n\nbenchmark(my_function, 10)\n```\n\nThis code snippet demonstrates how to use the `benchmark` function to evaluate the performance of the `my_function` function. It calls `benchmark` with the function and the number of repetitions as arguments. The `benchmark` function will execute the function multiple times and calculate the average time taken to execute it. The results will be printed to the console in the specified format.\n\nThe `benchmark` function can be modified to accept more arguments and return more information about the benchmark results, such as the standard deviation of the time taken or the minimum and maximum time taken. It can also be extended to support additional benchmarking features, such as comparing different implementations of the same function or analyzing the memory usage of the callable."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: matrix printing with row-major layout, nested loops for row and column traversal\n\n### Task", "fingerprint": null, "seed": "void print_matrix(float *x, int N)\n{\n\tint i, j;\n   \tfor(i=0;i<N;i++)\n   \t{\n      \t\tfor (j=0;j<N;j++) printf(\" %f \", x[N*i+j]); \n      \t\tprintf(\"\\n\"); \n   \t}\n}", "id": 80, "concepts": ["matrix printing with row-major layout", "nested loops for row and column traversal"], "instruction": "Implement a C++ class `MatrixPrinter` that initializes with a 2D array `matrix` and provides a method `print_row_major` to print the matrix in row-major layout. The method should return a string containing the matrix elements printed in row-major order, separated by spaces.\n\nHere is the class definition:\n\n```cpp\nclass MatrixPrinter {\npublic:\n    MatrixPrinter(vector<vector<int>> matrix);\n    string print_row_major();\n\nprivate:\n    vector<vector<int>> matrix;\n};\n```\n\nThe `MatrixPrinter` class initializes with a 2D array `matrix`. The `print_row_major` method should traverse the `matrix` in row-major order and return a string containing the matrix elements printed in row-major order, separated by spaces."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: hard\nconcepts: greedy algorithm, set data structure, tracking of indices\n\n### Task", "fingerprint": null, "seed": "int main()\n{\n#ifndef ONLINE_JUDGE\n    freopen(\"input.txt\", \"rt\", stdin);\n    freopen(\"output.txt\", \"wt\", stdout);\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    ll n;\n    cin >> n;\n    string s, t;\n    cin >> s >> t;\n    set<ll> s0, s1;\n    f(0, n)\n    {\n        if (s[i] != t[i])\n        {\n            if (s[i] == '1')\n                s1.insert(i);\n            else\n                s0.insert(i);\n        }\n    }\n    if (s0.size() == 0 && s1.size() == 0)\n    {\n        cout << \"0\\n\";\n        return 0;\n    }\n    if (s0.size() != s1.size())\n    {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    ll i0 = *s0.begin();\n    ll i1 = *s1.begin();\n    ll f = 2;\n    int ans=0;\n    while (!(s0.empty() && s1.empty()))\n    {\n        if (f == 2)\n        {\n            ans++;\n            i0 = *s0.begin();\n            i1 = *s1.begin();\n            f=0;\n        }\n        if(i0<i1)\n        {\n            s0.erase(i0);\n            s1.erase(i1);\n            auto p =s0.upper_bound(i1); \n            if(p==s0.end()){\n                f=2;\n                continue;\n            }\n            i0 = *p;\n        }\n        else\n        {\n            s0.erase(i0);\n            s1.erase(i1);\n            auto p =s1.upper_bound(i0); \n            if(p==s1.end()){\n                f=2;\n                continue;\n            }\n            i1 = *p;\n        }\n    }\n    cout<<ans<<\"\\n\";\n}", "id": 81, "concepts": ["greedy algorithm", "set data structure", "tracking of indices"], "instruction": "Implement a C++ function `max_non_overlapping_intervals(intervals)` that takes a list of intervals represented as pairs of integers `[start, end]` and returns the maximum number of non-overlapping intervals that can be chosen.\n\nFor example, given `intervals = [[1, 2], [2, 3], [3, 4], [1, 3]]`, the function should return 2 because the maximum number of non-overlapping intervals is 2, chosen from `[[1, 2], [3, 4]]`.\n\nThe function should satisfy the following assertions:\n\n```cpp\nassert max_non_overlapping_intervals([[1, 2], [2, 3], [3, 4], [1, 3]]) == 2\nassert max_non_overlapping_intervals([[1, 2], [2, 3], [3, 4]]) == 3\nassert max_non_overlapping_intervals([[1, 2], [2, 3], [3, 4], [1, 3], [5, 6], [6, 7]]) == 3\nassert max_non_overlapping_intervals([[1, 2], [2, 3], [3, 4], [1, 3], [5, 6], [6, 7], [8, 9]]) == 4\nassert max_non_overlapping_intervals([[1, 2], [2, 3], [3, 4], [1, 3], [5, 6], [6, 7], [8, 9], [9, 10], [10, 11], [11, 12]]) == 4\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: hard\nconcepts: time zone conversion, temperature sensor reading, humidity sensor reading, date and time formatting\n\n### Task", "fingerprint": null, "seed": "void loop(void)\r\n{\r\n\r\n//////////STILL TRYING TO GET ZULU WITH A DIFFERENT LIBRARY\r\n    time_t utc = now();\r\n    time_t local = myTZ.toLocal(utc, &tcr);\r\n    Serial.println();\r\n    printDateTime(utc, \"UTC\");\r\n    printDateTime(local, tcr -> abbrev);\r\n    delay(10000);\r\n          //THIS WORKS -  Now integrate it into the matrix disp\r\n//////////END STILL TRYING TO GET ZULU WITH A DIFFERENT LIBRARY\r\n \r\n////////// TRYING TO FIX TEMP SENSOR\r\n\r\n  // Reading temperature or humidity takes about 250 milliseconds!\r\n  // Sensor readings may also be up to 2 seconds 'old' (its a very slow sensor)\r\n  float hum = dht.readHumidity();\r\n  // Read temperature as Celsius (the default)\r\n  float temp = dht.readTemperature();\r\n  // Read temperature as Fahrenheit (isFahrenheit = true)\r\n  // float fern = dht.readTemperature(true);\r\n\r\n  // Check if any reads failed and exit early (to try again).\r\n            if (isnan(hum) || isnan(temp)) {           //  if (isnan(hum) || isnan(temp)) {     \r\n    return;\r\n  }                ////////THIS MAKES THE SKETCH STOP FOR A MOMENT - WHY???\r\n\r\n//////// END TEMP SENSOR\r\n  \r\n  static uint32_t lastTime = 0; // millis() memory\r\n  static uint8_t  display = 0;  // current display mode\r\n  static bool flasher = false;  // seconds passing flasher\r\n\r\n//char phln = (RTC.h - 420);\r\nfloat frnt = (temp*1.8+32);           //Changed int to float to get decimals - WORKS\r\n\r\n  P.displayAnimate();\r\n\r\n  P.setIntensity(0);                  //Intensity - Change with time later\r\n  if (P.getZoneStatus(0))\r\n  {\r\n    switch (display)\r\n    {\r\n      case 0: //SET AS ZULU TIME \r\n        P.setTextEffect(0, PA_FADE, PA_FADE);\r\n        display++;  \r\n\r\n        /////////   Now I just need to stop the glitch\r\n        /////////   and add 420 to time (ZULU)\r\n        ///         getTime((szTime), phln ); \r\n        ///         strcpy(phln, szMesg);\r\n        /////////   I've tried to get this to flash like the other clock but it\r\n        /////////   isn't working \r\n          strcpy(szMesg, \"W6LU\");\r\n\r\n//       getTime((szMesg), \"z\"); \r\n//       const int offset = -8;  // Pacific Standard Time (USA) - This line breaks it.\r\n        break;\r\n/*                                            \r\n      case 1: // Temperature deg C\r\n        P.setTextEffect(0, PA_SCROLL_LEFT, PA_SCROLL_UP_LEFT);\r\n        display++;\r\n        \r\n          dtostrf(temp, 3, 1, szMesg);\r\n          strcat(szMesg, \"$\");\r\n     \r\n        break;\r\n \r\n      case 2: // Temperature deg F\r\n        P.setTextEffect(0, PA_SCROLL_UP_LEFT, PA_SCROLL_LEFT);\r\n        display++;\r\n        \r\n          dtostrf(frnt, 3, 1, szMesg);\r\n          strcat(szMesg, \"&\");\r\n\r\n        break;\r\n\r\n      case 3: // Relative Humidity\r\n        P.setTextEffect(0, PA_SCROLL_LEFT, PA_SCROLL_LEFT);\r\n        display++;\r\n\r\n          dtostrf(hum, 3, 0, szMesg);\r\n          strcat(szMesg, \"% H \");\r\n\r\n        break;\r\n \r\n      case 4: // Call Sign\r\n        P.setTextEffect(0, PA_GROW_UP, PA_GROW_DOWN);     //I like PA_WIPE too - \r\n        display++;\r\n        \r\n          strcpy(szMesg, \"W6LU\");\r\n\r\n        break;\r\n \r\n\r\n      case 5: // day of week\r\n        P.setTextEffect(0, PA_SCROLL_LEFT, PA_SCROLL_LEFT);\r\n        display++;\r\n\r\n\r\n          dow2str(szMesg, \"W6LU\", MAX_MESG);\r\n//        dow2str(RTC.dow, szMesg, MAX_MESG);\r\n\r\n        break;\r\n*/\r\n      default:  // Calendar\r\n        P.setTextEffect(0, PA_SCROLL_LEFT, PA_SCROLL_LEFT);\r\n        display = 0;\r\n\r\n          strcpy(szMesg, \"W6LU\");      \r\n//        getDate(szMesg);\r\n      break; \r\n    }\r\n\r\n    P.displayReset(0);\r\n  }\r\n  \r\n  \r\n    // Finally, adjust the time string if we have to\r\n    if (millis() - lastTime >= 1000)\r\n    {\r\n      lastTime = millis();\r\n     printDateTime(utc, szTime);\r\n      flasher = !flasher;\r\n      P.displayReset(1);\r\n    }\r\n}", "id": 82, "concepts": ["time zone conversion", "temperature sensor reading", "humidity sensor reading", "date and time formatting"], "instruction": "Given a timestamp in UTC, a list of time zone offsets (in minutes), and two sensor readings (temperature and humidity), write a C++ function to convert the timestamp to each time zone and format the sensor readings according to the following specifications:\n\n- temperature: rounded to the nearest integer and followed by the degree symbol\n- humidity: rounded to one decimal place and followed by the percentage symbol\n\nFor example, given the timestamp `2023-01-01T12:00:00Z`, time zone offsets `[-480, 0, 480]`, temperature `25.3`, and humidity `50.1234`, the function should return the following output:\n\n```\nTime in UTC: 2023-01-01T12:00:00Z\nTime in -8:00: 2023-01-01T04:00:00-08:00\nTime in +0:00: 2023-01-01T12:00:00+00:00\nTime in +8:00: 2023-01-01T20:00:00+08:00\nTemperature: 25.3\u00b0\nHumidity: 50.1%\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: hard\nconcepts: serial communication setup, Modbus/RS-485 configuration, address assignment, energy counter reset, WiFi connection, Blynk configuration, relay control, physical button handling, timer setup, PZEM data acquisition, automatic mode, Blynk value update\n\n### Task", "fingerprint": null, "seed": "void setup()\n{\n  Serial.begin(9600);\n  pzemSerial.begin(9600);\n\n  /* start Modbus/RS-485 serial communication */\n\n  node1.begin(pzemSlave1Addr, pzemSerial);\n  node2.begin(pzemSlave2Addr, pzemSerial);\n  node3.begin(pzemSlave3Addr, pzemSerial);\n\n  /*********************************************************************************************\\\n      Change PZEM address\n  \\*********************************************************************************************/\n\n  /*\n      changeAddress(OldAddress, Newaddress)\n      By Uncomment the function in the below line you can change the slave address from one of the nodes (pzem device),\n      only need to be done ones. Preverable do this only with 1 slave in the network.\n      If you forgot or don't know the new address anymore, you can use the broadcast address 0XF8 as OldAddress to change the slave address.\n      Use this with one slave ONLY in the network.\n      This is the first step you have to do when connecting muliple pzem devices. If you haven't set the pzem address, then this program won't\n      works.\n     1. Connect only one PZEM device to nodemcu and powerup your PZEM\n     2. uncomment the changeAddress function call below i.e., changeAddress(OldAddress, Newaddress)\n     3. change the Newaddress value to some other value. Ex: 0x01, 0x02, 0xF7 etc.,\n     4. upload this program to nodemcu \n     5. if you see \"Changing Slave Address\" on serial monitor, then it successfully changed address \n     6. if you don't see that message, then click on RESET button on nodemcu\n     7. Once this done you have successfully assigned address to pzem device.\n     8. do the same steps for as many devices as you want. \n  */\n\n\n// changeAddress(0XF8, 0x02);                 // uncomment to set pzem address\n\n\n  /*********************************************************************************************\\\n      RESET PZEM Energy\n  \\*********************************************************************************************/\n\n  /*\n        By Uncomment the function in the below line you can reset the energy counter (Wh) back to zero from one of the slaves.\n        resetEnergy(pzemSlaveAddr);\n  */\n\n\n// resetEnergy(0x01);                        // uncomment to reset pzem energy\n\n#if defined(USE_LOCAL_SERVER)\n  WiFi.begin(WIFI_SSID, WIFI_PASS);         // Non-blocking if no WiFi available\n  Blynk.config(AUTH, SERVER, PORT);\n  Blynk.connect();\n#else\n  WiFi.begin(WIFI_SSID, WIFI_PASS);         // Non-blocking if no WiFi available\n  Blynk.config(AUTH);\n  Blynk.connect();\n#endif   \n\n\n  /*********************************************************************************************\\\n      RELAY code\n  \\*********************************************************************************************/\n\n  pinMode(RELAY_PIN_1, OUTPUT);  \n  pinMode(PUSH_BUTTON_1, INPUT_PULLUP);  \n  digitalWrite(RELAY_PIN_1, relay1State);\n    \n  pinMode(RELAY_PIN_2, OUTPUT);  \n  pinMode(PUSH_BUTTON_2, INPUT_PULLUP);  \n  digitalWrite(RELAY_PIN_2, relay2State);\n\n  pinMode(RELAY_PIN_3, OUTPUT);   \n  digitalWrite(RELAY_PIN_3, relay3State);\n\n  pinMode(RELAY_PIN_4, OUTPUT);   \n  digitalWrite(RELAY_PIN_4, relay4State);\n\n  timer.setInterval(GET_PZEM_DATA_TIME,       get_pzem_data);                   // How often you would like to call the function\n  timer.setInterval(AUTO_MODE_TIME,           auto_mode);    \n  timer.setInterval(PHYSICAL_BUTTON_TIME,     checkPhysicalButton);             // Setup a Relay function to be called every 100 ms\n  timer.setInterval(SEND_TO_BLYNK_TIME,       sendtoBlynk);                     // Send PZEM values blynk server every 10 sec\n }", "id": 83, "concepts": ["serial communication setup", "Modbus/RS-485 configuration", "address assignment", "energy counter reset", "WiFi connection", "Blynk configuration", "relay control", "physical button handling", "timer setup", "PZEM data acquisition", "automatic mode", "Blynk value update"], "instruction": "Implement a C++ function `setup_pzem_device` that initializes a PZEM-004T energy counter and connects it to a Blynk server using a WiFi connection. The function should perform the following steps:\n1. Set the Modbus slave address to 1.\n2. Set the Baud rate to 9600.\n3. Set the RS-485 transmission delay to 100 milliseconds.\n4. Connect to the Blynk server using the specified WiFi network and Auth Token.\n5. Declare a Blynk virtual pin for the energy counter's data.\n6. Reset the energy counter's data.\n7. Set up a timer to read the energy counter's data every 5 seconds.\n8. Set up a physical button to toggle the relay's state.\n9. Set the PZEM-004T's operating mode to automatic.\n10. Start the Blynk server.\n11. Update the Blynk value with the energy counter's data.\n\nThe implementation should follow the given steps and use the appropriate Blynk and PZEM-004T functions to achieve the desired functionality."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: hard\nconcepts: buzzer oscillation, sound generation, oscillating device\n\n### Task", "fingerprint": null, "seed": "void warn() {\n    T.oscillate (buzzer,50, HIGH, 4);  \n    // the end state is HIGH, i.e, buzzer is off *  \n}", "id": 84, "concepts": ["buzzer oscillation", "sound generation", "oscillating device"], "instruction": "Implement a C++ function `generate_buzzer_sound` to generate a sound wave representing the oscillation of a buzzer. The function should take the following arguments:\n\n- `frequency`: the frequency of the buzzer in Hz (cycles per second)\n- `duration`: the duration of the sound in seconds\n- `sample_rate`: the number of samples per second (Hz)\n\nThe function should return a NumPy array of samples that can be played as a sound."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: hard\nconcepts: serial communication protocol, CRC-16 calculation, data packet construction\n\n### Task", "fingerprint": null, "seed": "void resetEnergy(uint8_t slaveAddr)                                                // Function to reset energy value on PZEM device.\n{\n  /* The command to reset the slave's energy is (total 4 bytes):\n     Slave address + 0x42 + CRC check high byte + CRC check low byte. */\n  uint16_t u16CRC = 0xFFFF;\n  static uint8_t resetCommand = 0x42;\n  u16CRC = crc16_update(u16CRC, slaveAddr);\n  u16CRC = crc16_update(u16CRC, resetCommand);\n  Serial.println(\"Resetting Energy\");\n  pzemSerial.write(slaveAddr);\n  pzemSerial.write(resetCommand);\n  pzemSerial.write(lowByte(u16CRC));\n  pzemSerial.write(highByte(u16CRC));\n  delay(1000);\n}", "id": 85, "concepts": ["serial communication protocol", "CRC-16 calculation", "data packet construction"], "instruction": "Implement a C++ function `construct_packet(data)` to construct a data packet to be sent over a serial communication channel. The packet format should include a 16-bit CRC-16 value calculated over the data. The function should return a bytearray containing the data and the CRC-16 value."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: hard\nconcepts: pin setup, sensor initialization, data filtering and processing, state machine design for activity recognition, serial communication/README.md\n# Explain Code\nThe Explain Code project aims to develop a tool that can explain code snippets in natural language.\nGiven a code snippet, the tool should produce a comprehensive explanation that covers the following aspects:\n\n1. **Code structure**: Break down the code into its constituent parts, such as functions, classes, and modules.\n2. **Code functionality**: Explain the purpose of each function or module and how they work together to achieve the desired functionality.\n3. **Data flow**: Describe the flow of data through the code, including the input and output of each function or module.\n4. **Design principles**: Highlight the design principles and best practices that have been followed in the code.\n5. **Code quality**: Point out any potential issues or areas for improvement in the code.\n\nTo develop such a tool, we will employ various techniques from natural language processing and machine learning.\nWe will use techniques like named entity recognition, dependency parsing, and text generation to generate the explanation.\nWe will also leverage pre-trained language models like GPT-3 or BERT to enhance the quality of the generated explanation.\nAdditionally, we will employ techniques like active learning and human feedback to ensure that the generated explanations are accurate and useful.\n\nBy implementing this tool, we aim to make it easier for developers to understand and maintain complex codebases.\nBy providing a detailed explanation of the code, it will help developers to quickly grasp the functionality and structure of the code, making it easier to modify or extend it.\nThis will also help to prevent potential issues and improve code quality.\n\nWe will use the following approach to develop this tool:\n1. **Data collection**: We will collect a dataset of code snippets and their corresponding explanations.\n   This dataset will consist of code snippets and their corresponding explanations written by human experts.\n2. **Model training**: We will train a machine learning model on the dataset to generate explanations for new code snippets.\n   We will use techniques like named entity recognition, dependency parsing, and text generation to generate the explanation.\n   We will also leverage pre-trained language models like GPT-3 or BERT to enhance the quality of the generated explanation.\n3. **Active learning**: We will use active learning to iteratively improve the model's performance.\n   This will involve human experts providing feedback on the generated explanations, allowing the model to learn from its mistakes and improve over time.\n4. **Model evaluation**: We will evaluate the model's performance by testing it on a held-out test set.\n   We will use metrics like precision, recall, and F1-score to measure the model's accuracy and effectiveness.\n5. **Deployment**: Once the model has been trained and evaluated, we will deploy it as a web service or a command-line tool.\n   This will allow developers to easily understand and maintain complex codebases by providing a detailed explanation of the code.\n\nBy following this approach, we aim to develop a tool that can explain code snippets in natural language, making it easier for developers to understand and maintain complex codebases.\n/data/code_to_concepts.md\n## Code to Concepts\n\nIn this task, we will be using a code snippet and its corresponding concepts to train a model that can extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. The model should be able to identify these concepts and provide a list of them in a comma-separated format.\n\nBelow is an example of a code snippet and its corresponding concepts:\n\n```python\ndef verify_password(user_id, password):\n    password_hash = get_password_hash(user_id)\n    if not check_password_hash(password_hash, password):\n        raise ValueError(\"Incorrect password\")\n```\n\nThe corresponding concepts for this code snippet are:\n- Hashing\n- Password Storage\n- Salting\n\nTo train a model to identify these concepts, we will be using a dataset consisting of code snippets and their corresponding concepts. We will use a machine learning algorithm like a neural network or a decision tree to build the model. We will train the model on the dataset and evaluate its performance using various evaluation metrics like accuracy, precision, recall, and F1-score.\n\nBelow is the implementation of the model using a neural network:\n\n```python\nimport torch\nimport torch.nn as nn\n\nclass ConceptExtractor(nn.Module):\n    def __init__(self, input_size, hidden_size, output_size):\n        super(ConceptExtractor, self).__init__()\n        self.fc1 = nn.Linear(input_size, hidden_size)\n        self.relu = nn.ReLU()\n        self.fc2 = nn.Linear(hidden_size, output_size)\n\n    def forward(self, x):\n        x = self.fc1(x)\n        x = self.relu(x)\n        x = self.fc2(x)\n        return x\n```\n\n### Task", "fingerprint": null, "seed": "void setup() {\n  analogReference(EXTERNAL);\n  pinMode(X_ACCEL, INPUT);\n  pinMode(Y_ACCEL, INPUT);\n  pinMode(Z_ACCEL, INPUT);\n  pinMode(ledPin, OUTPUT);\n\n  queue_position = 0;\n\n  Serial.begin(9600);\n  Serial1.begin(9600);\n\n  mean_x = 0;\n  mean_y = 0;\n  mean_z = 0;\n  mean_counter = 0;\n//  Serial.begin(9600);\n\n  filtered_value = new FilterBuHp2();\n\n  // Get mean value for threshold\n//  Serial.println(\"Starting callibration...\");\n  t0 = millis();\n  while (millis() - t0 < 4000)\n  {\n    mean_x += getSeparatedValues(X_ACCEL);\n    mean_y += getSeparatedValues(Y_ACCEL);\n    mean_z += getSeparatedValues(Z_ACCEL);\n    mean_counter++;\n  }\n  \n  mean_x /= mean_counter;\n  mean_y /= mean_counter;\n  mean_z /= mean_counter;\n\n//  Serial.print(\"Callibration done! With samples: \");\n//  Serial.println(mean_counter);\n  // Get mean value for threshold\n  /*Serial.println(\"Starting accel callibration. Please stand still for 5 seconds.\");\n  int t0 = millis();\n  while (millis() - t0 < 4000)\n  {\n    mean_value = getFilteredSignal(X_ACCEL, Y_ACCEL, Z_ACCEL);\n  }*/\n  \n//  Serial.print(\"Callibration done! With samples: \");\n//  Serial.println(mean_counter);\n\n  state = 0;\n  t0 = millis();\n}", "id": 86, "concepts": ["pin setup", "sensor initialization", "data filtering and processing", "state machine design for activity recognition", "serial communication/README.md\n# Explain Code\nThe Explain Code project aims to develop a tool that can explain code snippets in natural language.\nGiven a code snippet", "the tool should produce a comprehensive explanation that covers the following aspects:\n\n1. **Code structure**: Break down the code into its constituent parts", "such as functions", "classes", "and modules.\n2. **Code functionality**: Explain the purpose of each function or module and how they work together to achieve the desired functionality.\n3. **Data flow**: Describe the flow of data through the code", "including the input and output of each function or module.\n4. **Design principles**: Highlight the design principles and best practices that have been followed in the code.\n5. **Code quality**: Point out any potential issues or areas for improvement in the code.\n\nTo develop such a tool", "we will employ various techniques from natural language processing and machine learning.\nWe will use techniques like named entity recognition", "dependency parsing", "and text generation to generate the explanation.\nWe will also leverage pre-trained language models like GPT-3 or BERT to enhance the quality of the generated explanation.\nAdditionally", "we will employ techniques like active learning and human feedback to ensure that the generated explanations are accurate and useful.\n\nBy implementing this tool", "we aim to make it easier for developers to understand and maintain complex codebases.\nBy providing a detailed explanation of the code", "it will help developers to quickly grasp the functionality and structure of the code", "making it easier to modify or extend it.\nThis will also help to prevent potential issues and improve code quality.\n\nWe will use the following approach to develop this tool:\n1. **Data collection**: We will collect a dataset of code snippets and their corresponding explanations.\n   This dataset will consist of code snippets and their corresponding explanations written by human experts.\n2. **Model training**: We will train a machine learning model on the dataset to generate explanations for new code snippets.\n   We will use techniques like named entity recognition", "dependency parsing", "and text generation to generate the explanation.\n   We will also leverage pre-trained language models like GPT-3 or BERT to enhance the quality of the generated explanation.\n3. **Active learning**: We will use active learning to iteratively improve the model's performance.\n   This will involve human experts providing feedback on the generated explanations", "allowing the model to learn from its mistakes and improve over time.\n4. **Model evaluation**: We will evaluate the model's performance by testing it on a held-out test set.\n   We will use metrics like precision", "recall", "and F1-score to measure the model's accuracy and effectiveness.\n5. **Deployment**: Once the model has been trained and evaluated", "we will deploy it as a web service or a command-line tool.\n   This will allow developers to easily understand and maintain complex codebases by providing a detailed explanation of the code.\n\nBy following this approach", "we aim to develop a tool that can explain code snippets in natural language", "making it easier for developers to understand and maintain complex codebases.\n/data/code_to_concepts.md\n## Code to Concepts\n\nIn this task", "we will be using a code snippet and its corresponding concepts to train a model that can extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming", "which are crucial for developers to master. The model should be able to identify these concepts and provide a list of them in a comma-separated format.\n\nBelow is an example of a code snippet and its corresponding concepts:\n\n```python\ndef verify_password(user_id", "password):\n    password_hash = get_password_hash(user_id)\n    if not check_password_hash(password_hash", "password):\n        raise ValueError(\"Incorrect password\")\n```\n\nThe corresponding concepts for this code snippet are:\n- Hashing\n- Password Storage\n- Salting\n\nTo train a model to identify these concepts", "we will be using a dataset consisting of code snippets and their corresponding concepts. We will use a machine learning algorithm like a neural network or a decision tree to build the model. We will train the model on the dataset and evaluate its performance using various evaluation metrics like accuracy", "precision", "recall", "and F1-score.\n\nBelow is the implementation of the model using a neural network:\n\n```python\nimport torch\nimport torch.nn as nn\n\nclass ConceptExtractor(nn.Module):\n    def __init__(self", "input_size", "hidden_size", "output_size):\n        super(ConceptExtractor", "self).__init__()\n        self.fc1 = nn.Linear(input_size", "hidden_size)\n        self.relu = nn.ReLU()\n        self.fc2 = nn.Linear(hidden_size", "output_size)\n\n    def forward(self", "x):\n        x = self.fc1(x)\n        x = self.relu(x)\n        x = self.fc2(x)\n        return x\n```"], "instruction": "-specific Design\n\nThis task requires a model that can extract key programming concepts from the provided code snippet. To accomplish this, we will need to design the model to handle the specific nature of the task.\n\nWe will be using a neural network as the model. The input to the model will be the code snippet, which we will process using a pre-trained language model like BERT. The output will be a list of concepts, which will be generated using a softmax layer.\n\nHere is the implementation of the model using a neural network:\n\n```python\nimport torch\nimport torch.nn as nn\n\nclass ConceptExtractor(nn.Module):\n    def __init__(self, bert_model, num_concepts):\n        super(ConceptExtractor, self).__init__()\n        self.bert = bert_model\n        self.fc = nn.Linear(self.bert.config.hidden_size, num_concepts)\n\n    def forward(self, input_ids, attention_mask):\n        outputs = self.bert(input_ids=input_ids, attention_mask=attention_mask)\n        last_hidden_state = outputs.last_hidden_state\n        pooled_output = torch.mean(last_hidden_state, dim=1)\n        logits = self.fc(pooled_output)\n        return logits\n```\n\nThis implementation uses a pre-trained BERT model to process the input code snippet. The output of the BERT model is pooled to a fixed-length vector, which is then passed through a fully-connected layer to generate the logits for each concept.\n\nWe will be using a pre-trained BERT model to process the input code snippet. BERT is a Transformer-based language model that has been pre-trained on a large corpus of text, including code. This allows the model to capture the context and semantics of the code, which is crucial for the task of identifying programming concepts.\n\nThe output of the BERT model is pooled to a fixed-length vector, which is then passed through a fully-connected layer to generate the logits for each concept. The softmax function is then applied to the logits to generate the probabilities for each concept.\n\nWe will be using a dataset consisting of code snippets and their corresponding concepts. We will use a machine learning algorithm like a neural network or a decision tree to build the model. We will train the model on the dataset and evaluate its performance using various evaluation metrics like accuracy, precision, recall, and F1-score.\n/data/code_to_concepts.md@@ -1,10 +1,10 @@\n \n-## Code to Concepts\n+## Code to Concepts Explanation\n \n In this task, we will be using a code snippet and its corresponding concepts to train a model that can extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. The model should be able to identify these concepts and provide a list of them in a comma-separated format.\n \n Below is an example of a code snippet and its corresponding concepts:\n \n ```python\n def verify_password(user_id, password):\n     password_hash = get_password_hash(user_id)@@ -33,17 +33,17 @@\n         x = self.relu(x)\n         x = self.fc2(x)\n         return x\n ```\n \n ### Task-specific Design\n \n This task requires a model that can extract key programming concepts from the provided code snippet. To accomplish this, we will need to design the model to handle the specific nature of the task.\n-\n+Here is an example of a code snippet and its corresponding concepts:\n We will be using a neural network as the model. The input to the model will be the code snippet, which we will process using a pre-trained language model like BERT. The output will be a list of concepts, which will be generated using a softmax layer.\n \n Here is the implementation of the model using a neural network:\n \n ```python\n import torch\n import torch.nn as nn\n @@ -65,10 +65,11 @@\n         outputs = self.bert(input_ids=input_ids, attention_mask=attention_mask)\n         last_hidden_state = outputs.last_hidden_state\n         pooled_output = torch.mean(last_hidden_state, dim=1)\n         logits = self.fc(pooled_output)\n         return logits\n ```\n \n This implementation uses a pre-trained BERT model to process the input code snippet. The output of the BERT model is pooled to a fixed-length vector, which is then passed through a fully-connected layer to generate the logits for each concept.\n+Here is an example of a code snippet and its corresponding concepts:\n username_1: This is a good start. We can do better! Here are some ways to improve it:\r\n\r\n1. You can add more examples to demonstrate your knowledge of the task. For example, you could provide more code snippets and their corresponding concepts.\r\n2. You can provide more details about your solution. For example, you could explain how you would approach the task using a specific algorithm or technique.\r\n3. You can provide more specific instructions for the reviewer. For example, you could ask the reviewer to check that your solution meets the requirements of the task.\r\n\r\nHere is an example of how you could improve your explanation:\r\n\r\n```\r\nTo solve this task, I would approach it using a neural network. I would first preprocess the data, such as tokenizing the code snippets and encoding the concepts as labels. I would then train a neural network on the preprocessed data to generate a model that can predict the concepts given a code snippet. I would evaluate the model's performance using metrics such as accuracy, precision, and recall.\r\n```1515307883commented"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: medium\nconcepts: constant function definition, function signature, function body, function arguments\n\n### Task", "fingerprint": null, "seed": "void defineConstantFunction(MincBlockExpr* scope, const char* name, PawsType* returnType, std::vector<PawsType*> argTypes, std::vector<std::string> argNames, FuncBlock body, void* funcArgs)\n{\n\tPawsFunc* pawsFunc = new PawsConstFunc(name, returnType, argTypes, argNames, body, funcArgs);\n\tscope->defineSymbol(name, PawsFunctionType::get(pawsSubroutineScope, returnType, argTypes), new PawsFunction(pawsFunc));\n}", "id": 87, "concepts": ["constant function definition", "function signature", "function body", "function arguments"], "instruction": "Implement a C++ program that defines a function named constant with two arguments: n and value. The function should return a list of length n with each element having the same value.\n\nYou must provide the following code snippets:\n\n```cpp\nfunction_signature = \"list constant(int n, int value)\"\nfunction_body = \"[value for _ in range(n)]\"\n```\n\nThe program should pass the following assertions:\n\n```cpp\nassert constant(5, 1) == [1, 1, 1, 1, 1]\nassert constant(10, 0) == [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\nassert constant(2, 'a') == ['a', 'a']\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: easy\nconcepts: OpenACC directives for data movement and parallelization, memory layout\n\n### Task", "fingerprint": null, "seed": "void transpose(float *data_in, float *data_out, int Nx, int Ny) \n{ \n\tint i, j; \n\t#pragma acc parallel loop independent present(data_in[0:Nx*Ny],data_out[0:Ny*Nx]) \n\tfor(i=0;i<Ny;i++) \n\t{ \n\t\t#pragma acc loop independent \n\t\tfor(j=0;j<Nx;j++) \n\t\t{ \n\t\t\tdata_out[i+j*Ny] = data_in[i*Nx+j]; \n\t\t} \n\t} \n}", "id": 88, "concepts": ["OpenACC directives for data movement and parallelization", "memory layout"], "instruction": "Given a 2D array `data` with dimensions `M` by `N`, write a C++ program using OpenACC to perform the following tasks:\n1. Copy the contents of `data` to a new 2D array `result` with dimensions `N` by `M` (transpose of `data`).\n2. Sum the elements of `result` along the second dimension (columns) and store the results in a 1D array `col_sums` of size `N`.\n3. Compute the average of the elements in each row of `result` and store the results in a 1D array `row_avgs` of size `M`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: CUDA programming for GPU acceleration, data transfer between host and device, parallel loop execution\n\n### Task", "fingerprint": null, "seed": "void fdst_gpu(float *data, float *data2, float *data3, int Nx, int Ny, int Lx) \n{ \n\tfloat s; \n\ts = sqrt(2.0/(Nx+1)); \n\t#pragma acc data present(data3[0:2*Lx*Ny],data[0:Nx*Ny],data2[0:Lx*Ny]) \n\t{ \n\t\texpand_data(data, data2, Nx, Ny, Lx); \n\t\texpand_idata(data2, data3, Nx, Ny, Lx); \n\t\t\n\t\t// Copy data to device at start of region and back to host and end of region \n\t\t// Inside this region the device data pointer will be used \n\t\t#pragma acc host_data use_device(data3) \n\t\t{ \n\t\t\tvoid *stream = acc_get_cuda_stream(acc_async_sync); \n\t\t\tcuda_fft(data3, Lx, Ny, stream); \n\t\t} \n\t\t\n\t\t#pragma acc parallel loop independent \n\t\tfor (int i=0;i<Ny;i++) \n\t\t{ \n\t\t\t#pragma acc loop independent \n\t\t\tfor (int j=0;j<Nx;j++)   data[Nx*i+j] = -1.0*s*data3[2*Lx*i+2*j+3]/2; \n\t\t} \n\t}// end data region\n}", "id": 89, "concepts": ["CUDA programming for GPU acceleration", "data transfer between host and device", "parallel loop execution"], "instruction": "Implement a C++ function `calculate_primes_on_gpu` that calculates the prime numbers up to a given `upper_bound` using the CUDA programming model. The function should perform the following steps:\n\n1. Declare and initialize the variables `num_primes` and `num_blocks` based on the `upper_bound`.\n2. Allocate device memory for the `primes` array of size `num_primes` and copy the `upper_bound` to the device.\n3. Create a CUDA kernel that checks each number from 2 to `upper_bound` for primality and stores the prime numbers in the `primes` array.\n4. Launch the kernel with `num_blocks` blocks each containing `256` threads.\n5. Copy the `primes` array back from the device and return it as a `std::vector<int>`.\n\nHere is a sample CUDA kernel that checks for primality:\n\n```cpp\n__global__ void is_prime_kernel(int *primes, int upper_bound)\n{\n    int index = blockIdx.x * blockDim.x + threadIdx.x;\n    if (index < upper_bound) {\n        bool is_prime = true;\n        for (int i = 2; i < index; i++) {\n            if (index % i == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            primes[index] = index;\n        }\n    }\n}\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: hard\nconcepts: simulation of a frame in a game, on-frame callback, game loop\n\n### Task", "fingerprint": null, "seed": "void myOnFrame(void *simulation) {\n    cout << \"FRAME!\" << endl;\n}", "id": 90, "concepts": ["simulation of a frame in a game", "on-frame callback", "game loop"], "instruction": "Implement a C++ program to simulate a single frame in a game. You can choose any game or game mechanic to suit your needs. The program should include an on-frame callback function that will be called every frame, and the game loop that updates the game state and invokes the on-frame callback. The callback function can perform actions specific to the game, such as updating the player's position, handling collisions, or rendering the game state.\n\nTo ensure a smooth gameplay experience, the game loop should run at a fixed frame rate. You can use a timer or a function like `std::this_thread::sleep_for` to control the update frequency.\n\nThe goal is to create a simple yet interactive game that demonstrates your understanding of game development and programming."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: easy\nconcepts: The toKilo() function takes a double value x and returns the equivalent value in kilograms.\n\n### Task", "fingerprint": null, "seed": "double toKilo(double x){\n\ndouble numKilo = x * kilograms;\n    return numKilo;\n    }", "id": 91, "concepts": ["The toKilo() function takes a double value x and returns the equivalent value in kilograms."], "instruction": "The toKilo() function takes a double value x and returns the equivalent value in kilograms.\n\nImplement the function in C++ that converts the value of the given unit (pounds, ounces, and stones) into kilograms, using the following conversion factors:\n\n1 pound = 0.453592 kilograms\n1 ounce = 0.0283495 kilograms\n1 stone = 6.35029 kilograms\n\nHere is the code:\n\n```cpp\ndouble toKilo(double x, string unit) {\n    if (unit == \"pounds\") {\n        return x * 0.453592;\n    } else if (unit == \"ounces\") {\n        return x * 0.0283495;\n    } else if (unit == \"stones\") {\n        return x * 6.35029;\n    } else {\n        return x;\n    }\n}\n```\n\nThe code defines a function `toKilo` that takes two arguments: `x` and `unit`. It checks the value of `unit` and returns the converted value in kilograms according to the provided conversion factors. If `unit` is not one of the three supported units, the function returns `x` as-is.\n\nThe code demonstrates a simple conditional statement that checks the value of `unit` and performs different calculations based on it. The conversion factors are used to convert the given value from pounds, ounces, and stones into kilograms. If `unit` is not one of the supported units, the function returns `x` as-is."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: point-in-polygon checks using bounding box, edge cases handling with boarder size and size checks\n\n### Task", "fingerprint": null, "seed": "inline bool inside(const Vector2d &pt) {\n    return pt(0, 0) >= boarder && pt(1, 0) >= boarder\n           && pt(0, 0) < width - boarder && pt(1, 0) <= height - boarder;\n}", "id": 92, "concepts": ["point-in-polygon checks using bounding box", "edge cases handling with boarder size and size checks"], "instruction": "Implement a C++ function to check whether a given point lies within a polygon. The function should take a list of polygon vertices and a target point as inputs. The polygon can be assumed to be non-self-intersecting and can have any number of sides. The function should return a boolean value indicating whether the point lies within the polygon.\n\nThe function should take care of the following edge cases:\n1. If the point is on the polygon's boundary, the function should return True.\n2. If the polygon is empty or the point is not within the polygon's bounding box, the function should return False.\n3. If the polygon has fewer than three vertices, the function should throw an exception."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: hard\nconcepts: problem solving, sorting, I/O handling\n\n### Task", "fingerprint": null, "seed": "int main()\n{\n\tlong int t,a[3],i;\n\tscanf(\"%li\", &t);\n\twhile(t--)\n\t{\n\t\tfor(i=0;i<3;++i)\n\t\t\tscanf(\"%li\", &a[i]);\n\t\tsort(a,a+3);\n\t\tprintf(\"%li\\n\", a[1]);\n\t}\n\treturn 0;\n}", "id": 93, "concepts": ["problem solving", "sorting", "I/O handling"], "instruction": "Create a C++ program that takes a list of integers as input and returns a new list of integers, sorted in descending order. The program should handle I/O and error handling appropriately.\n\nFor example, given the input `[5, 2, 3, 1]`, the program should print `[5, 3, 2, 1]` to the console. In case of invalid input, the program should print an error message to the console and exit."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: object-oriented programming, error handling, user input validation, data structure for inventory management, cash register simulation\n\n### Task", "fingerprint": null, "seed": "int main()\n{\n\tchar choice = 'N';\n\tint numSelected; // Entered by user\n\tint qtySelected; // Entered by user\n\tdouble subTotal; // Local variable for subTotal\n\tdouble tax; // Local variable for tax\n\tdouble total; // Local variable for total\n\n\tInventoryItem inventory[5] = { InventoryItem(\"Adjustable Wrench\", 3.49, 10),\n\t\t\t\t\t\t\t\t   InventoryItem(\"Screwdriver\", 5.99, 20),\n\t\t\t\t\t\t\t\t   InventoryItem(\"Pliers\", 2.69, 35),\n\t\t\t\t\t\t\t\t   InventoryItem(\"Ratchet\", 3.99, 10),\n\t\t\t\t\t\t\t\t   InventoryItem(\"Socket Wrench\", 2.49, 7) };\n\n\tdo\n\t{\n\t\tcout << left << setw(5) << \"#\" << setw(20) << \"Item\" << setw(20) << \"qty on Hand\" << endl;\n\t\tcout << \"-------------------------------------------------------\" << endl;\n\n\t\t// Display the inventory item\n\t\tDisplayItem(inventory);\n\n\t\t// Ask the user which item do they want to buy\n\t\tcout << endl << \"Which item above is beging purchased?\" << endl;\n\t\tcin >> numSelected;\n\n\t\t// Validate the user's input is on the list\n\t\twhile ((numSelected - 1) < 0 || (numSelected - 1) > 4)\n\t\t{\n\t\t\tcout << \"Invalid entry, please enter the valid number of goods: \";\n\t\t\tcin >> numSelected;\n\t\t}\n\n\n\t\t// Validate the item is not out of stock\n\t\twhile (inventory[numSelected - 1].getUnits() == 0)\n\t\t{\n\t\t\tcout << \"Sorry, this item is out of stock.\" << endl;\n\t\t\tcout << \"Please choose another item: \";\n\t\t\tcin >> numSelected;\n\t\t}\n\n\t\t// Ask the user how many items do they want\n\t\tcout << \"How many units?\" << endl;\n\t\tcin >> qtySelected;\n\n\t\t// Validate the qtySelected is not a negative value\n\t\twhile (qtySelected < 0)\n\t\t{\n\t\t\tcout << \"Error. Cannot enter negetive number\" << endl;\n\t\t\tcout << \"Please enter again: \";\n\t\t\tcin >> qtySelected;\n\t\t}\n\n\t\t// Validate the inventory of item is not being a negative value\n\t\twhile (inventory[numSelected - 1].getUnits() < qtySelected)\n\t\t{\n\t\t\tcout << \"Sorry. We do not have enough items.\" << endl;\n\t\t\tcout << \"Please enter again: \";\n\t\t\tcin >> qtySelected;\n\t\t}\n\n\t\t// Update InventoryItem\n\t\tinventory[numSelected - 1].setUnits(inventory[numSelected - 1].getUnits() - qtySelected);\n\n\t\t// Define an instance of the CashRegister class\n\t\tCashRegister Sale = CashRegister(inventory[numSelected - 1], qtySelected);\n\n\t\tcout << endl;\n\t\t// Get subtotal, tax, and total\n\t\tsubTotal = Sale.GetSubtotal();\n\t\ttax = Sale.GetTax();\n\t\ttotal = Sale.GetTotal();\n\n\t\t// Display subtotal, tax, and total\n\t\tcout << fixed << showpoint << setprecision(2);\n\t\tcout << \"Subtotal: $ \" << subTotal << endl;\n\t\tcout << \"Tax: $ \" << tax << endl;;\n\t\tcout << \"Total: $ \" << total << endl << endl;\t\t\n\n\t\t// Ask user to run again or not\n\t\tcout << \"Do you want to purchase another item? (Y/N)  \";\n\t\tcin >> choice;\n\t\tcout << endl;\n\t\t\n\t} while (choice == 'Y' || choice == 'y');\n\t\n\tcout << endl;\n\n\treturn 0;\n}", "id": 94, "concepts": ["object-oriented programming", "error handling", "user input validation", "data structure for inventory management", "cash register simulation"], "instruction": "Implement a C++ class `CashRegister` that simulates a cash register. It should have methods to add and remove items from an inventory, as well as calculate the total price of all items in the inventory. Additionally, handle any errors that may arise during the process, such as trying to remove an item that isn't in the inventory.\n\nThe `CashRegister` class should have the following methods:\n- `add_item(item, price)`: adds an item to the inventory with a given price.\n- `remove_item(item)`: removes an item from the inventory. If the item isn't in the inventory, raise a ValueError.\n- `calculate_total()`: calculates the total price of all items in the inventory.\n- `pay(amount)`: simulates payment for the total price. If the amount provided is less than the total price, raise a ValueError. Otherwise, return the change amount.\n\nHere is an example implementation of the `CashRegister` class:\n\n```cpp\nclass CashRegister {\n    private:\n        std::map<std::string, double> inventory;\n        double total = 0.0;\n    \n    public:\n        void add_item(std::string item, double price) {\n            inventory[item] = price;\n            total += price;\n        }\n        \n        void remove_item(std::string item) {\n            if (inventory.count(item) == 0) {\n                throw std::invalid_argument(\"Item not found in inventory\");\n            }\n            inventory.erase(item);\n            total -= inventory[item];\n        }\n        \n        double calculate_total() {\n            return total;\n        }\n        \n        double pay(double amount) {\n            if (amount < total) {\n                throw std::invalid_argument(\"Insufficient amount provided\");\n            }\n            double change = amount - total;\n            total = 0.0;\n            return change;\n        }\n};\n```\n\nThis class utilizes a `std::map` to store the inventory, where the keys are the item names and the values are their prices. The `total` variable tracks the total price of all items in the inventory.\n\nThe `add_item` method adds an item to the inventory with a given price and updates the total price. The `remove_item` method removes an item from the inventory and updates the total price accordingly. The `calculate_total` method returns the current total price of all items in the inventory. The `pay` method simulates payment and returns the change amount if the provided amount is greater than or equal to the total price. Otherwise, it raises a `std::invalid_argument` exception."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: unit testing, test-driven development, code quality measurement\n\n### Task", "fingerprint": null, "seed": "int main() {\n    \n    UnitTest test;\n\n    test.run();\n}", "id": 95, "concepts": ["unit testing", "test-driven development", "code quality measurement"], "instruction": "Implement a C++ class `CodeQuality` to measure the code quality of a given C++ program. The class should have the following methods:\n\n- `CodeQuality(source_code)`: Initialize the class with the given source code as a string.\n- `count_lines()`: Count the number of lines in the source code.\n- `count_comments()`: Count the number of comments in the source code.\n- `count_functions()`: Count the number of functions in the source code.\n\nThe class should also have a `get_quality()` method that returns a quality score based on the number of lines, comments, and functions in the source code. You can use any formula you like to calculate the quality score.\n\nHere is an example of how you could implement the `CodeQuality` class:\n\n```cpp\nclass CodeQuality {\npublic:\n    CodeQuality(std::string source_code) {\n        this->source_code = source_code;\n    }\n\n    int count_lines() {\n        int count = 0;\n        for (char c : this->source_code) {\n            if (c == '\\n') {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    int count_comments() {\n        int count = 0;\n        for (char c : this->source_code) {\n            if (c == '/' && this->source_code[i + 1] == '/') {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    int count_functions() {\n        int count = 0;\n        for (char c : this->source_code) {\n            if (c == '/' && this->source_code[i + 1] == '/' && this->source_code[i + 2] == '/') {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    double get_quality() {\n        int lines = count_lines();\n        int comments = count_comments();\n        int functions = count_functions();\n        return (lines - comments) / functions;\n    }\n\nprivate:\n    std::string source_code;\n};\n```\n\nYou can test your implementation by writing unit tests for the `CodeQuality` class. Here is an example of how you could test the `count_lines()` method:\n\n```cpp\nCodeQuality code_quality(\"int main() {\\n    return 0;\\n}\");\nint actual_lines = code_quality.count_lines();\nint expected_lines = 3;\nassert(actual_lines == expected_lines);\n```\n\nYou can also test the `count_comments()`, `count_functions()`, and `get_quality()` methods in a similar way."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: medium\nconcepts: depth-first search (DFS) traversal, tree construction, parent-child relation storage\n\n### Task", "fingerprint": null, "seed": "void dfs(int u,int fath)\n{\n\tfa[u][0]=fath;deep[u]=deep[fath]+1;\n\tfor(int i=head[u];i;i=e[i].next)\n\t{\n\t\tint v=e[i].v;\n\t\tif(v==fath) continue;\n\t\tval[v][0]=e[i].w;\n\t\tdfs(v,u);\n\t}\n}", "id": 96, "concepts": ["depth-first search (DFS) traversal", "tree construction", "parent-child relation storage"], "instruction": "Given a list of nodes `nodes` and a list of parent-child relations `edges`, construct a tree from the nodes and relations and return the root node. The nodes are represented as integers while the parent-child relations are represented as pairs of integers. For example, given `nodes = [1, 2, 3, 4, 5]` and `edges = [(1, 2), (1, 3), (2, 4), (3, 5)]`, the resulting tree should look like:\n\n```\n    1\n  /   \\\n2       3\n      /\n    4\n  /\n5\n```\n\nImplement a C++ program to construct and traverse the tree using DFS."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: function definition, function signature, initialization, library import\n\n### Task", "fingerprint": null, "seed": "void TriggerDictionaryInitialization_BMHitClusterDict() {\n  TriggerDictionaryInitialization_BMHitClusterDict_Impl();\n}", "id": 98, "concepts": ["function definition", "function signature", "initialization", "library import"], "instruction": "Implement a C++ function `get_first_n_primes(n)` that returns the first n prime numbers, where n is a positive integer. The function should take no arguments and return a list of prime numbers.\n\n```cpp\ndef is_prime(num):\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\ndef get_first_n_primes():\n    primes = []\n    num = 2\n    while len(primes) < n:\n        if is_prime(num):\n            primes.append(num)\n        num += 1\n    return primes\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: medium\nconcepts: string reversal using two nested loops, space handling\n\n### Task", "fingerprint": null, "seed": "int main()\n{\n    int t;\n    cin>>t;\n    getchar();\n    while(t--)\n    {\n        char a[1001];\n        cin.getline(a,1001);\n        int n=strlen(a);\n        for(int i=0;i<n;i++)\n        {\n            int k=i;\n            while(a[k]!=' '&&a[k]!='\\0') k++;\n            for(int j=k-1;j>=i;j--)\n              cout<<a[j]; i=k;\n             if(a[i]==' ') cout<<' ';\n        }\n        cout<<endl;\n    }\n}", "id": 99, "concepts": ["string reversal using two nested loops", "space handling"], "instruction": "Write a C++ program to reverse the order of words in a given string, without allocating any additional space. For example, given `\"this is a test\"`, the program should return `\"test a is this\"`.\n\nThe program should be designed in a way that shows the following properties:\n\n- It uses two nested loops, one for iterating through the words and the other for reversing the characters in each word.\n- It handles spaces appropriately to ensure that the words are reversed correctly.\n- It does not allocate any additional space for storing the reversed string."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: easy\nconcepts: parser generation, abstract syntax tree construction, syntax error handling\n\n### Task", "fingerprint": null, "seed": "int main(int argc, char *argv[])\n{\n\tyyparse();\n\treturn 0;\n}", "id": 100, "concepts": ["parser generation", "abstract syntax tree construction", "syntax error handling"], "instruction": "Implement a C++ program that reads a math expression from standard input in Reverse Polish Notation (RPN), evaluates it, and prints the result to standard output.\n\nThe Reverse Polish Notation is a postfix notation where operators come after their operands. For example, the expression `(1 + 2) * 3` would be written as `1 2 + 3 *`.\n\nYour program should handle the following arithmetic operators: `+`, `-`, `*`, `/`, and `^` (exponentiation).\n\nYou can assume that the input is valid and follows the Reverse Polish Notation format.\n\nHere is the pseudocode for the program:\n\n```cpp\ndef main():\n    stack = []\n    while true:\n        token = read_token()\n        if token is a number:\n            stack.push(token)\n        elif token is an operator:\n            if stack is empty or has fewer than two elements:\n                print(\"Invalid expression!\")\n                break\n            right = stack.pop()\n            left = stack.pop()\n            result = evaluate(left, right, token)\n            stack.push(result)\n        elif token is EOF:\n            if stack is empty:\n                print(\"Invalid expression!\")\n            else:\n                print(stack.pop())\n            break\n        else:\n            print(\"Invalid token!\")\n            break\n```\n\nThe `read_token()` function reads a single token from the input stream and returns it. The `evaluate()` function takes two operands and an operator and returns the result of applying the operator to the operands."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: sensor data processing, mathematical operations for vector magnitude calculation, function design for reusability\n\n### Task", "fingerprint": null, "seed": "float getSimpleValue(int pin_x, int pin_y, int pin_z)\n{\n  float instant_value_x = analogRead(pin_x);\n  float instant_value_y = analogRead(pin_y);\n  float instant_value_z = analogRead(pin_z);\n\n  float result = sqrt(pow(instant_value_x,2) + pow(instant_value_y,2) + pow(instant_value_z,2));\n\n  return result;\n}", "id": 101, "concepts": ["sensor data processing", "mathematical operations for vector magnitude calculation", "function design for reusability"], "instruction": "Write a C++ function to compute the magnitude of a three-dimensional vector (x, y, z) from sensor data. The sensor data is provided as a list of tuples, where each tuple represents a measurement. The first element of the tuple is the timestamp, the second element is the x-axis value, the third element is the y-axis value, and the fourth element is the z-axis value. The function should return a list of magnitude values corresponding to the input sensor data."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: hard\nconcepts: convolution backpropagation, reverse computation, padding handling, coordinate transformation\n\n### Task", "fingerprint": null, "seed": "void avg_pool_backprop(const T* delta,\n                       T* out,\n                       const Shape& delta_shape,\n                       const Shape& out_shape,\n                       const Shape& window_shape,\n                       const Strides& window_movement_strides,\n                       const Shape& padding_below,\n                       const Shape& padding_above,\n                       bool include_padding_in_avg_computation) {\n    NGRAPH_SUPPRESS_DEPRECATED_START\n    CoordinateTransform out_transform(out_shape);\n\n    for (const Coordinate& out_coord : out_transform) {\n        out[out_transform.index(out_coord)] = 0;\n    }\n\n    CoordinateTransform delta_transform(delta_shape);\n\n    for (const Coordinate& delta_coord : delta_transform) {\n        size_t img_index = delta_coord[0];\n        size_t channel = delta_coord[1];\n\n        size_t n_image_dimensions = out_shape.size() - 2;\n        Coordinate source_window_transform_start(2 + n_image_dimensions);\n        Coordinate source_window_transform_end(2 + n_image_dimensions);\n        Strides source_window_transform_source_strides(2 + n_image_dimensions, 1);\n        AxisVector source_window_transform_source_axis_order(2 + n_image_dimensions);\n        CoordinateDiff source_window_transform_padding_below(2 + n_image_dimensions);\n        CoordinateDiff source_window_transform_padding_above(2 + n_image_dimensions);\n\n        source_window_transform_start[0] = img_index;\n        source_window_transform_end[0] = img_index + 1;\n        source_window_transform_start[1] = channel;\n        source_window_transform_end[1] = channel + 1;\n        source_window_transform_padding_below[0] = 0;\n        source_window_transform_padding_below[1] = 0;\n        source_window_transform_padding_above[0] = 0;\n        source_window_transform_padding_above[1] = 0;\n\n        for (size_t i = 2; i < n_image_dimensions + 2; i++) {\n            size_t window_shape_this_dim = window_shape[i - 2];\n            size_t movement_stride = window_movement_strides[i - 2];\n\n            source_window_transform_start[i] = movement_stride * delta_coord[i];\n            source_window_transform_end[i] = source_window_transform_start[i] + window_shape_this_dim;\n            source_window_transform_padding_below[i] = padding_below[i - 2];\n            source_window_transform_padding_above[i] = padding_above[i - 2];\n        }\n        std::iota(begin(source_window_transform_source_axis_order), end(source_window_transform_source_axis_order), 0);\n\n        CoordinateTransform source_window_transform(out_shape,\n                                                    source_window_transform_start,\n                                                    source_window_transform_end,\n                                                    source_window_transform_source_strides,\n                                                    source_window_transform_source_axis_order,\n                                                    source_window_transform_padding_below,\n                                                    source_window_transform_padding_above);\n\n        size_t num_elements_in_window = 0;\n\n        for (const Coordinate& source_window_coord : source_window_transform) {\n            if (source_window_transform.has_source_coordinate(source_window_coord) ||\n                include_padding_in_avg_computation) {\n                num_elements_in_window++;\n            }\n        }\n\n        for (const Coordinate& source_window_coord : source_window_transform) {\n            if (source_window_transform.has_source_coordinate(source_window_coord)) {\n                size_t out_index = source_window_transform.index(source_window_coord);\n                out[out_index] += delta[delta_transform.index(delta_coord)] / num_elements_in_window;\n            }\n        }\n    }\n    NGRAPH_SUPPRESS_DEPRECATED_END\n}", "id": 102, "concepts": ["convolution backpropagation", "reverse computation", "padding handling", "coordinate transformation"], "instruction": "Implement a C++ class that performs the backpropagation step of a convolutional neural network. The class should have a method `convolution_backpropagation(dy, x, k, p, s)` that takes the following parameters:\n\n- `dy`: the gradient of the output of the convolution layer with respect to the loss, an array of shape `(n_out, n_out)`\n- `x`: the input image, an array of shape `(n_in, n_in)`\n- `k`: the kernel size of the convolution layer, an integer\n- `p`: the padding size, an integer\n- `s`: the stride size, an integer\n\nThe method should return the gradient of the input image, an array of shape `(n_in, n_in)`. Note that `n_in` and `n_out` are calculated using the following formulas:\n\n$$\nn_\\text{in} = \\frac{n_\\text{out} \\cdot s - 1}{s - p}\n$$\n\n$$\nn_\\text{out} = \\frac{n_\\text{in} - k + 2 \\cdot p}{s} + 1\n$$\n\nThe method should perform the backpropagation by reversing the convolution operation and considering the padding and stride sizes."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: setup code for initializing the serial communication\n\n### Task", "fingerprint": null, "seed": "void setup() {\n  Serial.begin(9600);   \n}", "id": 103, "concepts": ["setup code for initializing the serial communication"], "instruction": "Implement a C++ function to initialize a serial communication with a given port and baud rate. The function should return a Serial object that represents the communication."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: medium\nconcepts: string matching with a buffer, constant time string comparison\n\n### Task", "fingerprint": null, "seed": "static bool\ngetBoolBuffer(cstring buffer)\n{\n    return buffer[0] == 't' &&\n           buffer[1] == 'r' &&\n           buffer[2] == 'u' &&\n           buffer[3] == 'e';\n}", "id": 104, "concepts": ["string matching with a buffer", "constant time string comparison"], "instruction": "Implement a C++ program that reads lines of input from a file, looks for a given pattern in each line, and then prints the line number and the line itself to the output file. Use a 2048-byte buffer to avoid reading the entire file into memory at once.\n\nThe program should compare the pattern against each line in constant time by comparing the pattern's hash value against that of each line. If the hash values match, then the program should compare the pattern against the line in linear time to verify a match."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: array manipulation, struct usage, function definition and implementation\n\n### Task", "fingerprint": null, "seed": "void addPark (Park parks[], string parkname, string state, int area, int length)\n{\n  //adds the park struct type to the array\n  parks[length].parkname = parkname;\n  parks[length].state = state;\n  parks[length].area = area;\n}", "id": 105, "concepts": ["array manipulation", "struct usage", "function definition and implementation"], "instruction": "Implement a C++ function `get_max_sum(array, k)` that finds the maximum sum of `k` consecutive elements in the given array. The function should return the maximum sum and its corresponding indices in the array.\n\nFor example, given `array = [1, 2, 3, 4, 5]` and `k = 3`, the function should return `12` and the indices `(2, 4)` since the maximum sum is obtained by adding the elements `3 + 4 + 5`.\n\nThe function should handle negative numbers and return the maximum sum, not the sum of the absolute values."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: hard\nconcepts: dictionary lookup for variable mapping, error handling with return values\n\n### Task", "fingerprint": null, "seed": "int calc_get_var(const char *s, int *val)\n{\n\tvar_map::iterator it = calc_var_map.find(s);\n\n\tif (it != calc_var_map.end()) {\n\t\t*val = it->second;\n\t\treturn 0;\n\t} else {\n\t\tstd::cerr << \"variable \" << s << \" is not set\" <<std::endl;\n\t\treturn -1;\n\t}\n}", "id": 106, "concepts": ["dictionary lookup for variable mapping", "error handling with return values"], "instruction": "Write a C++ program that simulates a basic calculator. The program should support arithmetic operations like addition, subtraction, multiplication, and division. It should also support variables as operands. The user can assign a value to a variable using the assignment operator (`=`) and use it in subsequent calculations. The program should handle errors gracefully, such as invalid operations, division by zero, and unassigned variables, by returning an appropriate error message or value.\n\nFor example, the program should evaluate `x = 10`, `y = 20`, and `z = x + y` and return `z` as 30. If the user enters `a + b`, the program should return an error message stating that the variables `a` and `b` are unassigned."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: hard\nconcepts: led blinking, loop iteration, delay function for time control\n\n### Task", "fingerprint": null, "seed": "void blinker() {\n    for (int i=0; i<5; i++) {  // 10\n        digitalWrite(led, LOW);    \n        delay(100);      \n        digitalWrite(led, HIGH);        \n        delay(100); \n    }\n}", "id": 107, "concepts": ["led blinking", "loop iteration", "delay function for time control"], "instruction": "Implement a C++ function `led_blink` that takes three arguments: `led_pin`, an integer representing the pin number of the LED, `times`, an integer representing the number of times the LED should blink, and `delay_ms`, an integer representing the delay in milliseconds between each blink. The function should control the LED to blink the specified number of times, with the delay specified between each blink.\n\nYou can use the delay function `delay(delay_ms)` to control the delay between blinks."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: program entry point, test case handling, function composition\n\n### Task", "fingerprint": null, "seed": "int main()\r\n{\r\n    int no_of_test_cases;\r\n    cin >> no_of_test_cases;\r\n\r\n    while(no_of_test_cases--)\r\n        solve();\r\n\r\n    return 0;\r\n}", "id": 108, "concepts": ["program entry point", "test case handling", "function composition"], "instruction": "Implement a C++ function `is_not_palindrome(string)` to check whether a given string is not a palindrome.\nThe function should employ a test case-based approach to verify its correctness."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: medium\nconcepts: event handling, display update, user interface\n\n### Task", "fingerprint": null, "seed": "void myOnDraw(Display* d) {\n    cout << \"Display\" << endl;\n}", "id": 109, "concepts": ["event handling", "display update", "user interface"], "instruction": "Implement a C++ program to simulate a simple drawing application. The program should provide a graphical user interface with a drawing canvas, a color palette, and a set of tools for drawing shapes and manipulating them. The program should handle user input events to update the display and implement the following features:\n\n1. User can draw different shapes (e.g., circle, square, triangle) by selecting them from the toolbox.\n2. User can change the color of the shapes by selecting a color from the palette.\n3. User can move, resize, and delete the shapes by interacting with them on the canvas.\n4. User can save the drawing to a file and load it back for future edits.\n\nThe program should be designed to be extensible, so that new shapes and tools can be added easily."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: hard\nconcepts: forking a child process, socket programming, synchronization between processes, error handling, exception handling, pipe creation and use\n\n### Task", "fingerprint": null, "seed": "int main(int argc, char *argv[]){\n  m_error_t res;\n  size_t tests, errors;\n\n  tests = errors = 0;\n\n  try {\n    Forker Mother;\n\n    printf(\"Test %d: InetStreamSocket CTROR\\n\",++tests);\n    InetStreamSocket socket;\n    puts(\"+++ CTOR finished OK!\");\n    \n    printf(\"Test %d: InetStreamSocket::hostname()\\n\",++tests);\n    res = socket.hostname(\"localhost\");\n    if(ERR_NO_ERROR != res){\n      errors++;\n      printf(\"*** Error: hostname() failed 0x%.4x\\n\",(int)res);\n    } else {\n      puts(\"+++ hostname() finished OK!\");\n    }\n\n    const unsigned short pNum = 60179;\n    printf(\"Test %d: InetStreamSocket::port()\\n\",++tests);\n    res = socket.port(pNum);\n    if(ERR_NO_ERROR != res){\n      errors++;\n      printf(\"*** Error: port() failed 0x%.4x\\n\",(int)res);\n    } else {\n      puts(\"+++ port() finished OK!\");\n    }\n    \n    printf(\"Test %d: InetStreamSocket::ipv4()\\n\",++tests);\n    unsigned long ip = socket.ipv4();\n    // 127.0.0.1\n    const unsigned long loc_ip = (127 << (3*8)) + 1;\n    if((ip != loc_ip) || (pNum != socket.port())){\n      errors++;\n      printf(\"*** Error: Wrong address %d.%d.%d.%d:%d\\n\",\n\t     (int)((ip >> (3*8)) & 0xff),\n\t     (int)((ip >> (2*8)) & 0xff),\n\t     (int)((ip >> (1*8)) & 0xff),\n\t     (int)((ip >> (0*8)) & 0xff),\n\t     socket.port());\n    } else {\n      printf(\"??? Address %d.%d.%d.%d:%d\\n\",\n\t     (int)((ip >> (3*8)) & 0xff),\n\t     (int)((ip >> (2*8)) & 0xff),\n\t     (int)((ip >> (1*8)) & 0xff),\n\t     (int)((ip >> (0*8)) & 0xff),\n\t     socket.port());\n      puts(\"+++ ipv4() finished OK!\");\n    }\n      \n    // Setup pipe for syncronizing server and client\n    int pfd[2];\n    if(::pipe(pfd)){\n      printf(\"*** Error: pipe() failed %d\\n\",errno);\n      perror(\"*** System Error\");\n      mgrThrow(ERR_FILE_OPEN);      \n    }\n\n    pid_t child = -1;\n    res = Mother.fork( child );\n    if(res != ERR_NO_ERROR){\n      printf(\"*** Error: fork() failed 0x%.4x\\n\",(int)res);\n      perror(\"*** System Error\");\n    } else {\n      if(child == 0){\n\tres = do_client(socket,pfd[0],tests,errors);\n\tprintf(\"+++ Client exits 0x%.4x\\n\",(int)res);\n      } else {\n\tres = do_server(socket,pfd[1],tests,errors,child);\n\tprintf(\"+++ Server exits 0x%.4x\\n\",(int)res);\n\tres = Mother.wait(5000);\n\tif(ERR_CANCEL == res){\n\t  puts(\"*** Have Zombies - kill'em\");\n\t  if(ERR_NO_ERROR == Mother.killChildren()){\n\t    res = Mother.wait(1000);\n\t    if(res != ERR_NO_ERROR)\n\t      printf(\"*** Error killing Zombies 0x%.4x\\n\",(int)res);\n\t  }\n\t}\n\tprintf(\"+++ Mother exits 0x%.4x\\n\",(int)res);\n\tprintf(\"Used version: %s\\n\",socket.VersionTag());\n      }\t\n    }\n      \n  }\n  catch(Exception& e){\n    printf(\"*** Caught mgr::Exception: %s\\n\",e.what());\n  }\n\n  return 0;  \n}", "id": 110, "concepts": ["forking a child process", "socket programming", "synchronization between processes", "error handling", "exception handling", "pipe creation and use"], "instruction": "Implement a C++ program that forks a child process. The child process should create a socket connection to a remote host on a given port. The parent process should create a pipe and use it to send a message to the child process. The child process should receive the message, process it, and send a response back to the parent process through the pipe. The parent process should receive the response and display it to the user. Handle any errors or exceptions that may occur during the process."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: hard\nconcepts: linked list intersection, loop detection, hash set usage, null node handling\n\n### Task", "fingerprint": null, "seed": "int main()\n{\n    int start1, start2, n;\n    scanf(\"%d%d%d\", &start1,&start2, &n);\n    for(int i = 0; i < n; i++)\n    {\n        int add, nt;\n        char c;\n        scanf(\"%d %c %d\", &add, &c, &nt);\n        node n1 = {c, nt};\n        arr[add] = n1;\n    }\n\n    set<int> s1;\n\n    int i1 = start1;\n    while(i1 != -1)\n    {\n        s1.insert(i1);\n        i1 = arr[i1].next;\n    }\n\n    int i2 = start2;\n    while(i2 != -1)\n    {\n        if(s1.find(i2) != s1.end())\n        {\n            printf(\"%d\", i2);\n            return 0;\n        }\n        else\n        {\n            i2 = arr[i2].next;\n        }\n        \n    }\n    if(i2 == -1)\n        printf(\"-1\");\n\n    return 0;\n}", "id": 111, "concepts": ["linked list intersection", "loop detection", "hash set usage", "null node handling"], "instruction": "Implement a C++ program that determines whether two linked lists intersect. If they intersect, return the intersecting node. Otherwise, return NULL. Use both a hash set and a loop detection algorithm. Handle the case where one or both linked lists are NULL."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: sum of voltage, current, power, energy, frequency, power factor, error handling for invalid data\n\n### Task", "fingerprint": null, "seed": "void sumofpzem()\n{\n    Serial.println(\"Sum of all 3 PZEM devices\");\n    sum_of_voltage        =   (voltage_usage_1 + voltage_usage_2 + voltage_usage_3);\n    sum_of_current        =   (current_usage_1 + current_usage_2 + current_usage_3);\n    sum_of_power          =   (active_power_1 + active_power_2 + active_power_3);\n    sum_of_active_energy  =   (active_energy_1 + active_energy_2 + active_energy_3); \n    sum_of_frequency      =   (frequency_1 + frequency_2 + frequency_3);\n    sum_of_power_factor   =   (power_factor_1 + power_factor_2 + power_factor_3); \n    \n    Serial.print(\"SUM of VOLTAGE:           \");   Serial.println(sum_of_voltage);             // V\n    Serial.print(\"SUM of CURRENT_USAGE:     \");   Serial.println(sum_of_current, 3);          // A\n    Serial.print(\"SUM of ACTIVE_POWER:      \");   Serial.println(sum_of_power);               // W\n    Serial.print(\"SUM of ACTIVE_ENERGY:     \");   Serial.println(sum_of_active_energy, 3);    // kWh\n    Serial.print(\"SUM of FREQUENCY:         \");   Serial.println(sum_of_frequency);           // Hz\n    Serial.print(\"SUM of POWER_FACTOR:      \");   Serial.println(sum_of_power_factor);\n    Serial.println(\"====================================================\");\n      \n    low_voltage_check();\n    high_voltage_check();\n}", "id": 112, "concepts": ["sum of voltage", "current", "power", "energy", "frequency", "power factor", "error handling for invalid data"], "instruction": "Implement a C++ function `power_factor(voltage, current, power, energy, frequency)` that calculates the power factor of a given electrical load. The function takes the following parameters:\n\n- `voltage`: the RMS voltage of the load in volts\n- `current`: the RMS current of the load in amperes\n- `power`: the average power of the load in watts\n- `energy`: the total energy consumed by the load in kilowatt-hours\n- `frequency`: the frequency of the AC voltage in hertz\n\nThe function should return the power factor as a floating-point number between -1 and 1.\n\nThe function should handle invalid input data gracefully and raise an exception if any of the parameters are invalid."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: modulus operation, hash map for counting, string processing, polynomial hash\n\n### Task", "fingerprint": null, "seed": "int main()\r\n{\r\n    int totcas;\r\n    scanf(\"%d\",&totcas);\r\n    while (totcas--)\r\n    {\r\n        gets(s);\r\n        gets(s);\r\n        scanf(\"%d%d%d\",&b,&p,&n);\r\n        res = 0;\r\n        if (b == 0)\r\n        {\r\n            for (int i = 0; s[i] != 0; i++)\r\n                if (s[i]%p == n)\r\n                    res += i+1;\r\n            printf(\"%d\\n\",res);\r\n        }\r\n        else\r\n        {\r\n            long long a = 0,bi = 1,tt,ta;\r\n            mp.clear();\r\n            mp[0] = 1;\r\n            for (int i = 0; s[i] != 0; i++)\r\n            {\r\n                long long inv=getInv(bi);\r\n                a = (a*b+s[i])%p;\r\n                tt = (n-a+p)*inv%p;\r\n                res += mp[tt];\r\n\r\n                //printf(\"%d %d\\n\",i,mp[tt]);\r\n                ta = a*inv%p;\r\n                mp[ta]++;\r\n                bi = bi*b%p;\r\n            }\r\n            printf(\"%d\\n\",res);\r\n        }\r\n    }\r\n    return 0;\r\n}", "id": 113, "concepts": ["modulus operation", "hash map for counting", "string processing", "polynomial hash"], "instruction": "Implement a C++ class `StringProcessor` with the following methods:\n- `add_string(s)`: adds a string `s` to an internal data structure.\n- `remove_string(s)`: removes a string `s` from the internal data structure.\n- `get_count(s)`: returns the number of times the string `s` has been added to the internal data structure.\n- `get_min_count()`: returns the minimum count across all strings in the internal data structure.\n- `get_max_count()`: returns the maximum count across all strings in the internal data structure.\n- `get_strings_by_count(c)`: returns a list of strings in the internal data structure that have a count of `c`.\n- `get_polynomial_hash(s)`: returns the polynomial hash of a string `s`.\n\nThe internal data structure should be optimized for fast lookups, inserts, and deletes."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: hard\nconcepts: C++ object initialization, function argument passing, passing references\n\n### Task", "fingerprint": null, "seed": "void DiscreteMasterProperty__float___ObjInit_2(DiscreteMasterProperty__float* __this, ::app::Uno::UX::Property__float* property, ::app::Fuse::Animations::MixerBase* mixerBase)\n{\n    ::app::Fuse::Animations::MasterProperty__float___ObjInit_1(__this, property, mixerBase);\n}", "id": 114, "concepts": ["C++ object initialization", "function argument passing", "passing references"], "instruction": "Implement a C++ function to initialize an object of the class `Foo` with a string argument `s`. The function should take a reference to an object of the class `Foo` and modify its internal data to be equal to `s`. The function signature should be `void init_foo(Foo &foo, const std::string &s)`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: hard\nconcepts: 2-dimensional array indexing, exact solution calculation for partial differential equation\n\n### Task", "fingerprint": null, "seed": "void Exact_Solution(float *u, int Nx) \n{ \n\t// put the exact solution \n   \tint i, j; \n   \tfloat x, y, h; \n   \th = 1.0/(Nx+1); \n   \tfor(i=0;i<Nx;++i) \n   \t{ \n      \t\tx = (i + 1)*h; \n      \t\tfor(j=0;j<Nx;++j) \n      \t\t{ \n         \t\t//k = j + i*(N-1); \n         \t\ty = (j + 1)*h; \n         \t\tu[Nx*i+j] = sin(M_PI*x)*sin(2*M_PI*y); \n      \t\t} \n   \t} \n}", "id": 115, "concepts": ["2-dimensional array indexing", "exact solution calculation for partial differential equation"], "instruction": "Implement a C++ program that solves the 2-dimensional heat equation:\n\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\left( \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} \\right)\n$$\n\nwhere $u(x, y, t)$ is the temperature at point $(x, y)$ at time $t$, and $\\alpha$ is a constant. The initial condition is given by $u(x, y, 0) = f(x, y)$. The boundary conditions are $u(0, y, t) = u(L, y, t) = u(x, 0, t) = u(x, M, t) = 0$, where $L$ and $M$ are the lengths of the square domain.\n\nUse the finite difference method to discretize the PDE into a system of linear equations and solve for the temperature at each point on the grid using Gaussian elimination."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: medium\nconcepts: modbus protocol, crc calculation, serial communication, address change in modbus\n\n### Task", "fingerprint": null, "seed": "void changeAddress(uint8_t OldslaveAddr, uint8_t NewslaveAddr)                    // Function to change/assign pzem address\n{\n  static uint8_t SlaveParameter = 0x06;\n  static uint16_t registerAddress = 0x0002;                                       // Register address to be changed\n  uint16_t u16CRC = 0xFFFF;\n  u16CRC = crc16_update(u16CRC, OldslaveAddr);\n  u16CRC = crc16_update(u16CRC, SlaveParameter);\n  u16CRC = crc16_update(u16CRC, highByte(registerAddress));\n  u16CRC = crc16_update(u16CRC, lowByte(registerAddress));\n  u16CRC = crc16_update(u16CRC, highByte(NewslaveAddr));\n  u16CRC = crc16_update(u16CRC, lowByte(NewslaveAddr));\n  Serial.println(\"Changing Slave Address\");\n  pzemSerial.write(OldslaveAddr);\n  pzemSerial.write(SlaveParameter);\n  pzemSerial.write(highByte(registerAddress));\n  pzemSerial.write(lowByte(registerAddress));\n  pzemSerial.write(highByte(NewslaveAddr));\n  pzemSerial.write(lowByte(NewslaveAddr));\n  pzemSerial.write(lowByte(u16CRC));\n  pzemSerial.write(highByte(u16CRC));\n  Serial.println(\"Changing Slave Address is done\"); \n  delay(1000);\n}", "id": 116, "concepts": ["modbus protocol", "crc calculation", "serial communication", "address change in modbus"], "instruction": "Create a C++ program that performs the following tasks:\n1. Connects to a modbus device via serial communication\n2. Reads the current device ID using a modbus read command\n3. Calculates the crc value for the read command\n4. Sends the read command with crc to the modbus device\n5. Receives the response from the modbus device\n6. Parses the response and extracts the device ID\n7. Calculates the crc value for the response\n8. Compares the calculated crc with the received crc to verify the integrity of the response\n9. If the crc values match, prints the device ID. Otherwise, prints an error message\n10. Repeats steps 2-9 for a predefined number of iterations, or until the user stops the program"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: hard\nconcepts: nested switch statement for product management, dynamic dispatch for polymorphic behavior, early exit for error handling\n\n### Task", "fingerprint": null, "seed": "void handleUI(ProductManager& manager) {\n    int cmd;\n    std::cout << \"Add Product(1) / View All Products(2) / Exit(3) ? \";\n    std::cin >> cmd;\n\n    switch (cmd) {\n    case ADD_PRODUCT:\n        std::cout << \"Book(1) / MusicCD(2) / ConversationBook(3) ? \";\n        std::cin >> cmd;\n\n        switch (cmd) {\n        case BOOK:\n            manager.addProduct(reinterpret_cast<Product*>(new Book));\n            break;\n\n        case MUSICCD:\n            manager.addProduct(reinterpret_cast<Product*>(new CompactDisc));\n            break;\n\n        case CONVERSATIONBOOK:\n            manager.addProduct(\n                reinterpret_cast<Product*>(new ConversationBook));\n            break;\n\n        default:\n            std::cout << \"Wrong Input..\\n\";\n            exit(0);\n        }\n\n        break;\n\n    case VIEW_ALL_PRODUCTS:\n        manager.show();\n        break;\n\n    case EXIT:\n        exit(0);\n        break;\n\n    default:\n        std::cout << \"Wrong Input..\\n\";\n        exit(0);\n    }\n}", "id": 117, "concepts": ["nested switch statement for product management", "dynamic dispatch for polymorphic behavior", "early exit for error handling"], "instruction": "Implement a C++ function `handle_product` that takes in a `product_id` and some additional `attributes` for a product, and performs different actions depending on the product's category. The function should handle three different categories: \"electronics\", \"clothing\", and \"books\". Each category has a different set of attributes, and each attribute has a different handling logic.\n\n- For the \"electronics\" category, the function should handle the following attributes: \"brand\", \"model\", \"color\", \"storage\", \"ram\", \"display\", \"operating_system\".\n- For the \"clothing\" category, the function should handle the following attributes: \"brand\", \"color\", \"size\", \"material\", \"style\".\n- For the \"books\" category, the function should handle the following attributes: \"author\", \"title\", \"isbn\", \"pages\", \"publisher\", \"release_date\".\n\nEach attribute has a different handling logic, so the function should be designed to handle these attributes appropriately. For example, the \"brand\" attribute for the \"electronics\" category should be handled differently than the \"brand\" attribute for the \"clothing\" category.\n\nHere's an example of how this function might be implemented:\n\n```cpp\nvoid handle_product(int product_id, std::string category, std::map<std::string, std::string> attributes)\n{\n    switch (category)\n    {\n        case \"electronics\":\n            handle_electronic_product(product_id, attributes);\n            break;\n        case \"clothing\":\n            handle_clothing_product(product_id, attributes);\n            break;\n        case \"books\":\n            handle_book_product(product_id, attributes);\n            break;\n        default:\n            throw std::invalid_argument(\"Invalid category\");\n    }\n}\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: conditional control of relay and buzzer, mute option for buzzer, sending status after occupancy\n\n### Task", "fingerprint": null, "seed": "void occupy_room() {\n  if (!NORELAY)\n        digitalWrite(relay, HIGH); // active high\n    occupied = true; \n    if (!mute_buzzer)\n        T.pulse (buzzer, 200, HIGH); // active low  // 100\n    // the end state is HIGH, i.e, buzzer is off *\n    send_status(); \n}", "id": 118, "concepts": ["conditional control of relay and buzzer", "mute option for buzzer", "sending status after occupancy"], "instruction": "Implement a C++ function that activates a relay and buzzer based on the input status. If the status is 'occupied', the relay should be turned on (1) and the buzzer should be turned off (0). If the status is 'vacant', the relay should be turned off (0) and the buzzer should be turned on (1). If the status is 'unknown', the relay should be turned off (0) and the buzzer should be muted (0). The function should return the resulting relay and buzzer status in the format of (relay, buzzer)."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: tensor indexing and slicing, padding handling, edge cases management, rounding operations\n\n### Task", "fingerprint": null, "seed": "void avg_pool(const T* arg,\n              T* out,\n              const Shape& arg_shape,\n              const Shape& out_shape,\n              const Shape& window_shape,\n              const Strides& window_movement_strides,\n              const Shape& padding_below,\n              const Shape& padding_above,\n              bool include_padding_in_avg_computation) {\n    NGRAPH_SUPPRESS_DEPRECATED_START\n    auto old_mode = std::fegetround();\n    std::fesetround(FE_TONEAREST);\n    // At the outermost level we will walk over every output coordinate O.\n    CoordinateTransform output_transform(out_shape);\n\n    for (const Coordinate& out_coord : output_transform) {\n        // Our output coordinate O will have the form:\n        //\n        //   (N,chan,i_1,...,i_n)\n\n        size_t batch_index = out_coord[0];\n        size_t channel = out_coord[1];\n\n        // For the input data we need to iterate the coordinate:\n        //\n        //   I:\n        //\n        // over the range (noninclusive on the right):\n        //\n        //   (N,chan,s_1*i_1,s_2*i_2,...,s_n*i_n) ->\n        //\n        //     (N+1,chan+1,s_1*i_1 + window_shape_1,...,s_n*i_n + window_shape_n)\n        //\n        // with unit stride.\n        //\n        // We iterate this over the *padded* data, so below we will need to check for\n        // coordinates that fall in the padding area.\n\n        size_t n_spatial_dimensions = arg_shape.size() - 2;\n\n        Coordinate input_batch_transform_start(2 + n_spatial_dimensions);\n        Coordinate input_batch_transform_end(2 + n_spatial_dimensions);\n        Strides input_batch_transform_source_strides(2 + n_spatial_dimensions, 1);\n        AxisVector input_batch_transform_source_axis_order(2 + n_spatial_dimensions);\n        CoordinateDiff input_batch_transform_padding_below(2 + n_spatial_dimensions);\n        CoordinateDiff input_batch_transform_padding_above(2 + n_spatial_dimensions);\n\n        input_batch_transform_start[0] = batch_index;\n        input_batch_transform_end[0] = batch_index + 1;\n        input_batch_transform_start[1] = channel;\n        input_batch_transform_end[1] = channel + 1;\n        input_batch_transform_padding_below[0] = 0;\n        input_batch_transform_padding_below[1] = 0;\n        input_batch_transform_padding_above[0] = 0;\n        input_batch_transform_padding_above[1] = 0;\n\n        for (size_t i = 2; i < n_spatial_dimensions + 2; i++) {\n            size_t window_shape_this_dim = window_shape[i - 2];\n            size_t movement_stride = window_movement_strides[i - 2];\n\n            input_batch_transform_start[i] = movement_stride * out_coord[i];\n            input_batch_transform_end[i] = input_batch_transform_start[i] + window_shape_this_dim;\n            input_batch_transform_padding_below[i] = padding_below[i - 2];\n            input_batch_transform_padding_above[i] = padding_above[i - 2];\n            // If a window (kernel) is out of arg shape bounds, trim it to fit\n            auto padded_upper_bound = arg_shape[i] + padding_below[i - 2] + padding_above[i - 2];\n            if (input_batch_transform_end[i] > padded_upper_bound) {\n                input_batch_transform_end[i] = padded_upper_bound;\n            }\n        }\n\n        for (size_t i = 0; i < arg_shape.size(); i++) {\n            input_batch_transform_source_axis_order[i] = i;\n        }\n\n        CoordinateTransform input_batch_transform(arg_shape,\n                                                  input_batch_transform_start,\n                                                  input_batch_transform_end,\n                                                  input_batch_transform_source_strides,\n                                                  input_batch_transform_source_axis_order,\n                                                  input_batch_transform_padding_below,\n                                                  input_batch_transform_padding_above);\n\n        // As we go, we compute the sum value:\n        //\n        //   output[O] := output[O] + arg[I]\n        //\n        // and the number of elements:\n        //\n        //   n_elements := n_elements + 1\n\n        T result = 0;\n        size_t n_elements = 0;\n\n        // The below conditions are to provide conformance between the ref and plugins:\n        // If exclude_padding is disabled (include_padding... enabled), then:\n        // The size of window doesn't change even if the window was clipped to fit the\n        // input, number of elements will be equal to window_size.width *\n        // window_size.height. The exception from this rule is if padding is not\n        // present, then window size is calculated each time.\n\n        auto padding_present =\n            padding_below[0] != 0 || padding_below[1] != 0 || padding_above[0] != 0 || padding_above[1] != 0;\n\n        if (include_padding_in_avg_computation && padding_present) {\n            n_elements = shape_size(window_shape);\n        }\n        for (const Coordinate& input_batch_coord : input_batch_transform) {\n            bool in_bounds = input_batch_transform.has_source_coordinate(input_batch_coord);\n\n            if (in_bounds || include_padding_in_avg_computation) {\n                T v = in_bounds ? arg[input_batch_transform.index(input_batch_coord)] : static_cast<T>(0);\n                result += v;\n                if (!padding_present || (in_bounds && !include_padding_in_avg_computation)) {\n                    n_elements++;\n                }\n            }\n        }\n\n        if (n_elements != 0) {\n            if (std::is_same<T, int8_t>::value || std::is_same<T, uint8_t>::value) {\n                out[output_transform.index(out_coord)] =\n                    static_cast<T>(std::nearbyint(static_cast<float>(result) / n_elements));\n            } else {\n                out[output_transform.index(out_coord)] = result / static_cast<T>(n_elements);\n            }\n        } else {\n            out[output_transform.index(out_coord)] = T{0};\n        }\n\n        std::fesetround(old_mode);\n    }\n    NGRAPH_SUPPRESS_DEPRECATED_END\n}", "id": 119, "concepts": ["tensor indexing and slicing", "padding handling", "edge cases management", "rounding operations"], "instruction": "Implement a C++ class `Tensor` for multi-dimensional array with indexing and slicing operations. The class should handle various shapes, including scalars, vectors, matrices, and higher-dimensional tensors. You must provide the following methods:\n\n- `__init__`: initializes the tensor with a given shape and initializes each element with a given value.\n- `__getitem__`: returns the element at a given index or a slice of elements.\n- `__setitem__`: sets the element at a given index or a slice of elements.\n- `shape`: returns the shape of the tensor as a tuple of integers.\n- `reshape`: reshapes the tensor into a new shape.\n- `to_list`: converts the tensor to a nested list representation.\n\nFor example, the following code snippet demonstrates how to use the `Tensor` class:\n\n```cpp\nTensor t(shape=(2, 3), value=0);\nt[0, 1] = 5;\nt[1, 2] = 10;\nassert t.shape() == (2, 3);\nassert t.to_list() == [[0, 5, 0], [0, 0, 10]];\nt.reshape(shape=(3, 2));\nassert t.shape() == (3, 2);\nassert t.to_list() == [[0, 5], [0, 0], [0, 10]];\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: hard\nconcepts: unit testing, matrix allocation and initialization, CUDA error handling, memory management\n\n### Task", "fingerprint": null, "seed": "int main() {\n    assert(test(1024) == 0);\n\n    std::vector<int> test_sizes = {{ 64, 128, 256, 512, 1024, 2048, 4096 }};\n\n    for (auto size: test_sizes) {\n        std::vector<double> A(size * size, 0.0);\n\n        A[0] =  2.0;\n        A[1] = -1.0;\n        for (size_t i = 1; i < size - 1; ++i) {\n            A[i * size + i - 1] = -1.0;\n            A[i * size + i    ] =  2.0;\n            A[i * size + i + 1] = -1.0;\n        }\n        A[size * size - 2] = -1.0;\n        A[size * size - 1] =  2.0;\n\n        double *d_A;\n        cudaError_t cudaErr;\n        cudaErr = cudaMalloc(&d_A, A.size() * sizeof(double));\n        assert(cudaErr == cudaSuccess);\n\n        cudaErr = cudaMemcpy(d_A, A.data(), A.size() * sizeof(double), cudaMemcpyHostToDevice);\n        assert(cudaErr == cudaSuccess);\n\n        int    *d_row, *d_col;\n        double *d_val;\n        full_to_csr(size, size, d_A, size, &d_row, &d_col, &d_val);\n\n        cudaFree(d_A);\n        cudaFree(d_row);\n        cudaFree(d_col);\n        cudaFree(d_val);\n    }\n\n    return 0;\n}", "id": 120, "concepts": ["unit testing", "matrix allocation and initialization", "CUDA error handling", "memory management"], "instruction": "Implement a C++ class with a method `matrix_multiplication(A, B)` that performs matrix multiplication between two matrices A and B. This method should handle any matrix dimensions and return the resultant matrix. Additionally, ensure efficient memory management and CUDA error handling.\n\nUnit test the matrix multiplication method with different matrix sizes and random inputs to verify correctness and performance."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: dynamic programming, edit distance calculation, minimum edit operations\n\n### Task", "fingerprint": null, "seed": "int editDistance(string s1,string s2,int m,int n)\n{\n         \n   int dp[m+1][n+1];\n   memset(dp,0,sizeof dp);\n   for(int i=0;i<=m;i++)\n   {\n       for(int j=0;j<=n;j++)\n       {\n           if(i==0)\n           dp[i][j]=j;\n           else if(j==0)\n           dp[i][j]=i;\n           else if(s1[i-1]==s2[j-1])\n           {\n                 dp[i][j]=dp[i-1][j-1];\n           }\n              \n           else{\n               dp[i][j]=1+min(min(dp[i][j-1],dp[i-1][j]),dp[i-1][j-1]);\n           }\n       }\n   }\n   \n   for(int i=0;i<=m;i++)\n   {\n       for(int j=0;j<=n;j++)\n       {  \n           cout<<dp[i][j]<<\" \";\n       }\n       cout<<endl;\n   }\n   \n   \n   return dp[m][n];\n    \n   \n}", "id": 121, "concepts": ["dynamic programming", "edit distance calculation", "minimum edit operations"], "instruction": "Implement a C++ function `min_edit_distance(s1, s2)` that calculates the minimum number of operations required to convert `s1` into `s2` using only insertion, deletion, and substitution operations. Utilize dynamic programming to efficiently compute the edit distance between two strings.\n\nFor example, given `s1 = \"kitten\"` and `s2 = \"sitting\"`, the minimum edit distance is 3, consisting of the following operations:\n\n- substitute 'k' with 's'\n- substitute 'e' with 'i'\n- insert 'g' at the end\n\nThe function should satisfy the following assertions:\n\n```cpp\nassert min_edit_distance(\"kitten\", \"sitting\") == 3\nassert min_edit_distance(\"\", \"\") == 0\nassert min_edit_distance(\"cat\", \"dog\") == 3\nassert min_edit_distance(\"foobar\", \"barfoo\") == 3\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: function definition, function signature, variable declaration, control flow\n\n### Task", "fingerprint": null, "seed": "void defineFunction(MincBlockExpr* scope, const char* name, PawsType* returnType, std::vector<PawsType*> argTypes, std::vector<std::string> argNames, MincBlockExpr* body)\n{\n\tPawsFunc* pawsFunc = new PawsRegularFunc(name, returnType, argTypes, argNames, body);\n\tscope->defineSymbol(name, PawsFunctionType::get(pawsSubroutineScope, returnType, argTypes), new PawsFunction(pawsFunc));\n}", "id": 122, "concepts": ["function definition", "function signature", "variable declaration", "control flow"], "instruction": "Implement the C++ function `find_min` to find the minimum value in a given array of integers. The function should satisfy the following assertions:\n\n```cpp\nassert find_min([1, 2, 3, 4, 5]) == 1\nassert find_min([5, 4, 3, 2, 1]) == 1\nassert find_min([1]) == 1\nassert find_min([]) == null\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: hard\nconcepts: bit manipulation for USB device status checks, type casting for struct field access, function pointer calls\n\n### Task", "fingerprint": null, "seed": "uint8_t CDC_Transmit_FS(uint8_t* Buf, uint16_t Len)\r\n{\r\n    uint8_t result = USBD_OK;\r\n    /* USER CODE BEGIN 7 */\r\n    USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef*) hUsbDeviceFS.pClassData;\r\n    if (hcdc->TxState != 0)\r\n    {\r\n        return USBD_BUSY;\r\n    }\r\n    USBD_CDC_SetTxBuffer(&hUsbDeviceFS, Buf, Len);\r\n    result = USBD_CDC_TransmitPacket(&hUsbDeviceFS);\r\n    /* USER CODE END 7 */\r\n    return result;\r\n}", "id": 123, "concepts": ["bit manipulation for USB device status checks", "type casting for struct field access", "function pointer calls"], "instruction": "Implement a C++ class `UsbDevice` that represents a USB device connected to a computer. The class should contain the following information about the device:\n\n- Device ID (integer)\n- Device name (string)\n- Device status (integer)\n\nThe class must provide the following methods:\n\n- `is_connected`: checks if the device is currently connected to the computer\n- `is_busy`: checks if the device is currently busy performing a task\n- `get_status_string`: returns a string representation of the device status\n\nThe device status is represented by an integer that can have multiple values combined together. Each value represents a specific status, such as connected, busy, or error. You can use bit manipulation to check these statuses."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: hard\nconcepts: IOCTLHOOK_Activity IOCTL call, _AS_Unload activity, InstallerProtection AppID\n\n### Task", "fingerprint": null, "seed": "void\r\nOLD_ClientUnregister (\r\n\tHANDLE hDevice\r\n\t)\r\n{\r\n\tHDSTATE Activity;\r\n\r\n\tActivity.Activity = _AS_Unload;\r\n\tActivity.AppID = InstallerProtection;\r\n\r\n\tDWORD dwRet;\r\n\r\n\tDeviceIoControl (\r\n\t\thDevice,\r\n\t\tIOCTLHOOK_Activity,\r\n\t\t&Activity,\r\n\t\tsizeof(Activity),\r\n\t\t&Activity,\r\n\t\tsizeof(Activity),\r\n\t\t&dwRet,\r\n\t\tNULL\r\n\t\t);\r\n}", "id": 124, "concepts": ["IOCTLHOOK_Activity IOCTL call", "_AS_Unload activity", "InstallerProtection AppID"], "instruction": "Implement a program that detects malicious activity based on IOCTLHOOK_Activity IOCTL calls from the _AS_Unload activity of the InstallerProtection AppID, which is used to detect and prevent unauthorized software installation. The program should identify and report any malicious IOCTLHOOK_Activity calls that do not match the expected behavior of the InstallerProtection AppID.\n\nThe program should:\n1. Identify the AppID and activity from the IOCTLHOOK_Activity call.\n2. Check the AppID and activity against the expected values for InstallerProtection.\n3. If the AppID or activity do not match the expected values, report the malicious activity.\n\nHere is the expected behavior of the InstallerProtection AppID:\n\n```\nAppID: InstallerProtection\nActivity: _AS_Unload\nExpected IOCTLHOOK_Activity call:\n\nAppID: InstallerProtection\nActivity: _AS_Unload\nExpected IOCTLHOOK_Activity call:\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: string conversion to integer, handling null characters, potential buffer overflow\n\n### Task", "fingerprint": null, "seed": "int\ngetBufferInt(cstring charBuffer)\n{\n    return atoi(charBuffer);\n}", "id": 125, "concepts": ["string conversion to integer", "handling null characters", "potential buffer overflow"], "instruction": "Implement a C++ function `my_atoi(str)` to convert a string to an integer. This function should handle null characters and avoid potential buffer overflow. The input string can be in decimal, binary, or hexadecimal format.\n\nThis function should be implemented without using any built-in functions or methods."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: hard\nconcepts: function call convention, macro expansion, string interpolation\n\n### Task", "fingerprint": null, "seed": "void _stdcall SubCureTrace(tag_TRACE_LEVEL dTraceLevel,char* chMask)\r\n{\r\n\t//INT3;\r\n\tPR_TRACE((g_root,dTraceLevel,chMask));\r\n\treturn;\r\n}", "id": 126, "concepts": ["function call convention", "macro expansion", "string interpolation"], "instruction": "Implement a C++ class to encode and decode a string using the following encoding scheme: replace each character with the character's ASCII value, separated by a comma and a space (for example, \"Hello\" becomes \"72,101,108,108,111\"). The class should provide two methods: `encode` and `decode`. The `encode` method should take a string and return the encoded string, while the `decode` method should take an encoded string and return the original string."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: sensor data processing, data averaging, root mean square calculation, error handling\n\n### Task", "fingerprint": null, "seed": "void measureAndCalculateRMS() {\n  double sum = 0, sum2 = 0;\n\n  int delayBetweenMeasures = 1;\n  int measureCount = 2000;\n  \n  for(int i = 0; i < measureCount; i++) {\n    //sensor 1\n    double rawValue = analogRead(SENSOR_INPUT_FRONT) - 500;      //sensor nr.: 515\n    sum += rawValue * rawValue;\n\n    //sensor 2\n    double rawValue2 = analogRead(SENSOR_INPUT_BACK) - 500;   //sensor nr.: 510.5\n    sum2 += rawValue2 * rawValue2;\n\n    delay(delayBetweenMeasures);\n  }\n  \n  rmsFrontSensor = rootMeanSquare(sum, measureCount);\n  rmsBackSensor = rootMeanSquare(sum2, measureCount);\n}", "id": 127, "concepts": ["sensor data processing", "data averaging", "root mean square calculation", "error handling"], "instruction": "Develop a C++ function that processes sensor data and returns the root mean square of the average of the data. The function should take a list of sensor values and perform the following steps:\n\n1. Validate the input data by checking if it is a list of numbers. If it is not, raise a ValueError.\n2. Calculate the average of the data by summing the values and dividing them by the length of the list.\n3. Calculate the root mean square of the average by squaring the average, taking the square root of the result, and returning it.\n\nFor example, given the data `[1, 2, 3, 4, 5]`, the function should return 3.0."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: medium\nconcepts: C++ map data structure, function parameter handling, input parsing\n\n### Task", "fingerprint": null, "seed": "void calc_set_var(const char *s, int val)\n{\n\tcalc_var_map[s] = val;\n\n\tstd::cout << val << std::endl;\n}", "id": 128, "concepts": ["C++ map data structure", "function parameter handling", "input parsing"], "instruction": "Implement a C++ program that takes a list of strings representing key-value pairs and builds a map data structure in memory. Each string in the input list has the format \"key=value\". The program should parse each string and insert the key and value into the map. The program should handle duplicate keys and update the corresponding value in the map.\n\nFor example, given the input list `[\"name=John\", \"age=30\", \"name=Jane\", \"age=40\"]`, the program should build a map with the keys \"name\" and \"age\" and the corresponding values \"John\" and \"30\" for the first pair, and \"Jane\" and \"40\" for the last pair.\n\nThe program should support the following operations:\n\n- `get(key)`: returns the value associated with the given key in the map, or null if the key is not present.\n- `set(key, value)`: inserts or updates the value associated with the given key in the map.\n- `remove(key)`: removes the entry associated with the given key from the map.\n- `keys()`: returns a list of all keys in the map."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: string comparison, character comparison, loop termination condition\n\n### Task", "fingerprint": null, "seed": "int compare(char* string1, char* string2) \n{\n    int i = 0;\n    while(string1[i] != '\\0' && string2[i] != '\\0') {\n        if(string1[i] != string2[i]) {\n            if(string1[i] < string2[i]) {\n                return 1;\n            } else {\n                return -1;\n            }\n        }\n        i++;\n    }\n    return 0; //0 for equal\n}", "id": 129, "concepts": ["string comparison", "character comparison", "loop termination condition"], "instruction": "Implement a C++ function `compare_char` that compares two characters `ch1` and `ch2` based on their ASCII values. The function should return -1 if `ch1` is less than `ch2`, 0 if they are equal, and 1 if `ch1` is greater than `ch2`. You can use the `ord` function to obtain the ASCII value of a character. Write assertions to ensure that the function works correctly."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: function declaration and definition, modular code for maintainability\n\n### Task", "fingerprint": null, "seed": "void get_pzem_data()                                          // Function to check time to see if it reached mentioned time to fetch PZEM data\n{\n    pzemdevice1(); \n    pzemdevice2();\n    pzemdevice3();\n    sumofpzem();\n}", "id": 130, "concepts": ["function declaration and definition", "modular code for maintainability"], "instruction": "Implement a C++ class `LinkedList` that represents a singly linked list data structure. The class should include the following functions:\n\n- `insert_at_head(value)`: insert a new node with the given value at the head of the linked list.\n- `remove_at_head()`: remove the head node from the linked list and return its value.\n- `insert_at_tail(value)`: insert a new node with the given value at the tail of the linked list.\n- `remove_at_tail()`: remove the tail node from the linked list and return its value.\n- `get_size()`: return the size of the linked list.\n- `is_empty()`: return a boolean indicating whether the linked list is empty.\n- `print_list()`: print the contents of the linked list in a readable format."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: graph data structure, breadth-first search, residual graph\n\n### Task", "fingerprint": null, "seed": "int findMaxFlow(adjmattype graph, int s, int t, adjmattype &fGraphvect, vector<int> parentorig)\r\n{\r\n    int u, v;\r\n\tif (-1 == s|| -1 == t)\r\n\t\treturn 0;\r\n    // Create a residual graph and fill the residual graph with\r\n    // given capacities in the original graph as residual capacities\r\n    // in residual graph\r\n   \tadjmattype  rGraph(graph.begin(),graph.end());\r\n\tint parent[V];  // This array is filled by BFS and to store path\r\n\tvector<int> path;\r\n    int max_flow = 0;  // There is no flow initially\r\n \r\n    // Augment the flow while tere is path from source to sink\r\n    while (bfs(rGraph, s, t, parent, path))\r\n    {\r\n        // Find minimum residual capacity of the edges along the\r\n        // path filled by BFS. Or we can say find the maximum flow\r\n        // through the path found.\r\n        int path_flow = INT_MAX;\r\n \r\n        for (v=t; v!=s; v=parent[v])\r\n        {\r\n            u = parent[v];\r\n            path_flow = min(path_flow, rGraph[u][v]);\r\n        }\r\n \r\n        // update residual capacities of the edges and reverse edges\r\n        // along the path\r\n        for (v=t; v != s; v=parent[v])\r\n        {\r\n            u = parent[v];\r\n            rGraph[u][v] -= path_flow;\r\n            rGraph[v][u] += path_flow;\r\n        }\r\n \r\n        // Add path flow to overall flow\r\n        max_flow += path_flow;\r\n    }\r\n \r\n\t\r\n\t//Calculate the flows on each edge - subtracting residual from capacity, aka. residual capacity current flow on each edge\r\n\tfor( int i = 0; i < V; ++i)\r\n\t{\r\n\t\tfor( int j = 0; j < V; ++j )\r\n\t\t{\r\n\t\t\tfGraphvect[i][j] =  graph[i][j] - rGraph[i][j];\r\n\r\n\t\t}\r\n\r\n\t}\r\n    // Return the overall flow (max_flow is equal to maximum\r\n    // number of edge-disjoint paths)\r\n    return max_flow;\r\n}", "id": 131, "concepts": ["graph data structure", "breadth-first search", "residual graph"], "instruction": "Implement a C++ function to compute the maximum flow through a network of vertices and edges, using a breadth-first search algorithm. The function takes three arguments:\n\n- `graph`, a two-dimensional integer array representing the network of vertices and edges\n- `source`, the starting vertex in the graph\n- `sink`, the ending vertex in the graph\n\nThe function should return an integer representing the maximum flow through the network."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: file parsing, JSON parsing, string comparison, data type conversion\n\n### Task", "fingerprint": null, "seed": "void read_json_config()\r\n{\r\n\r\n\tstd::string json = get_file_contents(config_file.c_str());\r\n\trapidjson::Document d;\r\n\td.Parse<0>(json.c_str());\r\n\r\n\toutput_file = d[\"output_file\"].GetString();\r\n\tcrop_width = d[\"height\"].GetInt();\r\n\tcrop_height = d[\"width\"].GetInt();\r\n\tscale = d[\"scale\"].GetInt();\r\n\tseed = d[\"seed\"].GetInt();\r\n\trandom_offset = d[\"offset\"].GetInt();\r\n\toffset_dr = d[\"rough\"].GetDouble();\r\n\tnormalise = (strcmp(d[\"normalise\"].GetString(), \"true\") == 0);\r\n\tnormalise_min = d[\"normalise_min\"].GetInt();\r\n\tnormalise_max = d[\"normalise_max\"].GetInt();\r\n\tsea_level = d[\"sea_level\"].GetInt();\r\n\tsand_level = d[\"sand_level\"].GetInt();\r\n\tsnow_level = d[\"snow_level\"].GetInt();\r\n\tcliff_difference = d[\"cliff_height_difference\"].GetInt();\r\n\tn_rivers = d[\"number_of_river_sources\"].GetInt();\r\n\tmax_branches = d[\"max_branches_per_source\"].GetInt();\r\n\tn_settlements = d[\"number_of_settlements\"].GetInt();\r\n\tmin_distance = d[\"min_distance_between_settlements\"].GetInt();\r\n\tn_vegetation = d[\"number_of_vegetation\"].GetInt();\r\n\troot_radius = d[\"vegetation_root_radius\"].GetInt();\r\n\tgenerations = d[\"vegetation_generations\"].GetInt();\r\n\r\n}", "id": 132, "concepts": ["file parsing", "JSON parsing", "string comparison", "data type conversion"], "instruction": "Given a file with the following contents:\n\n```json\n[\n  {\n    \"name\": \"Alice\",\n    \"age\": 20\n  },\n  {\n    \"name\": \"Bob\",\n    \"age\": 25\n  },\n  {\n    \"name\": \"Charlie\",\n    \"age\": 30\n  }\n]\n```\n\nWrite a C++ function to read the file and return the average age of all the people in the file."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: time complexity analysis, algorithm optimization, loop unrolling\n\n### Task", "fingerprint": null, "seed": "int main()\n{\n    ll t;\n    cin>>t;\n    while(t--)\n        solve();\n}", "id": 133, "concepts": ["time complexity analysis", "algorithm optimization", "loop unrolling"], "instruction": "Implement a C++ function `count_digit_frequency(num)` that counts the frequency of each digit in a positive integer `num`. Return a list of integers, where the first element represents the frequency of the digit 0, the second element represents the frequency of the digit 1, and so on. The function should run in linear time complexity, with no additional space.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert count_digit_frequency(12345) == [0, 1, 1, 1, 1, 1, 0, 0, 0, 0]\nassert count_digit_frequency(13579) == [0, 1, 0, 1, 0, 1, 0, 0, 0, 1]\nassert count_digit_frequency(11111) == [0, 5, 0, 0, 0, 0, 0, 0, 0, 0]\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: C++ headers inclusion, main function definition, code execution\n\n### Task", "fingerprint": null, "seed": "int main(){ \n    c_p_c();\n    int t; t = 1;\n    while(t--){\n        solve();\n    }\n}", "id": 134, "concepts": ["C++ headers inclusion", "main function definition", "code execution"], "instruction": "Implement a C++ class named `Test` with a method `test_function` that returns the string `'Hello World!'`. The class should be defined in a header file named `test.h`, and the `main` function should be defined in a separate `main.cpp` file. The `main` function should include the header file, create an instance of the `Test` class, and call the `test_function` method. Finally, the `main` function should print the returned string."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: hard\nconcepts: network communication, data reception, data processing, data validation, error handling\n\n### Task", "fingerprint": null, "seed": "void loop_FunkCheck()\n{\n  //===== Receiving =====//\n  network.update();\n\n  while (network.available()) // Is there any incoming data?\n  {\n    RF24NetworkHeader header(FunkMasterSwitchcabinet);\n    network.read(header, &dataIncoming, sizeof(dataIncoming)); // Read the incoming data\n\n    if ((header.from_node == FunkMasterSwitchcabinet) and (dataIncoming.header == 1))\n    {\n      //Serial.println(\"Switchcabinet hat was gefunkt\");\n\n      if ((dataIncoming.val1 != TargetTemperatureZone_1) and (NewTargetTempAvalible_Zone1 == false))\n      {\n        TargetTemperatureZone_1 = dataIncoming.val1;\n      }\n      if ((dataIncoming.val2 != TargetTemperatureZone_2) and (NewTargetTempAvalible_Zone2 == false))\n      {\n        TargetTemperatureZone_2 = dataIncoming.val2;\n      }\n      if (dataIncoming.val3 != RealTemperatureZone_1)\n      {\n        RealTemperatureZone_1 = dataIncoming.val3;\n      }\n      if (dataIncoming.val4 != RealTemperatureZone_2)\n      {\n        RealTemperatureZone_2 = dataIncoming.val4;\n      }\n    }\n  }\n}", "id": 135, "concepts": ["network communication", "data reception", "data processing", "data validation", "error handling"], "instruction": "Implement a C++ function that receives data from a network socket and processes it. The data is received in chunks, and each chunk may or may not be complete. The function should reassemble the data and ensure that it is valid before processing it.\n\nThe function should take the following parameters:\n- `socket`: a socket object representing the network connection\n- `buffer`: a bytearray object to store the received data\n- `chunk_size`: the size of each chunk to be received (default to 4096 bytes)\n- `delimiter`: the delimiter to indicate the end of a complete message (default to b'\\n')\n\nThe function should return a list of valid messages. If an error occurs during reception or processing, the function should raise an appropriate exception."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: function overloading, specialization, deleted functions, mutex class\n\n### Task", "fingerprint": null, "seed": "int main()\n{\n\t//// 1. \uc77c\ubc18 \ud568\uc218\uac00 \ud15c\ud50c\ub9bf \ud568\uc218\ubcf4\ub2e4 \uba3c\uc800 \ubd88\ub9ac\uae30 \ub54c\ubb38\uc5d0 void goo(double) = delete; \uac00 \uc788\uc73c\uba74 \uc774 \ubc11\uc5d0\uc11c \uc624\ub958\ub0a8\n\tgoo(3.4);\n\n\n\t//// 2. Mutex\ub294 \ubcf5\uc0ac \uc0dd\uc131\uc790\ub97c \uc0ac\uc6a9\ud560 \uc218 \uc5c6\uc74c. \n\tMutex m1;\n\tMutex m2 = m1; // \ubcf5\uc0ac \uc0dd\uc131\uc790.\n}", "id": 136, "concepts": ["function overloading", "specialization", "deleted functions", "mutex class"], "instruction": "Implement a function `lock` that can lock a mutex. The function should take a mutex as a parameter and lock it. If the mutex is already locked, the function should throw a `std::runtime_error` exception with the message \"Mutex is already locked\". Also, define a function `unlock` that takes a mutex as a parameter and unlocks it.\n\nHere's an example implementation:\n\n```cpp\nvoid lock(std::mutex& mutex) {\n    if (mutex.try_lock()) {\n        throw std::runtime_error(\"Mutex is already locked\");\n    }\n}\n\nvoid unlock(std::mutex& mutex) {\n    mutex.unlock();\n}\n```\n\nNote that the implementation of the `lock` function uses the `try_lock` method to attempt to lock the mutex. If the mutex is already locked, `try_lock` returns `false`, and the function throws an exception. On the other hand, the `unlock` function simply calls the `unlock` method of the mutex."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: file handling, string processing, data structures for storing and accessing data\n\n### Task", "fingerprint": null, "seed": "int main(int argc, char *argv[])\n{\n  //Initialize variables\n    ifstream inFile(argv[1]);\n    Park prk[100];\n    string parkData;\n    string parkName;\n    string parkState;\n    int arrayLength = 0;\n    int parkArea;\n    int minArea;\n\n\n\n\n    if (inFile.is_open())\n    while (!inFile.eof())\n    {\n      getline (inFile, parkData, ',');\n      parkName = parkData;\n      getline (inFile, parkData, ',');\n      parkState = parkData;\n      getline (inFile, parkData, '\\n');\n      stringstream convert(parkData);\n      convert >> parkArea;\n\n      addPark (prk, parkName, parkState, parkArea, arrayLength++);\n    }\n    printList (prk, arrayLength);\n    inFile.close();\n    ofstream outFile(argv[2]);\n\n    stringstream convert2(argv[3]);\n    convert2 >> minArea;\n    for (int j = 0; j < arrayLength; j++)\n    {\n      if (prk[j].area >= minArea)\n      {\n        outFile << prk[j].parkname << \",\" << prk[j].state << \",\" << prk[j].area << endl;\n      }\n    }\n    outFile.close();\n}", "id": 137, "concepts": ["file handling", "string processing", "data structures for storing and accessing data"], "instruction": "Implement a C++ function that parses a given text file and returns a dictionary with each word as a key and its number of occurrences as its value. The function should ignore case and punctuation, treating \"word\" and \"Word\" as the same word. The function should handle UTF-8 encoding with BOM.\n\nFor example, given the following file content:\n\n```\nHello, world!\nThis is a test file.\n```\n\nThe function should return a dictionary like this:\n\n```\n{\n    \"hello\": 1,\n    \"world\": 1,\n    \"this\": 1,\n    \"is\": 1,\n    \"a\": 1,\n    \"test\": 1,\n    \"file\": 1\n}\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: easy\nconcepts: problem solving with greedy algorithm, dynamic programming, constant space optimization\n\n### Task", "fingerprint": null, "seed": "int main ()\n{\n    int TT;\n    scanf(\"%d\", &TT);\n    for (int tt = 1; tt <= TT; tt++) {\n        int R, C, N;\n        scanf(\"%d %d %d\", &R, &C, &N);\n        ULL sol = get_min(R, C, N);\n        printf(\"Case #%d: %llu\\n\", tt, sol);\n    }\n    return 0;\n}", "id": 138, "concepts": ["problem solving with greedy algorithm", "dynamic programming", "constant space optimization"], "instruction": "Given an integer array `nums` and an integer `target`, find a subsequence of `nums` that sums to `target` and has the smallest size. If there are multiple solutions, return any of them. If there's no solution, return an empty list.\n\nFor example, given `nums = [1, 2, 3, 4, 5]` and `target = 9`, a solution is `[2, 3, 4]`.\n\nYour solution should be implemented as a C++ program, and it should satisfy the following assertions:\n\n```cpp\nassert find_min_subsequence([1, 2, 3, 4, 5], 9) == [2, 3, 4]\nassert find_min_subsequence([1, 2, 3, 4, 5], 8) == [1, 2, 5]\nassert find_min_subsequence([1, 2, 3, 4, 5], 7) == [1, 2, 4]\nassert find_min_subsequence([1, 2, 3, 4, 5], 6) == [1, 2, 3]\nassert find_min_subsequence([1, 2, 3, 4, 5], 5) == [1, 2, 3]\nassert find_min_subsequence([1, 2, 3, 4, 5], 4) == [1, 3]\nassert find_min_subsequence([1, 2, 3, 4, 5], 3) == [1, 2]\nassert find_min_subsequence([1, 2, 3, 4, 5], 2) == [1, 1]\nassert find_min_subsequence([1, 2, 3, 4, 5], 1) == [1]\nassert find_min_subsequence([1, 2, 3, 4, 5], 0) == []\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: pixel coordinate conversion, geospatial calculation, data type conversion\n\n### Task", "fingerprint": null, "seed": "int RolFromXCoord(double xCoord){\n    double xLeft = -374495.83635;\n    double cellSize = 270.0;\n    double result;\n    int retVal;\n    \n    result = (xCoord - xLeft)/cellSize;\n    retVal = result;\n    return retVal;\n}", "id": 139, "concepts": ["pixel coordinate conversion", "geospatial calculation", "data type conversion"], "instruction": "Implement a C++ function `pixel2coord(x, y, zoom)` that converts a pixel coordinate `(x, y)` at a given zoom level to a geospatial coordinate `(longitude, latitude)` using the Google Maps projection. The Google Maps projection divides the Earth into 256x256 pixel tiles at zoom level 0, where each successive zoom level doubles the number of tiles in each dimension. The function should use the `math` module for mathematical calculations."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: easy\nconcepts: unit conversion, variable naming, function naming\n\n### Task", "fingerprint": null, "seed": "double toPounds(int x){\ndouble numPounds = x * lbs;\nreturn numPounds;\n}", "id": 140, "concepts": ["unit conversion", "variable naming", "function naming"], "instruction": "Write a C++ program to convert a distance from centimeters to inches. The program should include at least two functions: `cm_to_in` to perform the conversion and `print_conversion` to print the result. The `cm_to_in` function should take a value in centimeters as an argument and return the equivalent value in inches. The `print_conversion` function should take the output from `cm_to_in` and print it in a human-readable format."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: file I/O redirection, factorial calculation, graph traversal, distance queries, permutation generation, dynamic programming\n\n### Task", "fingerprint": null, "seed": "int main()\n{\n\tfreopen(\"path.in\",\"r\",stdin);\n\tfreopen(\"path.ans\",\"w\",stdout);\n\tfac[0]=1;\n\tfor(int i=1;i<N;i++) fac[i]=1ll*fac[i-1]*i%mod;\n\tscanf(\"%d\",&Case);\n\tscanf(\"%d\",&n);\n\tfor(int i=1,u,v,w;i<n;i++) scanf(\"%d%d%d\",&u,&v,&w),add(u,v,w),add(v,u,w);\n\tscanf(\"%d\",&k);\n\tfor(int i=1;i<=k;i++) scanf(\"%d\",&A[i]),mark[A[i]]=1;\n\tdfs(1,0);\n\tprocess();\n\tfor(int i=1;i<=k;i++) f[i]=i;\n\tdo\n\t{\n\t\tint res=0;\n\t\tfor(int i=1;i<k;i++) res=mul(res+askdist(A[f[i]],A[f[i+1]]));\n\t\t//for(int i=1;i<k;i++) printf(\"%d \",askdist(A[f[i]],A[f[i+1]]));\n\t\t//for(int i=1;i<=k;i++) printf(\"%d \",A[f[i]]);\n\t\t//printf(\"%d\\n\",res);\n\t\tans=mul(ans+res);\n\t}while(std::next_permutation(f+1,f+1+k));\n\tprintf(\"%d\\n\",1ll*ans*Pow(fac[k],mod-2)%mod);\n}", "id": 141, "concepts": ["file I/O redirection", "factorial calculation", "graph traversal", "distance queries", "permutation generation", "dynamic programming"], "instruction": "Implement the C++ function `factorial(n)` that calculates the factorial of a non-negative integer `n`. The function should satisfy the following assertions:\n\n```cpp\nassert factorial(0) == 1\nassert factorial(1) == 1\nassert factorial(2) == 2\nassert factorial(3) == 6\nassert factorial(4) == 24\nassert factorial(5) == 120\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: memory management, object heap freeing, return handling\n\n### Task", "fingerprint": null, "seed": "void pfMemFree(hOBJECT hObj,void* Obj)\r\n{\r\n\tif (!Obj) return;\r\n\tCALL_SYS_ObjHeapFree(hObj,Obj);\r\n\treturn;\r\n}", "id": 142, "concepts": ["memory management", "object heap freeing", "return handling"], "instruction": "Given the following C++ class `MyObject`, write a function `free_my_object(MyObject* obj)` that frees the memory allocated for the object.\n\n```cpp\nclass MyObject {\npublic:\n    MyObject() {\n        data = new int[1000];\n    }\n    ~MyObject() {\n        delete[] data;\n    }\nprivate:\n    int* data;\n};\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: hard\nconcepts: dynamic programming for efficient calculation, avoiding redundant calculations\n\n### Task", "fingerprint": null, "seed": "void process()\n{\n\tfor(int j=1;j<20;j++)\n\t\tfor(int i=1;i<=n;i++) \n\t\tfa[i][j]=fa[fa[i][j-1]][j-1],val[i][j]=mul(val[i][j-1]+val[fa[i][j-1]][j-1]);\n}", "id": 143, "concepts": ["dynamic programming for efficient calculation", "avoiding redundant calculations"], "instruction": "Implement a C++ class with a method `get_nth_fibonacci_memoized(n)` that returns the nth Fibonacci number, where n is a positive integer. Utilize memoization to store previously calculated Fibonacci numbers in a dictionary within the class to avoid recalculating them for multiple method calls. Ensure the method efficiently updates and references this dictionary to find new Fibonacci numbers as needed. Additionally, enhance performance by avoiding redundant calculations."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: easy\nconcepts: bit manipulation for coin weight calculation, coin array update, value assignment based on condition\n\n### Task", "fingerprint": null, "seed": "void setCoin(int w)\r\n{\r\n\tint i, j;\r\n\tfor (i = 0; i < 2; i++)\r\n\t\tfor (j = 0; j < s[i].size(); j++)\r\n\t\t\tif (!ox[s[i][j] - 'A'])\r\n\t\t\t\tcoin[s[i][j] - 'A'] += w * ((i == 1) * 1 + (-1) * (i == 0));\r\n\treturn ;\r\n}", "id": 144, "concepts": ["bit manipulation for coin weight calculation", "coin array update", "value assignment based on condition"], "instruction": "Given a weighted coin array where the weight of each coin is represented by a bit in an integer, design a class that simulates the process of flipping a coin and updating its weight. The class should have two methods:\n\n- `flip_coin()`: Flip the coin, returning `True` if the coin lands on heads and `False` if it lands on tails.\n- `update_coin(result)`: Update the coin's weight based on the result of the flip. If the result is `True`, add 1 to the coin's weight; otherwise, subtract 1.\n\nHere's how you can implement this class in C++:\n\n```cpp\nclass WeightedCoin {\n  public:\n    WeightedCoin(int weight): weight(weight) {}\n    bool flip_coin() {\n        int random_num = rand() % (weight + 1);\n        return random_num == weight;\n    }\n    void update_coin(bool result) {\n        if (result) {\n            weight += 1;\n        } else {\n            weight -= 1;\n        }\n    }\n\n  private:\n    int weight;\n};\n```\n\nTo test this class, you can create a weighted coin with a given weight and simulate multiple flips:\n\n```cpp\nWeightedCoin coin(5);\nint num_heads = 0;\nint num_tails = 0;\nfor (int i = 0; i < 10; i++) {\n    if (coin.flip_coin()) {\n        num_heads++;\n    } else {\n        num_tails++;\n    }\n    coin.update_coin(coin.flip_coin());\n}\nassert num_heads > 0;\nassert num_tails > 0;\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: hard\nconcepts: insertion of nodes into a linked list, filtering specific characters, string interpolation\n\n### Task", "fingerprint": null, "seed": "void p4(Node *h){\n\tNode *p = h;\n\twhile(p){\n\t\tNode *pn = p->next;\n\t\tif(pn == NULL || (\n\t\t\tpn->c != ',' &&\n\t\t\tpn->c != ';' &&\n\t\t\tpn->c != ':' &&\n\t\t\tpn->c != '@' &&\n\t\t\tpn->c != '#' &&\n\t\t\tpn->c != '$' &&\n\t\t\tpn->c != '%' &&\n\t\t\tpn->c != '&')){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n//\t\tcout<<\"p4\"<<endl;\n\t\tNode *node;\n\t\tnode = new Node(' ');\n\t\tp = insert(p,node);\n\t\tnode = new Node(' ');\n\t\tpn = insert(pn,node);\n\t\tp = pn;\n\t}\n}", "id": 145, "concepts": ["insertion of nodes into a linked list", "filtering specific characters", "string interpolation"], "instruction": "Implement a C++ class to represent a simple linked list containing nodes that store strings. The class should provide methods to insert a new node at the end of the list or filter out nodes containing specific characters. Use a template for the value type to allow the use of different data types within a single linked list."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data processing with accelerometer, filtering and smoothing, serial communication, RMS calculation, state transitions\n\n### Task", "fingerprint": null, "seed": "void loop() {\n  if (millis() - t0 > 1000)\n  {\n    state++;\n    t0 = millis();\n  }\n  accel = getSimpleValue(X_ACCEL, Y_ACCEL, Z_ACCEL);\n//  Serial.print(\"Simple value: \");\n//  Serial.print(accel);\n  float accel_rms = getFilteredSignal(X_ACCEL, Y_ACCEL, Z_ACCEL);\n  Serial.print(accel_rms);\n  Serial.print(\",\");\n  accel_rms = filtered_value->step(accel_rms);\n//  Serial.print(\" - RMS value: \");\n  Serial.print(accel_rms);\n  Serial1.println(accel_rms);\n  Serial.print(\",\");\n  Serial.println(state);\n  // Serial.print(\"X: \");\n  // Serial.print(getSeparatedValues(X_ACCEL) - mean_x);\n  // Serial.print(\" - Y: \");\n  // Serial.print(getSeparatedValues(Y_ACCEL) - mean_y);\n  // Serial.print(\" - Z: \");\n  // Serial.println(getSeparatedValues(Z_ACCEL) - mean_z);\n  delay(1);\n}", "id": 146, "concepts": ["data processing with accelerometer", "filtering and smoothing", "serial communication", "RMS calculation", "state transitions"], "instruction": "Design a C++ program to process data from an accelerometer, apply a low-pass filter, and calculate the RMS of the filtered data. The accelerometer data is stored in a binary file with 32-bit integer values representing the x-, y-, and z-axis acceleration in that order. The program should filter out any data points that are more than 2000 units away from the mean, and then calculate the RMS of the remaining data points. The program should also send the RMS value over a serial port at a baud rate of 9600, with a newline character (\\n) as the delimiter."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: Particle.functions, string to integer conversion, string matching\n\n### Task", "fingerprint": null, "seed": "int ledToggle(String command) {\n     /* Particle.functions always take a string as an argument and return an integer.\n     Since we can pass a string, it means that we can give the program commands on how the function should be used.\n     In this case, telling the function \"on\" will turn the LED on and telling it \"off\" will turn the LED off.\n     Then, the function returns a value to us to let us know what happened.\n     In this case, it will return 1 for the LEDs turning on, 0 for the LEDs turning off,\n     and -1 if we received a totally bogus command that didn't do anything to the LEDs.\n     */\n     if (command==\"on\") {\n         digitalWrite(pinLed,HIGH);\n         return 1;\n     }\n     else if (command==\"off\") {\n         digitalWrite(pinLed,LOW);\n         return 0;\n     }\n     else {\n         return -1;\n     }\n}", "id": 147, "concepts": ["Particle.functions", "string to integer conversion", "string matching"], "instruction": "Implement a C++ class `Particle` that represents a single particle in a simulator. The class should have the following attributes and functions:\n1. Attributes:\n    - `position`: a tuple representing the x- and y-coordinates of the particle's current position\n    - `velocity`: a tuple representing the x- and y-components of the particle's velocity\n    - `acceleration`: a tuple representing the x- and y-components of the particle's acceleration\n    - `color`: a string representing the particle's color in hexadecimal format (e.g., `'#FF0000'` for red)\n    - `size`: an integer representing the particle's size in pixels\n2. Functions:\n    - `update()`: updates the particle's position based on its velocity and acceleration\n    - `draw(canvas)`: renders the particle on the given `canvas`, which is a 2D array of pixels\n    - `collide(particle)`: checks whether the particle has collided with another particle, returning `true` if so\n    - `distance_to(particle)`: calculates the distance between the particle and another particle"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: easy\nconcepts: deletion in linked lists, handling of edge cases and boundary conditions\n\n### Task", "fingerprint": null, "seed": "void del(Node *p){\n\tif(p->next){\n\t\tNode *pnext = p->next;\n\t\tNode *pnextnext = pnext->next;\n\t\tp->next = pnextnext;\n\t\tdelete pnext;\n\t}\n}", "id": 148, "concepts": ["deletion in linked lists", "handling of edge cases and boundary conditions"], "instruction": "Implement a C++ class `LinkedList` that represents a linked list data structure. The class should have methods to add a new node to the end of the list (`add`), remove a specific node from the list (`remove`), and return the list's size (`size`). Ensure that the linked list can handle the following edge cases:\n- Removing a node from an empty list\n- Removing a node that does not exist in the list"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: hard\nconcepts: string parsing, linked list manipulation, parenthesis matching\n\n### Task", "fingerprint": null, "seed": "void p7(Node *h){\n\tNode *p = h;\n\twhile(p){\n\t\tNode *pn = p->next;\n\t\tif(pn == NULL || \n\t\t\t(pn->c != ']' &&\n\t\t\t pn->c != '[' &&\n\t\t\t pn->c != '(' &&\n\t\t\t pn->c != ')' &&\n\t\t\t pn->c != '{' &&\n\t\t\t pn->c != '}' &&\n\t\t\t pn->c != '<' &&\n\t\t\t pn->c != '>')){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n//\t\tcout<<\"p7\"<<endl;\n\t\tNode *node = new Node(' ');\n\t\tp = insert(p,node);\n\t\tnode = new Node(' ');\n\t\tpn = insert(pn,node);\n\t\tp = pn;\n\t}\n}", "id": 149, "concepts": ["string parsing", "linked list manipulation", "parenthesis matching"], "instruction": "Implement a C++ function to determine whether a string containing only parentheses is balanced. A string is considered balanced if it has the same number of opening parentheses as closing parentheses, and each closing parenthesis has a corresponding opening parenthesis. For example, \"(())\" is balanced, but \"(()))\" is not.\n\nYour function should return `true` if the string is balanced, and `false` otherwise.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert is_balanced(\"(())\") == true\nassert is_balanced(\"(()))\") == false\nassert is_balanced(\"(()))(()\") == false\nassert is_balanced(\"(((())))\") == true\nassert is_balanced(\"(((()))\") == false\nassert is_balanced(\"(((()))))\") == false\nassert is_balanced(\"(((())))()\") == true\nassert is_balanced(\"())(\") == false\nassert is_balanced(\"())(()\") == false\nassert is_balanced(\"())(()))\") == false\nassert is_balanced(\"()((())())\") == true\nassert is_balanced(\"()((())())()\") == true\nassert is_balanced(\"()((())())(()\") == false\nassert is_balanced(\"()((())())())))\") == false\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: hard\nconcepts: modular arithmetic for integer multiplication\n\n### Task", "fingerprint": null, "seed": "int mul(int x){return x>=mod?x-mod:x;}", "id": 150, "concepts": ["modular arithmetic for integer multiplication"], "instruction": "Implement a C++ program that multiplies two integers `a` and `b` without using the `*` operator. Instead, utilize modular arithmetic and addition to perform the multiplication."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: radio communication setup, network configuration, automatic acknowledgement, retry configuration, delay calculation\n\n### Task", "fingerprint": null, "seed": "void setup_Funk()\n{\n  SPI.begin();\n  radio.begin();\n  network.begin(FunkChannel, FunkSlaveJoystick); //(channel, node address)\n  radio.setPALevel(RF24_PA_MAX);\n  radio.setDataRate(RF24_2MBPS);\n  radio.setAutoAck(1); // Ensure autoACK is enabled\n  radio.setRetries(15, 15);\n  // delay How long to wait between each retry, in multiples of 250us, max is 15. 0 means 250us, 15 means 4000us.\n  //count How many retries before giving up, max 15\n}", "id": 151, "concepts": ["radio communication setup", "network configuration", "automatic acknowledgement", "retry configuration", "delay calculation"], "instruction": "Create a C++ function `setup_radio_communication(frequency, data_rate, timeout)` to establish a radio communication between two devices, given the shared frequency, data rate, and timeout values. The function should set up the radio module, configure the frequency, data rate, and timeout, and return a boolean value indicating the success or failure of the setup. Additionally, include an automatic acknowledgement mechanism within the function to ensure the successful communication."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: medium\nconcepts: notification handling for specific conditions, error logging with serial output\n\n### Task", "fingerprint": null, "seed": "void phasefailurenotification()\n{\n   if(phasefailurenotificationflag == true && phaseFailureAlertOnOffState == 0 && blynkConnectionStatusForNotification == true){\n     Serial.println(\"Sending Phase Failure Blynk notification\");\n     Blynk.notify(\"Phase Failure Detected!\");\n     phasefailurenotificationflag = false;\n   }\n}", "id": 152, "concepts": ["notification handling for specific conditions", "error logging with serial output"], "instruction": "Develop a C++ program to handle a series of notifications. The program should print the notification details when the notification type is 'critical' or 'warning'. In addition, log the error message to a serial output device when the notification type is 'error'. The program should also include assertions to verify the input data is valid."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: function definition, function signature, input parameter\n\n### Task", "fingerprint": null, "seed": "void calc_expr(int val)\n{\n\tstd::cout << val << std::endl;\n}", "id": 153, "concepts": ["function definition", "function signature", "input parameter"], "instruction": "Implement a C++ function named `find_max_subarray_sum` that takes an array of integers as input and returns the maximum sum of a contiguous subarray within the input array. The function should have the following signature:\n\n```cpp\nint find_max_subarray_sum(const std::vector<int>& array);\n```\n\nFor example, given the array `[-2, 1, -3, 4, -1, 2, 1, -5, 4]`, the contiguous subarray with the largest sum is `[4, -1, 2, 1]`, with a sum of `6`. Therefore, the function should return `6`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: hard\nconcepts: C++ code snippet with a function definition for the `DiscreteMasterProperty__bool__OnComplete` method. The function takes a pointer to a `DiscreteMasterProperty__bool` object as an argument. The function iterates through the object's `Handles` list, which contains `MixerHandle__bool` objects, and finds the one with the highest strength. If such a handle exists, the function sets the value of the `Property` to the value of the handle.\n\n### Task", "fingerprint": null, "seed": "void DiscreteMasterProperty__bool__OnComplete(DiscreteMasterProperty__bool* __this)\n{\n    bool nv = __this->RestValue();\n    float str = 0.5f;\n\n    for (::app::Uno::Collections::List1_Enumerator__Fuse_Animations_MixerHandle_bool_ enum_123 = ::uPtr< ::app::Uno::Collections::List__Fuse_Animations_MixerHandle_bool_*>(__this->Handles)->GetEnumerator(); enum_123.MoveNext(); )\n    {\n        ::app::Fuse::Animations::MixerHandle__bool* v = enum_123.Current();\n\n        if (::uPtr< ::app::Fuse::Animations::MixerHandle__bool*>(v)->HasValue() && (::uPtr< ::app::Fuse::Animations::MixerHandle__bool*>(v)->Strength > str))\n        {\n            nv = ::uPtr< ::app::Fuse::Animations::MixerHandle__bool*>(v)->Value;\n            str = v->Strength;\n        }\n    }\n\n    ::uPtr< ::app::Uno::UX::Property__bool*>(__this->Property)->Set(nv, (::uObject*)__this);\n}", "id": 154, "concepts": ["C++ code snippet with a function definition for the `DiscreteMasterProperty__bool__OnComplete` method. The function takes a pointer to a `DiscreteMasterProperty__bool` object as an argument. The function iterates through the object's `Handles` list", "which contains `MixerHandle__bool` objects", "and finds the one with the highest strength. If such a handle exists", "the function sets the value of the `Property` to the value of the handle."], "instruction": "Implement the `OnComplete` method for the `DiscreteMasterProperty__bool` class in C++:\n\n```cpp\nvoid DiscreteMasterProperty__bool__OnComplete(DiscreteMasterProperty__bool* self) {\n    float maxStrength = 0.0f;\n    MixerHandle__bool* maxStrengthHandle = NULL;\n    for (int i = 0; i < self->Handles.Count; i++) {\n        if (self->Handles[i]->Strength > maxStrength) {\n            maxStrength = self->Handles[i]->Strength;\n            maxStrengthHandle = self->Handles[i];\n        }\n    }\n    if (maxStrengthHandle != NULL) {\n        self->Property = maxStrengthHandle->Value;\n    }\n}\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: graph traversal, sorting, union-find data structure\n\n### Task", "fingerprint": null, "seed": "int main(){\n    int n,v;\n    fin>>n;\n    int en=0;\n    for(int i=0;i<n;i++)\n    {\n        for(int j=0;j<n;j++)\n        {\n            fin>>v;\n            if(j<=i)\n                continue;\n            edg[en].v=v;\n            edg[en].x=i;\n            edg[en].y=j;\n            en++;\n        }\n    }\n    //\n    sort(edg,edg+en,cmp);\n    int eslc=0;\n    UnionFind<100> uf;\n    int cost=0;\n    for(int i=0;i<en&&eslc<en-1;i++)\n    {\n        if(uf.Union(edg[i].x,edg[i].y)){\n            cost+=edg[i].v;\n            eslc++;\n        }\n    }\n    fout<<cost<<endl;\n}", "id": 155, "concepts": ["graph traversal", "sorting", "union-find data structure"], "instruction": "Implement a C++ function `critical_connections(n, connections)` that finds all critical connections in a graph with `n` nodes and `connections` edges. A connection is defined as critical if removing it would cause the graph to become disconnected.\n\nThe function should return a list of all critical connections. The graph is represented as a list of edges, where each edge is a pair of nodes. Each node is represented as an integer.\n\nHere is the implementation of the `UnionFind` class, which is used to check if removing an edge would cause the graph to become disconnected:\n\n```cpp\nclass UnionFind {\npublic:\n    UnionFind(int n) : parent(n), rank(n, 0) {\n        for (int i = 0; i < n; ++i) {\n            parent[i] = i;\n        }\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    void unionSets(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX != rootY) {\n            if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else {\n                parent[rootX] = rootY;\n                rank[rootY]++;\n            }\n        }\n    }\n\nprivate:\n    vector<int> parent;\n    vector<int> rank;\n};\n```\n\nThe `UnionFind` class provides two methods: `find(x)`, which finds the root of the set containing node `x`, and `unionSets(x, y)`, which merges the sets containing nodes `x` and `y`.\n\nThe idea of the solution is to use depth-first search (DFS) to traverse the graph and keep track of the discovery time of each node. We can then use the union-find data structure to determine if removing an edge would cause the graph to become disconnected.\n\nHere is the implementation of the `critical_connections` function:\n\n```cpp\nvector<vector<int>> critical_connections(int n, vector<vector<int>>& connections) {\n    UnionFind uf(n);\n    vector<vector<int>> graph(n);\n    for (const auto& edge : connections) {\n        graph[edge[0]].push_back(edge[1]);\n        graph[edge[1]].push_back(edge[0]);\n    }\n\n    vector<int> discovery(n, -1);\n    vector<int> low(n, -1);\n    vector<vector<int>> critical;\n    dfs(graph, uf, discovery, low, critical, 0, -1, 0);\n\n    return critical;\n}\n\nvoid dfs(vector<vector<int>>& graph, UnionFind& uf, vector<int>& discovery, vector<int>& low, vector<vector<int>>& critical, int node, int parent, int time) {\n    discovery[node] = low[node] = time;\n    for (int neighbor : graph[node]) {\n        if (neighbor == parent) {\n            continue;\n        }\n        if (discovery[neighbor] == -1) {\n            dfs(graph, uf, discovery, low, critical, neighbor, node, time + 1);\n            low[node] = min(low[node], low[neighbor]);\n            if (low[neighbor] > discovery[node]) {\n                critical.push_back({node, neighbor});\n            }\n        } else {\n            low[node] = min(low[node], discovery[neighbor]);\n        }\n    }\n}\n```\n\nThis function uses depth-first search (DFS) to traverse the graph, keeping track of the discovery time and lowest discovery time of each node. It uses the union-find data structure to determine if removing an edge would cause the graph to become disconnected.\n\n- The `critical_connections` function takes the number of nodes `n` and a list of edges `connections`. It initializes a graph using an adjacency list representation and a `UnionFind` data structure.\n\n- The `dfs` function is a recursive function that performs DFS on the graph. It takes the graph, the `UnionFind` data structure, the discovery time and lowest discovery time arrays, the list of critical connections, the current node, the parent node, and the current time as arguments. It updates the discovery time and lowest discovery time of the current node, visits each neighbor node, and updates the lowest discovery time of the current node based on the lowest discovery time of the neighbor node. If the lowest discovery time of the neighbor node is greater than the discovery time of the current node, then the edge between the current node and the neighbor node is a critical connection and is added to the list of critical connections.\n\n- The `critical_connections` function then calls the `dfs` function with the starting node as the root node and the current time as 0. It returns the list of critical connections.\n\nThe `critical_connections` function uses depth-first search to traverse the graph and keep track of the discovery time and lowest discovery time of each node. It uses the union-find data structure to determine if removing an edge would cause the graph to become disconnected. The `dfs` function is a recursive function that performs DFS on the graph. It updates the discovery time and lowest discovery time of the current node, visits each neighbor node, and updates the lowest discovery time of the current node based on the lowest discovery time of the neighbor node. If the lowest discovery time of the neighbor node is greater than the discovery time of the current node, then the edge between the current node and the neighbor node is a critical connection and is added to the list of critical connections.\n\nThe `critical_connections` function then calls the `dfs` function with the starting node as the root node and the current time as 0. It returns the list of critical connections."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: class definition, function implementation, function overloading, function overriding, inheritance, polymorphism\n\n### Task", "fingerprint": null, "seed": "int main()\n{\n    Proxy c;\n\n    c.set_X(4);\n    c.set_Y(4.5);\n    c.set_Z(\"Hello\");\n\n    for(int i=0; i<5; i++){\n        c.g();\n        c.f(4);\n    }\n}", "id": 156, "concepts": ["class definition", "function implementation", "function overloading", "function overriding", "inheritance", "polymorphism"], "instruction": "Implement a C++ class `Base` with a method `f(int)` that returns the square of the input. Create a subclass `Derived` that overrides the `f(int)` method to return the cube of the input. Additionally, define a function `call_f(Base& b, int x)` that calls the `f(int)` method on the given object `b` and returns the result."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data expansion, 2D array handling, loop parallelization\n\n### Task", "fingerprint": null, "seed": "void expand_idata(float *data2, float *data3, int Nx, int Ny, int Lx) \n{ \n\t#pragma acc parallel loop independent present(data2[0:Lx*Ny],data3[0:2*Lx*Ny]) \n\tfor (int i=0;i<Ny;i++) \n\t{ \n\t\t#pragma acc loop independent \n\t\tfor (int j=0;j<Lx;j++) \n\t\t{ \n\t\t\tdata3[2*Lx*i+2*j] = data2[Lx*i+j]; \n\t\t\tdata3[2*Lx*i+2*j+1] = 0.0; \n\t\t} \n\t} \n}", "id": 157, "concepts": ["data expansion", "2D array handling", "loop parallelization"], "instruction": "Write a C++ program that accepts a 2D array of size $n \\times m$ and expands it to a $2n \\times 2m$ array by doubling the size of each element. For example, given `array = [[1, 2], [3, 4]]`, the output should be `[[1, 1, 2, 2], [1, 1, 2, 2], [3, 3, 4, 4], [3, 3, 4, 4]]`. The program should run in $O(nm)$ time complexity and utilize parallel computing to achieve better performance."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: hard\nconcepts: serial communication with an external device, data parsing and processing, error handling\n\n### Task", "fingerprint": null, "seed": "void pzemdevice2()                                                                // Function to get PZEM device 2 data\n{\n  Serial.println(\"====================================================\");\n  Serial.println(\"Now checking PZEM Device 2\");\n  uint8_t result2;\n\n  ESP.wdtDisable();\n  result2 = node2.readInputRegisters(0x0000, 10);\n  ESP.wdtEnable(1);\n\n  if (result2 == node2.ku8MBSuccess)\n  {\n    voltage_usage_2      = (node2.getResponseBuffer(0x00) / 10.0f);\n    current_usage_2      = (node2.getResponseBuffer(0x01) / 1000.000f);\n    active_power_2       = (node2.getResponseBuffer(0x03) / 10.0f);\n    active_energy_2      = (node2.getResponseBuffer(0x05) / 1000.0f);\n    frequency_2          = (node2.getResponseBuffer(0x07) / 10.0f);\n    power_factor_2       = (node2.getResponseBuffer(0x08) / 100.0f);\n\n    Serial.print(\"VOLTAGE:           \");   Serial.println(voltage_usage_2);         // V\n    Serial.print(\"CURRENT_USAGE:     \");   Serial.println(current_usage_2, 3);      // A\n    Serial.print(\"ACTIVE_POWER:      \");   Serial.println(active_power_2);          // W\n    Serial.print(\"ACTIVE_ENERGY:     \");   Serial.println(active_energy_2, 3);      // kWh\n    Serial.print(\"FREQUENCY:         \");   Serial.println(frequency_2);             // Hz\n    Serial.print(\"POWER_FACTOR:      \");   Serial.println(power_factor_2);\n    Serial.println(\"====================================================\");\n  }\n    else {\n    Serial.println(\"Failed to read PZEM Device 2\");\n    Serial.println(\"PZEM Device 2 Data\");\n    voltage_usage_2      = 0;\n    current_usage_2      = 0;\n    active_power_2       = 0;\n    active_energy_2      = 0;\n    frequency_2          = 0;\n    power_factor_2       = 0;\n    Serial.print(\"VOLTAGE:           \");   Serial.println(voltage_usage_2);         // V\n    Serial.print(\"CURRENT_USAGE:     \");   Serial.println(current_usage_2, 3);      // A\n    Serial.print(\"ACTIVE_POWER:      \");   Serial.println(active_power_2);          // W\n    Serial.print(\"ACTIVE_ENERGY:     \");   Serial.println(active_energy_2, 3);      // kWh\n    Serial.print(\"FREQUENCY:         \");   Serial.println(frequency_2);             // Hz\n    Serial.print(\"POWER_FACTOR:      \");   Serial.println(power_factor_2);\n    Serial.println(\"====================================================\");\n    swith_off(); \n  }\n}", "id": 158, "concepts": ["serial communication with an external device", "data parsing and processing", "error handling"], "instruction": "Implement a C++ function to communicate with an external device via a serial port. The function should take a command string, send it over the serial port, and wait for a response from the device. The response should be parsed and interpreted as a 32-bit integer in little-endian format. If the response is invalid or the device does not respond within a timeout, the function should raise an exception.\n\nFor example, given `command = 'get_temperature'`, the function should send the command over the serial port, wait for the response, parse it as a 32-bit integer in little-endian format, and return it. If the response is invalid or the device does not respond within a timeout, the function should raise an exception.\n\nNote: You can use `std::exception` or a custom exception class to handle exceptions, and `std::chrono` or a custom timer class to implement the timeout functionality."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: hard\nconcepts: command-line argument parsing, output formatting, error handling\n\n### Task", "fingerprint": null, "seed": "void print_usage(FILE* stream, int exit_code, char* program_name)\r\n{\r\n\tfprintf(stream,\r\n\t\t\t\"A program to generate terrain and features with variable formats.\\n\\n\");\r\n\tfprintf(stream, \"Usage:  %s [options]\\n\", program_name);\r\n\tfprintf(stream,\r\n\t\t\t\"  -h  --help                 Display this usage information.\\n\"\r\n\t\t\t\t\t\"  -c  --config <filename>    Use custom config file.\\n\"\r\n\t\t\t\t\t\"  -v  --verbose              Print verbose messages.\\n\"\r\n\t\t\t\t\t\"      --height <value>       Crop the map down to specified positive integer height.\\n\"\r\n\t\t\t\t\t\"      --width <value>        Crop the map down to specified positive integer width.\\n\"\r\n\t\t\t\t\t\"      --rough <value>        Define smoothness of the terrain as a float (0.0 < v < 1.0).\\n\"\r\n\t\t\t\t\t\"                             Lower values produce smoother terrain, smaller difference in adjacent tiles.\\n\"\r\n\t\t\t\t\t\"      --seed <value>         Set the initial positive integer height for the algorithm to be generate values from.\\n\"\r\n\t\t\t\t\t\"      --offset <value>       Set the initial offset positive integer height (seed+offset=max possible height).\\n\"\r\n\t\t\t\t\t\"      --plate <value>        Set the fraction of the tectonic plates appearance.\\n\"\r\n\t\t\t\t\t\"                             Higher values will give a more 'ripped apart' look, values too close to 1 are not\\n\"\r\n\t\t\t\t\t\"                             recommended for realistic terrain. (0.0 < v < 1.0)\\n\"\r\n\t\t\t\t\t\"      --erosion <value>      Number of erosion iterations over the terrain. Must be a positive integer.\\n\"\r\n\t\t\t\t\t\"  -n  --negative             Allow for negative height values.\\n\"\r\n\t\t\t\t\t\"  -s  --standard             Use standard output to be written to a file (used as default output).\\n\"\r\n\t\t\t\t\t\"                             width, height and a set of height values all separated by a space.\\n\"\r\n\t\t\t\t\t\"  -g  --graphical            Display the height map using a 3D OpenGL view.\\n\"\r\n\t\t\t\t\t\"  -x  --xml                  Use the following xml output to be written to a file:\\n\"\r\n\t\t\t\t\t\"                           <map width=int height=int>\\n\"\r\n\t\t\t\t\t\"                           [<tile x=int y=int>\\n\"\r\n\t\t\t\t\t\"                           <height>int</height>\\n\"\r\n\t\t\t\t\t\"\t\t\t\t\t\t\t<type>string</type>\\n\"\r\n\t\t\t\t\t\"                           </tile>\\n]+\"\r\n\t\t\t\t\t\"                           </map>\\n\");\r\n\texit(exit_code);\r\n}", "id": 159, "concepts": ["command-line argument parsing", "output formatting", "error handling"], "instruction": "Create a C++ program that accepts command-line arguments and performs logical operations on them. The program should accept up to three command-line arguments, each representing a Boolean value. The first argument should represent the value of A, the second argument should represent the value of B, and the third argument should represent the logical operator to apply (AND, OR, or XOR). The program should output the result of the logical operation in the format \"A {operator} B = C\", where A, B, and C are replaced with the appropriate values. If the program is provided with fewer than three arguments or an invalid logical operator, it should display an error message and exit.\n\nFor example, the program should produce the following output for the given arguments:\n\n```\n$ ./boolean_program true false or\nA OR B = true\n\n$ ./boolean_program 1 0 and\nA AND B = false\n\n$ ./boolean_program 1 0 xor\nA XOR B = true\n\n$ ./boolean_program 1\nError: expected 3 arguments, received 1\n\n$ ./boolean_program 1 0 invalid-operator\nError: invalid logical operator\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: hard\nconcepts: character array parsing, type conversion, string to float conversion\n\n### Task", "fingerprint": null, "seed": "float\ngetBufferFloat(cstring charBuffer)\n{\n    return (float) atof(charBuffer);\n}", "id": 160, "concepts": ["character array parsing", "type conversion", "string to float conversion"], "instruction": "Implement a C++ function `str2float` to convert a string to a float. The function should parse a string of digits and decimal points and return a float value. For example, `str2float('123.456')` should return 123.456, and `str2float('123')` should return 123.0.\n\nFor this task, you can assume the input string is valid and only contains digits and '.' (decimal point)."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: hard\nconcepts: linked list traversal, node struct definition, pointer manipulation for list traversal\n\n### Task", "fingerprint": null, "seed": "int main()\r\n{\r\n\tStudent s[3]={{1001,\"Sunny\",90},{1002,\"Tom\",80},{1003,\"Kitty\",85}};\r\n\tStudent *p,*head;\r\n\thead=s;\r\n\ts[0].next=&s[1];\r\n\ts[1].next=&s[2];\r\n\ts[2].next=NULL;\r\n\tp=head;\r\n\twhile(p!=NULL)\r\n\t{\r\n\t\tprintf(\"%6d %6s %6.2f\",p->num,p->name,p->score);\r\n\t\tp=p->next;\r\n\t\tprintf(\"\\n\");\r\n\t}\r\nreturn 0;\t\t\t\r\n}", "id": 161, "concepts": ["linked list traversal", "node struct definition", "pointer manipulation for list traversal"], "instruction": "Design a C++ function to remove duplicates from a sorted linked list in O(n) time and O(1) space. The linked list is represented by a struct `Node` with an integer value and a pointer to the next node.\n\nFor example, given the linked list `1 -> 2 -> 3 -> 3 -> 4 -> 4 -> 5`, the function should return `1 -> 2 -> 3 -> 4 -> 5`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: hard\nconcepts: string scrambler, string scrambling, checking string scrambler\n\n### Task", "fingerprint": null, "seed": "int main()\n{\n    string s1 = \"eebaacbcbcadaaedceaaacadccd\";\n    string s2 = \"eadcaacabaddaceacbceaabeccd\";\n    \n    bool result = isScramble(s1, s2);\n    cout << \"result = \" << result << endl;\n\n    return 0;\n}", "id": 162, "concepts": ["string scrambler", "string scrambling", "checking string scrambler"], "instruction": "Implement a C++ function `scramble_string(input_str)` that returns a string with the characters of `input_str` randomly shuffled. The function must satisfy the following preconditions:\n\n1. The function must accept a string as input and return a string of the same length.\n2. The function must not return the same string for a given input string.\n3. The function must return a string where each character appears in the original string.\n\nAdditionally, design a C++ function `check_scrambler(scrambler)` that takes a function as input and checks whether it satisfies the preconditions."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: hard\nconcepts: accelerometer values, value queueing, circular queue\n\n### Task", "fingerprint": null, "seed": "void accel_values_put(float value_in)\n{\n  if (queue_position == RMS_window)\n    queue_position = 0;\n  accel_values[queue_position] = value_in;\n  queue_position++;\n}", "id": 163, "concepts": ["accelerometer values", "value queueing", "circular queue"], "instruction": "Create a C++ program to process a stream of accelerometer values from a sensor. The values are represented as a tuple (x, y, z), where each element represents a different axis. The program should maintain a queue of the most recent N values, where N is a user-defined parameter. Then, for each incoming value, calculate the average of the x, y, and z axes and print the result. The program must be designed to handle large amounts of data efficiently."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: function overloading, object creation and initialization, function call resolution\n\n### Task", "fingerprint": null, "seed": "int main() {\n    Foo s1, s2(1);\n    bar(s1);\n    bar(2);\n}", "id": 164, "concepts": ["function overloading", "object creation and initialization", "function call resolution"], "instruction": "Implement a C++ function `create_function` that accepts a string representation of a C++ function declaration, parses it, and returns a callable object that behaves the same as the function. For example, `create_function(\"void f(int x) { return x + 1; }\")` should return a function that takes an integer `x` and returns `x + 1`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: hard\nconcepts: analog read from a pin, instantaneous value acquisition, floating-point number representation\n\n### Task", "fingerprint": null, "seed": "float getSeparatedValues(int pin)\n{  \n  float instant_value = analogRead(pin);\n  return instant_value;\n}", "id": 165, "concepts": ["analog read from a pin", "instantaneous value acquisition", "floating-point number representation"], "instruction": "Implement a C++ function to perform an analog read on a pin and return a floating-point number representing the analog value. The function should take the pin number as an argument and return a value between 0 and 1.0 representing the voltage level on the pin.\n\nThe analog read is performed by converting the analog signal into a digital value using an analog-to-digital converter (ADC). The ADC converts the analog signal into a digital value by sampling the analog signal at regular intervals and storing the sampled values into a buffer. The function should read from the buffer at the specified pin and convert the stored digital value into a floating-point number representing the analog value."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: hard\nconcepts: linked list traversal, pattern matching, node insertion, string concatenation\n\n### Task", "fingerprint": null, "seed": "void p13(Node *h, char *c){\n\tNode *p = h;\n\twhile(p){\n\t\tNode *pn = p->next;\n\t\tif(pn == NULL || pn->c != c[0]){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tNode *pnn = pn->next;\n\t\tif(pnn == NULL || pnn->c != c[1]){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tNode *pnnn = pnn->next;\n\t\tif(pnnn == NULL || pnnn->c != c[2]){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tNode *pnnnn = pnnn->next;\n\t\tif(pnnnn == NULL || pnnnn->c != ' '){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n//\t\tcout<<\"p13\"<<endl;\n\t\tNode *node = new Node(' ');\n\t\tp = insert(p,node);\n\t\tp = pnnnn;\n\t}\n}", "id": 166, "concepts": ["linked list traversal", "pattern matching", "node insertion", "string concatenation"], "instruction": "Implement a C++ program to process a singly linked list of strings. The program should traverse the list, searching for patterns that match a given regular expression. For each match, the program should insert a new node containing the concatenation of the matched string and a given suffix into the list immediately after the matched node. The program should terminate when it reaches the end of the list or encounters an empty string."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: hard\nconcepts: domain name parsing, pattern matching and replacement, string processing\n\n### Task", "fingerprint": null, "seed": "void solve(){\n    string s; cin>>s;\n    bool w = false;\n    bool com = false;\n    bool fwd = false;\n    int w_cnt = 0;\n    int fw_cnt = 0;\n    for(int i = 0; i < s.length(); i++){\n        if(w_cnt == 3 && !w){\n            cout<<\".\";\n            w = true;\n        }\n        if(s[i] == 'w'){\n            w_cnt++;\n        }else{\n            w_cnt = 0;\n        }\n        if(i+3 <= s.length()){\n            if(s[i] == 'c' && s[i+1] == 'o' && s[i+2] == 'm' && !com){\n                cout<<\".\";\n                com = true;\n                fw_cnt = i+3;\n            }\n        }\n        if(i == fw_cnt && !fwd && i != 0){\n            cout<<\"/\";\n            fwd = true;\n        }\n        cout<<s[i];\n\n    }\n}", "id": 167, "concepts": ["domain name parsing", "pattern matching and replacement", "string processing"], "instruction": "Develop a C++ program that takes a list of URLs and returns a list of their hostname.\nFor example, given the list of URLs `['https://www.google.com', 'https://github.com', 'https://en.wikipedia.org/wiki/Main_Page']`, the program should return the list of hostnames `['www.google.com', 'github.com', 'en.wikipedia.org']`. The program should handle both HTTP and HTTPS URLs."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: hard\nconcepts: pascal's triangle and binomial coefficient, reducing unnecessary calculations, handling corner cases\n\n### Task", "fingerprint": null, "seed": "int main(){\n    //use double otherwise it will overflow\n    double m,n;\n    vector<double>top;\n    vector<double>bottom;\n    while(cin>>m>>n){\n        if(m==0&&n==0)\n            break;\n        if(n==0){\n            cout<<1<<endl;\n            continue;\n        }\n        n=min(n,m-n);\n        for(double i=0;i<n;i++){\n            top.push_back(m-i);\n            bottom.push_back(i+1);\n\n        }\n        for(int i=n-1;i>=0;i--){\n            for(int j=0;j<n;j++){\n                if((top[j]/bottom[i])==int(top[j]/bottom[i])){\n                    top[j]/=bottom[i];\n                    bottom[i]=1;\n                    break;\n                }\n            }\n        }\n        double ans=1,ans2=1;\n        for(int i=0;i<n;i++){\n            ans*=top[i];\n            ans2*=bottom[i];\n        }\n        cout<<int(ans/ans2)<<endl;\n        top.clear();\n        bottom.clear();\n    }\n\n\n\n\n\n\n\n\n    return 0;\n}", "id": 168, "concepts": ["pascal's triangle and binomial coefficient", "reducing unnecessary calculations", "handling corner cases"], "instruction": "Develop a C++ program to calculate the binomial coefficient (n choose k), which represents the number of ways to choose k items from a set of n items. Implement the program using Pascal's Triangle to reduce unnecessary calculations and handle edge cases. Consider the following properties:\n\n- The triangle is a two-dimensional array where each row represents a new level.\n- The first and last values in each row are 1.\n- Each value in the triangle is the sum of the two values above it.\n- The binomial coefficient is the value in the triangle at row n and column k.\n- If k is greater than n, the coefficient is 0.\n- If k is 0 or n, the coefficient is 1.\n\nYour program should take two arguments: n and k, and return the binomial coefficient. Handle potential errors by raising exceptions when n or k are negative or k is greater than n."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: hard\nconcepts: main function structure, linked list creation and manipulation, memory management\n\n### Task", "fingerprint": null, "seed": "int main(int argc, char* argv[]) {\n\n    // g++ -I./include -o a.out  oddEvenLinkedList.cpp include/list_node.cpp -g\n    // createLink \u603b\u662f\u4e0ddelete\uff0c\u6240\u4ee5\uff0c\u5176\u5b9e\u8fd9\u4e2amain\u4f1a\u5185\u5b58\u6cc4\u9732\n    Solution *solu = new Solution();\n\n    cout << \"begin run:\" << endl;\n    ListNode *head = createLink(5);\n    echoList(head);\n    head = solu->oddEvenList(head);\n    echoList(head);\n\n    cout << \"---------------------------------\" << endl;\n    head = createLink(4);\n    echoList(head);\n    head = solu->oddEvenList(head);\n    echoList(head);\n\n    cout << \"---------------------------------\" << endl;\n    head = createLink(1);\n    echoList(head);\n    head = solu->oddEvenList(head);\n    echoList(head);\n\n}", "id": 169, "concepts": ["main function structure", "linked list creation and manipulation", "memory management"], "instruction": "Implement a C++ class `LinkedList` to represent a linked list data structure. The class should have the following properties:\n\n- A `Node` class to represent a node in the linked list with a value and a pointer to the next node.\n- A `head` pointer to the head node of the linked list.\n- A `size` counter to keep track of the number of nodes in the linked list.\n- A `push_front` method to add a new node with the given value to the front of the linked list.\n- A `pop_front` method to remove the first node from the linked list and return its value.\n- A `remove` method to remove the first node with the given value from the linked list.\n- A `reverse` method to reverse the linked list in place.\n- A `print` method to print the values of the nodes in the linked list.\n- A `search` method to search for a node with the given value in the linked list and return its index.\n\nHere is the implementation of the `LinkedList` class:\n\n```cpp\nclass LinkedList {\nprivate:\n    class Node {\n    public:\n        int value;\n        Node* next;\n\n        Node(int value, Node* next = nullptr) : value(value), next(next) {}\n    };\n\n    Node* head;\n    int size;\n\npublic:\n    LinkedList() : head(nullptr), size(0) {}\n\n    void push_front(int value) {\n        head = new Node(value, head);\n        size++;\n    }\n\n    int pop_front() {\n        if (head == nullptr) {\n            throw std::runtime_error(\"Cannot pop from an empty linked list\");\n        }\n\n        Node* node = head;\n        head = head->next;\n        size--;\n\n        int value = node->value;\n        delete node;\n        return value;\n    }\n\n    void remove(int value) {\n        if (head == nullptr) {\n            return;\n        }\n\n        if (head->value == value) {\n            pop_front();\n            return;\n        }\n\n        Node* prev = head;\n        Node* curr = head->next;\n\n        while (curr != nullptr) {\n            if (curr->value == value) {\n                prev->next = curr->next;\n                delete curr;\n                size--;\n                return;\n            }\n\n            prev = curr;\n            curr = curr->next;\n        }\n    }\n\n    void reverse() {\n        Node* curr = head;\n        Node* prev = nullptr;\n        Node* next = nullptr;\n\n        while (curr != nullptr) {\n            next = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = next;\n        }\n\n        head = prev;\n    }\n\n    void print() {\n        Node* curr = head;\n\n        while (curr != nullptr) {\n            std::cout << curr->value << \" \";\n            curr = curr->next;\n        }\n\n        std::cout << std::endl;\n    }\n\n    int search(int value) {\n        int index = 0;\n        Node* curr = head;\n\n        while (curr != nullptr) {\n            if (curr->value == value) {\n                return index;\n            }\n\n            curr = curr->next;\n            index++;\n        }\n\n        return -1;\n    }\n};\n```\n\nThe class provides methods to manipulate the linked list, including adding and removing nodes, reversing the list, searching for a value, and printing the list. The `Node` class is used to represent each node in the linked list.\n\nNote that the `reverse` method uses a three-pointer approach to reverse the linked list in place. The `print` method iterates through the linked list and prints each node's value. The `search` method searches for the first occurrence of a value in the linked list and returns its index. If the value is not found, it returns -1."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: static variable initialization, non-local variable modification, function call order\n\n### Task", "fingerprint": null, "seed": "void bar(const Foo i) {\n    static Foo s3 = i + 1;\n    ++s3;\n}", "id": 170, "concepts": ["static variable initialization", "non-local variable modification", "function call order"], "instruction": "Implement a C++ function that returns the next integer in a sequence. The sequence is defined as follows: the first element is $a$, the second element is $b$, and the $n$-th element is the sum of the previous two elements. The function should also maintain a static variable that stores the previous two elements. The function should satisfy the following assertions:\n\n```cpp\nassert next_in_sequence(1, 1) == 2\nassert next_in_sequence(1, 1) == 3\nassert next_in_sequence(1, 1) == 5\nassert next_in_sequence(1, 1) == 8\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: hard\nconcepts: fast Poisson solver implementation using the GPU, parallel computing, data transfer and management, Fast Sine Transform\n\n### Task", "fingerprint": null, "seed": "void fast_poisson_solver_gpu(float *b, float *x, float *data2, float *data3, int Nx, int Ny, int Lx) \n{\n\tint i, j;\n\tfloat h, *lamda, *temp;\n\n\ttemp = (float *) malloc(Nx*Ny*sizeof(float));\n\tlamda = (float *) malloc(Nx*sizeof(float));\n\th = 1.0/(Nx+1);\n\n\t#pragma acc data create(lamda[0:Nx],temp[0:Nx*Ny]), present(b[0:Nx*Ny],x[0:Nx*Ny]) \n\t{\n\n\t\t#pragma acc parallel loop independent\n\t\tfor(i=0;i<Nx;i++)\n\t\t{\n\t\t\tlamda[i] = 2 - 2*cos((i+1)*M_PI*h);\n\t\t}\n\n\t\tfdst_gpu(b, data2, data3, Nx, Ny, Lx);\n\t\ttranspose(b, temp, Nx, Ny);\n\t\tfdst_gpu(temp, data2, data3, Nx, Ny, Lx);\n\t\ttranspose(temp, b, Ny, Nx);\n\n\t\t#pragma acc parallel loop independent\n\t\tfor(i=0;i<Ny;i++)\n\t\t{\n\t\t\t#pragma acc loop independent\n\t\t\tfor(j=0;j<Nx;j++)\n\t\t\t{\n\t\t\t\tx[Nx*i+j] = -b[Nx*i+j]/(lamda[i] + lamda[j]);\n\t\t\t}\n\t\t}\n\t\tfdst_gpu(x, data2, data3, Nx, Ny, Lx);\n\t\ttranspose(x, temp, Nx, Ny);\n\t\tfdst_gpu(temp, data2, data3, Nx, Ny, Lx);\n\t\ttranspose(temp, x, Ny, Nx);\n\t} // end data region\n}", "id": 171, "concepts": ["fast Poisson solver implementation using the GPU", "parallel computing", "data transfer and management", "Fast Sine Transform"], "instruction": "Implement a GPU-accelerated fast Poisson solver for the following equation:\n\n$$\n\\nabla^2 \\phi = f\n$$\n\nwhere $\\phi$ is the unknown function and $f$ is the known function. Employ the Fast Sine Transform (FST) to compute the solution efficiently. Utilize a combination of CUDA and C++ to achieve optimal performance on GPUs. Consider memory management and data transfer strategies to ensure effective computation."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: serial communication, command parsing, reset functionality\n\n### Task", "fingerprint": null, "seed": "void read_command() {\n    network.read(in_header, &command_payload, sizeof(command_payload));\n    Serial.print(F(\"Received <- Header.From: 0\"));\n    Serial.print(in_header.from_node, OCT);\n    Serial.print(F(\" command: \"));\n    Serial.println(command_payload.command);\n    //Serial.print(F(\"  value: \"));\n    //Serial.println(command_payload.value);   \n    if (command_payload.command == 'R') {\n         Serial.println(F(\"\\r\\nGot reset command from Master!! \"));\n         Serial.println(F(\"\\nRestarting in 5 seconds.... \"));\n         delay(5000);\n         software_reset();\n    }\n}", "id": 172, "concepts": ["serial communication", "command parsing", "reset functionality"], "instruction": "Implement a C++ function `parse_serial_command` to parse a serial command and process it accordingly. The command is a string containing the following information: the command name, the reset flag (optional), and the command arguments (optional). The command name is a string that defines the type of action to perform. The reset flag is a boolean value that, when set to true, resets the internal state of the function. The command arguments are additional parameters required for the specific command.\n\nThe function should process the command by performing the appropriate action based on the command name and its arguments. If the command is not recognized, the function should throw an exception.\n\nThe function should also handle the reset flag. When the reset flag is set to true, the function should reset its internal state and return the command name as the result.\n\nHere is the pseudo-code for the function:\n\n```cpp\ndef parse_serial_command(command):\n    command_name, *args = command.split()\n    reset_flag = \"reset\" in args\n    if command_name == \"do_something\":\n        if reset_flag:\n            ...\n        ...\n    elif command_name == \"do_something_else\":\n        ...\n    else:\n        raise Exception(f\"Invalid command: {command}\")\n\n    return command_name\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: string manipulation, pointer manipulation, node insertion, node deletion\n\n### Task", "fingerprint": null, "seed": "void p10(Node *h){\n\tNode *p = h;\n\twhile(p){\n\t\tNode *pn = p->next;\n\t\tif(pn == NULL || pn->c != '\\\"'){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n//\t\tcout<<\"p10\"<<endl;\n\t\tNode *node;\n\t\tnode = new Node(' ');\n\t\tp = insert(p,node);\n\t\tnode = new Node('\\'');\n\t\tp = insert(p,node);\n\t\tnode = new Node('\\'');\n\t\tp = insert(p,node);\n\t\tnode = new Node(' ');\n\t\tp = insert(p,node);\n\n\t\tdel(p);\n\t}\n}", "id": 173, "concepts": ["string manipulation", "pointer manipulation", "node insertion", "node deletion"], "instruction": "Implement a C++ class `LinkedList` that represents a linked list. The class should have the following methods:\n\n- `insert_in_order(value)`: Insert a new node with the given value in the linked list in the appropriate position based on the value.\n- `delete(value)`: Delete the first node in the linked list with the given value.\n- `get_string()`: Return a string representation of the linked list in the format: `\"[value1, value2, value3, ...]\"`\n\nNote: You can use the `Node` class as a nested class within the `LinkedList` class to represent each node of the linked list."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: easy\nconcepts: fork system call, process creation, error handling, optimization in system calls\n\n### Task", "fingerprint": null, "seed": "int main() {\n    for (int i = 0; i < 100; ++i) {\n        pid_t pid = fork();\n        if (pid == -1) {\n            std::cout << \"Failed to fork (i = \" << i << \"): \" << strerror(errno) << std::endl;\n            break;\n        }\n        if (pid == 0) {\n            sleep(1);\n            return 0;\n        }\n    }\n    return 0;\n}", "id": 174, "concepts": ["fork system call", "process creation", "error handling", "optimization in system calls"], "instruction": "Implement a C++ program that uses the `fork` system call to create a new process. The parent process should wait for the child process to complete before exiting. Handle any errors that may occur during the process creation. Optimize the program to minimize the number of system calls."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: state reading and processing, if-else statements for conditional logic, boolean logic, function calling\n\n### Task", "fingerprint": null, "seed": "void loop() {\n    //LECTURA DE ESTADOS\n    isDoorOpen = digitalRead(pinDoor);\n    hasDetection = !digitalRead(pinSensor);\n    isRinging = !digitalRead(pinDoorBell);\n\n\n    //MOSTRAR INFO EN LED\n    if (isRinging==true) {\n      ledToggle(\"on\");\n    } else {\n      ledToggle(\"off\");\n    }\n\n/*\n    //MOSTRAR INFO EN LED\n    if (isDoorOpen==true) {\n      ledToggle(\"on\");\n    } else {\n      ledToggle(\"off\");\n    }\n\n    //MOSTRAR INFO EN LED\n    if (hasDetection==true) {\n      ledToggle(\"on\");\n    } else {\n      ledToggle(\"off\");\n    }\n*/\n\n\n}", "id": 175, "concepts": ["state reading and processing", "if-else statements for conditional logic", "boolean logic", "function calling"], "instruction": "Implement a C++ function `read_state(state)` that reads a state string and returns a boolean value indicating whether it is a valid state. The state is valid if it has a length of 2 and all characters are uppercase letters.\n\nThe function should satisfy the following assertions:\n\n```cpp\nassert read_state(\"NY\") == true\nassert read_state(\"new york\") == false\nassert read_state(\"12\") == false\nassert read_state(\"CA\") == true\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: hard\nconcepts: dynamic programming, greedy algorithm, minimum cost calculation, sorting\n\n### Task", "fingerprint": null, "seed": "int main(){\n\n\n\n    while(~scanf(\"%d\",&N)){\n\n        for(int i=1;i<=N;i++)\n                scanf(\"%d\",&a[i]);\n\n\n        sort(a+1,a+N+1);\n\n\n        dp[1]=a[1];\n        dp[2]=a[2];\n\n\n        for(int i=3;i<=N;i++)\n             dp[i]=min(dp[i-1] + a[1] + a[i],dp[i-2] + a[1] + a[i] + 2*a[2]);\n\n\n        printf(\"%d\\n\",dp[N]);\n\n\n    }\n\n\n    return 0;\n}", "id": 176, "concepts": ["dynamic programming", "greedy algorithm", "minimum cost calculation", "sorting"], "instruction": "Given a list of integers `nums`, design a C++ function `min_cost(nums)` to calculate the minimum cost to rearrange the list into a strictly increasing sequence. The cost of rearranging a pair of elements is the sum of their absolute difference and the product of their values. For example, rearranging 4 and 2 has a cost of abs(4 - 2) + 4 * 2 = 6.\n\nYour function should return the minimum cost to rearrange the list into a strictly increasing sequence. If the list is already sorted in a strictly increasing order, the function should return 0.\n\n```cpp\nassert min_cost([1, 2, 3, 4]) == 0\nassert min_cost([4, 2, 3, 1]) == 6\nassert min_cost([3, 1, 2]) == 5\nassert min_cost([1, 2, 2, 3]) == 3\nassert min_cost([1, 2, 3, 2]) == 4\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: hard\nconcepts: conditional logic for simulation and production, random number generation for simulation, status payload population, transmission of status payload, error handling for transmission failure, debugging output\n\n### Task", "fingerprint": null, "seed": "void send_status() {\n    if (SIMULATION) {\n        status_payload.occupied = random(0,2);  // [min, max)\n        status_payload.temperature = random(0, 40);\n        status_payload.humidity = random(0,100);    \n    }\n    else {\n        status_payload.occupied = occupied;\n        status_payload.temperature = temperature;\n        status_payload.humidity = humidity;  \n    }\n    // TODO: disable this for production\n    Serial.print(status_payload.occupied ? \"Occupied, \" : \"Free, \"); \n    Serial.print(status_payload.temperature); \n    Serial.print(F(\", \"));\n    Serial.print(status_payload.humidity);  \n       \n    result = mesh.write(&status_payload, 'S', sizeof(status_payload));\n    if (result)  \n        Serial.println();\n    else \n        Serial.println(F(\"  (Send failed)*\"));\n}", "id": 177, "concepts": ["conditional logic for simulation and production", "random number generation for simulation", "status payload population", "transmission of status payload", "error handling for transmission failure", "debugging output"], "instruction": "Implement a C++ class that simulates a device that can transmit a status payload in the form of a sequence of numbers. The device can operate in either simulation or production mode, where simulation mode simulates the transmission process by generating random numbers for the status payload, while production mode transmits the status payload to a remote server. In simulation mode, the class should print the status payload to the console for debugging purposes. In production mode, the class should attempt to transmit the status payload to a remote server. If the transmission fails, the class should raise an exception to indicate the failure."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: easy\nconcepts: function pointer call, type casting, process execution\n\n### Task", "fingerprint": null, "seed": "void fpcM_Draw(void* pProc) {\n    fpcDw_Execute((base_process_class*)pProc);\n}", "id": 178, "concepts": ["function pointer call", "type casting", "process execution"], "instruction": "Implement a C++ program that takes a function pointer as input and call it with the correct arguments. The function pointer must be cast to a generic function pointer type `void (*)(void*)`. The program should execute the function with the given argument and then return the result.\n\nFor example, if the function is `int square(int x) { return x * x; }`, the program should call `square(5)` and return `25` as the result."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: swapping of two objects, temporary variable creation, assignment operator overloading\n\n### Task", "fingerprint": null, "seed": "void Myswap(Priority &ob1,Priority &ob2)\n{\n\tPriority temp;\n\ttemp =ob1;\n\tob1=ob2;\n\tob2=temp;\n}", "id": 179, "concepts": ["swapping of two objects", "temporary variable creation", "assignment operator overloading"], "instruction": "Implement a C++ function `swap_objects(a, b)` to swap the values of two objects of the same type. You can assume that the objects have an assignment operator that can assign values to them. Your function should use a temporary variable to perform the swap.\n\nFor example, given the following class definition:\n\n```cpp\nclass Foo {\npublic:\n    Foo(int value) : value(value) {}\n    int value;\n    void operator=(const Foo& other) {\n        value = other.value;\n    }\n};\n```\n\nYour function should pass the following assertions:\n\n```cpp\nFoo a(1);\nFoo b(2);\nswap_objects(a, b);\nassert a.value == 2;\nassert b.value == 1;\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: conditional check for the maximum product, input parsing with scanf\n\n### Task", "fingerprint": null, "seed": "int main(int argc, char const *argv[]){\n    int a, b, c, d;\n    scanf(\"%d %d %d %d\",&a, &b, &c, &d);\n\n    if(a*b >= c*d){\n        printf(\"%d\\n\", a*b);\n    }\n    else{\n        printf(\"%d\\n\", c*d);\n    }\n    return 0;\n}", "id": 181, "concepts": ["conditional check for the maximum product", "input parsing with scanf"], "instruction": "Implement a C++ function `max_prod` that accepts two integers and returns the maximum product of them. The function should satisfy the following assertions:\n\n```cpp\nassert max_prod(10, 20) == 200\nassert max_prod(-10, 20) == 200\nassert max_prod(-10, -20) == 200\nassert max_prod(10, -20) == -200\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: hard\nconcepts: command-line arguments parsing, host name resolution, address information retrieval, error handling with return codes, socket programming\n\n### Task", "fingerprint": null, "seed": "int main (int argc, char** argv)\n{\n\tchar * hostName;\n\tif (argc > 1)\n\t\thostName = argv[1];\n\telse return -1;\n\t/*\n\thostent* node = gethostbyname(hostName);\n\tservent* service = getservbyname(hostName, NULL);\n*/\n\tstruct addrinfo* res;\n\tstruct addrinfo hints;\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = AF_UNSPEC;\n\n\tint success = getaddrinfo(argv[1], 0, &hints, &res);\n\tif (success != 0) return success;\n\n\tfor (struct addrinfo* p = res; p != NULL; p = p->ai_next)\n\t{\n\t\tchar host[NI_MAXHOST];\n\n\t\tgetnameinfo(p->ai_addr, p->ai_addrlen, host, NI_MAXHOST, 0, 0, NI_NUMERICHOST);\n\n\t\tstd::cout<< host << \" \" << p->ai_family << \" \"<< p->ai_socktype << std::endl;\n\t}\n\n\tfreeaddrinfo(res);\n\n\treturn 0;\n}", "id": 182, "concepts": ["command-line arguments parsing", "host name resolution", "address information retrieval", "error handling with return codes", "socket programming"], "instruction": "Implement a C++ function to resolve a host name and retrieve its address information. The function should accept a string `host` representing the host name to resolve, and an integer `port` representing the port number. It should return a list of address information tuples, each containing the IP address and port number. If the host name cannot be resolved or the address information cannot be retrieved, the function should return an empty list.\n\nThe function should use the `getaddrinfo` function from the C++ standard library to resolve the host name and retrieve the address information. It should handle any errors that may occur during the process and return an empty list if any errors are encountered.\n\nTo test the function, you can use the following code:\n\n```cpp\nassert resolve_host_addr_info(\"www.google.com\", 80) == [('172.16.17.32', 80), ('192.168.127.12', 80), ('172.16.58.3', 80), ('172.16.58.3', 80), ('192.168.3.11', 80)]\nassert resolve_host_addr_info(\"invalidhostname\", 80) == []\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: hard\nconcepts: linked list insertion, memory management, pointer manipulation\n\n### Task", "fingerprint": null, "seed": "void p9(Node *h){\n\tNode *p = h;\n\tNode *node = new Node(' ');\n\tp = insert(p,node);\n\twhile(p->next){\n\t\tp = p->next;\n\t}\n\tnode = new Node(' ');\n\tp = insert(p, node);\n}", "id": 183, "concepts": ["linked list insertion", "memory management", "pointer manipulation"], "instruction": "Implement a C++ class to represent a linked list. The class should have the following methods:\n\n- `insert(data)` to insert a new node with the given data at the head of the linked list\n- `remove(data)` to remove the first node with the given data from the linked list\n- `print_list()` to print the contents of the linked list\n\nThe class should also define a `Node` class to represent each node in the linked list. Each `Node` object should have a `data` field to store the node's data and a `next` field to point to the next node in the linked list.\n\nImplement the `insert` and `remove` methods in a way that ensures memory management and pointer manipulation are handled properly, ensuring that the linked list remains valid and consistent."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: array traversal and indexing, minimum and maximum value tracking, edge case handling\n\n### Task", "fingerprint": null, "seed": "int main()\n{\n    int n;\n    cin >>n;\n    int a[n];\n    int mx=INT_MIN;\n    int mn=INT_MAX;\n    for(int i=0;i<n;i++){\n        cin >>a[i];\n        mx=max(mx,a[i]);\n        mn=min(mn,a[i]);\n    }\n    int mnI,mxI;\n    for(int i=0;i<n;i++){\n        if(mx==a[i]){mxI=i;}\n        if(mn==a[i]){mnI=i;}\n    }\n    int ans;\n    if(mnI>mxI){\n       ans=max(mnI,n-1-mxI);\n    }\n    else{\n        ans=max(mxI,n-1-mnI);\n    }\n    cout <<ans<<endl;\n    return 0;\n\n}", "id": 184, "concepts": ["array traversal and indexing", "minimum and maximum value tracking", "edge case handling"], "instruction": "Implement a C++ function `find_longest_increasing_subarray` that takes an array of integers as input and returns the longest increasing subarray. The function should handle edge cases such as empty arrays and arrays containing only one element.\n\nFor example, given the array `[1, 2, 3, 2, 4, 5, 6, 3, 4, 5]`, the function should return `[1, 2, 3, 2, 4, 5, 6]`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: hard\nconcepts: I/O pin control, serial communication, Blynk library usage\n\n### Task", "fingerprint": null, "seed": "void swith_off()                                              // Function to switch off relays\n{\n    Serial.println(\"Switching off Relay 1 now..\");\n    digitalWrite(RELAY_PIN_1, HIGH);                // Turnoff Relay 1\n    Serial.println(\"Relay 1 OFF..\");       \n    Blynk.virtualWrite(VPIN_BUTTON_1, HIGH);        // Update Relay Off status on Blynk app   \n\n    Serial.println(\"Switching off Relay 2 now..\");\n    digitalWrite(RELAY_PIN_2, HIGH);                // Turnoff Relay 2\n    Serial.println(\"Relay 2 OFF..\");       \n    Blynk.virtualWrite(VPIN_BUTTON_2, HIGH);        // Update Relay Off status on Blynk app   \n}", "id": 185, "concepts": ["I/O pin control", "serial communication", "Blynk library usage"], "instruction": "Implement a C++ class `BlynkConnection` that provides an interface to control I/O pins on a Blynk-enabled device. The class should include the following methods:\n\n- `BlynkConnection(port, baudrate)`: This is the class constructor that initializes the serial connection with the given `port` and `baudrate`.\n- `connect()`: This method establishes a connection with the Blynk server.\n- `disconnect()`: This method closes the connection with the Blynk server.\n- `set_pin_mode(pin, mode)`: This method sets the mode of an I/O pin (either `INPUT` or `OUTPUT`).\n- `write_pin(pin, value)`: This method writes a value to an I/O pin.\n- `read_pin(pin)`: This method reads the value from an I/O pin.\n\nThe class should handle errors gracefully by throwing exceptions."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: hard\nconcepts: recursive backtracking, depth-first search, state space traversal, solution space exploration\n\n### Task", "fingerprint": null, "seed": "void solve()\n{\n    cin>>n;\n    ll arr[n];\n    for(ll i=0;i<n;i++)\n        cin>>arr[i];\n    dfs(0,0,arr);\n   // cout<<41243431;\n    map<ll,ll>::iterator itr;\n    for(itr=st.begin();itr!=st.end();itr++)\n    {\n        while(itr->second!=0)\n        {\n            cout<<itr->first<<\" \";\n            itr->second--;\n        }\n    }\n    cout<<endl;\n}", "id": 186, "concepts": ["recursive backtracking", "depth-first search", "state space traversal", "solution space exploration"], "instruction": "Implement a C++ class that solves a Sudoku puzzle using recursive backtracking. The class should have a constructor that takes a 9x9 2D array representing the initial board state (some cells may be filled with digits, others should be empty). The class should also have a method `solve()` that returns a boolean indicating whether a solution was found. If a solution is found, the class should update the board state to contain the solved puzzle.\n\nThe implementation should use a recursive backtracking algorithm with depth-first search to explore the solution space. The algorithm should start by selecting an empty cell and trying to fill it with a valid digit (1-9). If a valid digit is found, the algorithm should recursively continue to the next empty cell until the board is filled. If no valid digit can be found for a cell, the algorithm should backtrack to the previous cell and try a different digit. The algorithm should stop once a solution is found or no valid digit can be found for any cell.\n\nThe implementation should also use memoization to store already explored states and avoid revisiting them. This can help reduce the search space and improve efficiency."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: looping through an array of structures, accessing individual fields, printing formatted output\n\n### Task", "fingerprint": null, "seed": "void printList (const Park parks[], int length)\n{\n  for (int i = 0; i < length; i++)\n  {\n    cout << parks[i].parkname << \" [\" << parks[i].state << \"] area: \" << parks[i].area << endl;\n  }\n}", "id": 187, "concepts": ["looping through an array of structures", "accessing individual fields", "printing formatted output"], "instruction": "Given a C++ struct `Person` with the following fields: `name` (a string), `age` (an integer), and `height` (a float), write a function `print_people` that takes an array of `Person`s and prints their details in the following format:\n\n```\nName: <name>, Age: <age>, Height: <height>\n```\n\nFor example, given the array `[{name: \"Alice\", age: 20, height: 1.65}, {name: \"Bob\", age: 30, height: 1.80}]`, the function should print:\n\n```\nName: Alice, Age: 20, Height: 1.65\nName: Bob, Age: 30, Height: 1.80\n```\n\nThe function should use a loop to iterate through the array and access the fields using dot notation."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: matrix difference calculation, maximum absolute difference, vectorization\n\n### Task", "fingerprint": null, "seed": "float Error(float *x, float *u, int Nx) \n{ \n\t// return max_i |x[i] - u[i]| \n\tint i, j; \n\tfloat v, e; \n\tv = 0.0; \n\t\n\tfor(i=0;i<Nx;++i) \n\t{ \n\t\tfor(j=0;j<Nx;j++) \n\t\t{ \n\t\t\te = fabs(x[Nx*i+j] - u[Nx*i+j]); \n\t\t\tif(e > v) v = e;\n\t\t\t//v = max(v, e); \n\t\t} \n\t} \n\treturn v; \n}", "id": 188, "concepts": ["matrix difference calculation", "maximum absolute difference", "vectorization"], "instruction": "Given two 2D arrays `a` and `b` of the same shape, compute the maximum absolute difference between their corresponding elements. You can leverage vectorization and broadcasting techniques to achieve this.\n\nImplement a C++ function `max_abs_diff(a, b)` that returns the maximum absolute difference between the elements of `a` and `b`, considering their corresponding positions."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: image processing, downsampling, upsampling, Gaussian pyramid, Laplacian pyramid\n\n### Task", "fingerprint": null, "seed": "int main(int argc, char* argv) {\n\tMat src = imread(\"lena.jpg\");\n\tMat gsrc;\n\tMat lsrc;\n\n\tpyrDown(src, gsrc);//\u9ad8\u65af\u91d1\u5b57\u5854  \u6210\u500d\u5411\u4e0b\u91c7\u6837\n\tpyrUp(src, lsrc);//\u62c9\u666e\u62c9\u65af\u91d1\u5b57\u5854 \u5411\u4e0a\u91c7\u6837\n\n\tnamedWindow(\"src\");\n\tmoveWindow(\"src\", 0, 0);\n\tnamedWindow(\"gsrc\");\n\tmoveWindow(\"gsrc\", 512, 0);\n\tnamedWindow(\"lsrc\");\n\tmoveWindow(\"lsrc\", 0, 512);\n\n\timshow(\"src\", src);\n\timshow(\"gsrc\", gsrc);\n\timshow(\"lsrc\", lsrc);\n\n\twaitKey(0);\n\n\treturn 0;\n}", "id": 189, "concepts": ["image processing", "downsampling", "upsampling", "Gaussian pyramid", "Laplacian pyramid"], "instruction": "Implement a C++ class `ImagePyramid` that constructs a Gaussian pyramid and a Laplacian pyramid from a given image. The Gaussian pyramid is formed by repeatedly applying a Gaussian filter and downsampling the image. The Laplacian pyramid is formed by taking the difference between the Gaussian pyramid levels.\n\nYou will need to define the `ImagePyramid` class with the following methods:\n\n- `ImagePyramid(image)`: The constructor takes an image as input and initializes the Gaussian and Laplacian pyramids.\n- `gaussian_pyramid()`: Returns the Gaussian pyramid as a list of images.\n- `laplacian_pyramid()`: Returns the Laplacian pyramid as a list of images.\n\nFor each pyramid, you will need to define the following methods:\n\n- `downsample(image, scale)`: Downsamples an image by a given scale factor.\n- `upsample(image, scale)`: Upsamples an image by a given scale factor.\n- `convolve(image, kernel)`: Convolves an image with a given kernel.\n\nYou may use built-in libraries for image processing or define your own functions for downsampling, upsampling, and convolution."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: hard\nconcepts: modbus communication, serial communication, error handling with result codes, real-time monitoring and control\n\n### Task", "fingerprint": null, "seed": "void pzemdevice1()                                                            // Function to get PZEM device 1 data\n{\n  Serial.println(\"====================================================\");     // PZEM Device 1 data fetching code starts here\n  Serial.println(\"Now checking PZEM Device 1\");\n  uint8_t result1;\n\n  ESP.wdtDisable();                                                           // Disable watchdog during modbus read or else ESP crashes when no slave connected\n  result1 = node1.readInputRegisters(0x0000, 10);\n  ESP.wdtEnable(1);                                                           // Enable watchdog during modbus read\n\n  if (result1 == node1.ku8MBSuccess)\n  {\n    voltage_usage_1      = (node1.getResponseBuffer(0x00) / 10.0f);\n    current_usage_1      = (node1.getResponseBuffer(0x01) / 1000.000f);\n    active_power_1       = (node1.getResponseBuffer(0x03) / 10.0f);\n    active_energy_1      = (node1.getResponseBuffer(0x05) / 1000.0f);\n    frequency_1          = (node1.getResponseBuffer(0x07) / 10.0f);\n    power_factor_1       = (node1.getResponseBuffer(0x08) / 100.0f);\n\n    Serial.print(\"VOLTAGE:           \");   Serial.println(voltage_usage_1);       // V\n    Serial.print(\"CURRENT_USAGE:     \");   Serial.println(current_usage_1, 3);    // A\n    Serial.print(\"ACTIVE_POWER:      \");   Serial.println(active_power_1);        // W\n    Serial.print(\"ACTIVE_ENERGY:     \");   Serial.println(active_energy_1, 3);    // kWh\n    Serial.print(\"FREQUENCY:         \");   Serial.println(frequency_1);           // Hz\n    Serial.print(\"POWER_FACTOR:      \");   Serial.println(power_factor_1);\n    Serial.println(\"====================================================\");\n  }\n  else {\n    Serial.println(\"Failed to read PZEM Device 1\");\n    Serial.println(\"PZEM Device 1 Data\");\n    voltage_usage_1      = 0;\n    current_usage_1      = 0;\n    active_power_1       = 0;\n    active_energy_1      = 0;\n    frequency_1          = 0;\n    power_factor_1       = 0;\n\n    Serial.print(\"VOLTAGE:           \");   Serial.println(voltage_usage_1);       // V\n    Serial.print(\"CURRENT_USAGE:     \");   Serial.println(current_usage_1, 3);    // A\n    Serial.print(\"ACTIVE_POWER:      \");   Serial.println(active_power_1);        // W\n    Serial.print(\"ACTIVE_ENERGY:     \");   Serial.println(active_energy_1, 3);    // kWh\n    Serial.print(\"FREQUENCY:         \");   Serial.println(frequency_1);           // Hz\n    Serial.print(\"POWER_FACTOR:      \");   Serial.println(power_factor_1);\n    Serial.println(\"====================================================\");\n    swith_off();                                                                  // Calling swith_off() to turn off relays\n  }\n}", "id": 190, "concepts": ["modbus communication", "serial communication", "error handling with result codes", "real-time monitoring and control"], "instruction": "Implement a C++ program to communicate with a Modbus RTU device using a serial port. The program should perform the following steps:\n\n1. Establish a serial connection with the device.\n2. Send a Modbus RTU request to the device.\n3. Receive and parse the response from the device.\n4. Close the serial connection.\n5. Handle any errors gracefully.\n\nThe program should be able to handle different Modbus function codes and responses, as well as handle errors gracefully."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: easy\nconcepts: code snippet, sorting, bubble sort, string, algorithm, sorting algorithm\n\n### Task", "fingerprint": null, "seed": "int main()\n{\n#pragma region \"Bubble Sort\"\n\tchar word[] = { \"TOLEARNSORTALGORITHMK\" };\n\n\tprintf( \"%s\\n\", word );\n\n\tBubbleSort( word, strlen( word ) );\n\t\n\tprintf( \"%s\\n\", word );\n#pragma endregion\n\treturn 0;\n}", "id": 191, "concepts": ["code snippet", "sorting", "bubble sort", "string", "algorithm", "sorting algorithm"], "instruction": "Implement a C++ class `BubbleSort` with a method `sort(items)` that takes an array of integers and sorts it using the bubble sort algorithm.\n\nHere's how you can implement this class in C++:\n\n```cpp\nclass BubbleSort {\n  public:\n    void sort(int items[], int length) {\n        for (int i = 0; i < length; i++) {\n            for (int j = 0; j < length - i - 1; j++) {\n                if (items[j] > items[j + 1]) {\n                    int temp = items[j];\n                    items[j] = items[j + 1];\n                    items[j + 1] = temp;\n                }\n            }\n        }\n    }\n};\n```\n\nThe `sort` method takes an array of integers (`items`) and its length (`length`). It iterates through the array twice, comparing each pair of adjacent elements and swapping them if they are out of order. This process continues until the array is fully sorted.\n\nHere's a simple test case to verify that the `BubbleSort` class works correctly:\n\n```cpp\nint items[] = {3, 2, 1};\nint sorted[] = {1, 2, 3};\nBubbleSort bubbleSort;\nbubbleSort.sort(items, 3);\nfor (int i = 0; i < 3; i++) {\n    assert(items[i] == sorted[i]);\n}\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: hard\nconcepts: chatter callback function definition, message reception, message logging\n\n### Task", "fingerprint": null, "seed": "void chatterCallback(const std_msgs::String::ConstPtr& msg){\n     ROS_INFO(\"I got:[%s]\",msg->data.c_str());\n\n}", "id": 192, "concepts": ["chatter callback function definition", "message reception", "message logging"], "instruction": "Implement a C++ program that simulates a chat application. The program should allow users to send messages to each other and receive messages from other users. The program should also provide a callback function to handle messages. The callback function should log the received message to a file.\n\nThe program should allow multiple users to connect and chat simultaneously. The program should support multiple chat rooms, where users can join and leave chat rooms. Each chat room should have its own set of users and messages.\n\nImplement the following features:\n- User registration and authentication.\n- User-to-user chatting.\n- Group chatting in chat rooms.\n- Message logging.\n\nThe program should be robust and handle potential errors gracefully."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: fast input/output using scanf/printf, array size optimization, frequency calculation and max frequency tracking\n\n### Task", "fingerprint": null, "seed": "int main()\n{\n    const int size = 30005;\n    int n, m, max = 0;\n    scanf(\"%d\",&n);\n    int p[size];\n    for (int i = 0; i < size; i++)\n    {\n        p[i] = 0;\n    }\n    while (n--)\n    {\n        scanf(\"%d\",&m);\n        p[m] ++;\n    }\n    for (int i = 0; i < size; i++)\n    {\n        max = p[i] > max ? p[i] : max;\n    }\n    for (int i = 0; i < size; i++)\n    {\n        if(p[i] == max)\n        {\n            printf(\"%d %d\\n\",i,p[i]);\n        }\n    }\n    return 0;\n}", "id": 193, "concepts": ["fast input/output using scanf/printf", "array size optimization", "frequency calculation and max frequency tracking"], "instruction": "Implement a C++ class with two methods: `void add(int num)` and `int get_max_frequency()`, where the former adds a number to the class and the latter returns the maximum frequency of any number in the class. Optimize the class for fast input/output using `scanf/printf`."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: hard\nconcepts: deletion in a linked list, skipping over spaces, edge case handling\n\n### Task", "fingerprint": null, "seed": "void p15(Node *h){\n\tNode *p = h;\n\twhile(p->next){\n\t\tif((p->next)->c == ' ') del(p);\n\t\telse break;\n\t}\n//\tcout<<\"p15\"<<endl;\n\twhile(p){\n\t\tif(p->c == ' '){\n\t\t\twhile(p->next){\n\t\t\t\tif((p->next)->c == ' ') del(p);\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t\tp = p->next;\n\t}\n}", "id": 194, "concepts": ["deletion in a linked list", "skipping over spaces", "edge case handling"], "instruction": "Given a singly linked list, implement a C++ function to delete all the spaces in the list. The function should mutate the list in-place by skipping over the spaces and maintaining the relative order of the remaining elements. For example, given a linked list containing the characters ['a', ' ', 'b', ' ', 'c', ' ', 'd'], the function should mutate the list to ['a', 'b', 'c', 'd']. The function should handle edge cases such as the list being empty or containing only spaces."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: hard\nconcepts: voltage measurement, failure detection, notification and response\n\n### Task", "fingerprint": null, "seed": "void low_voltage_check()\n{\n  if(voltage_usage_1 == 0 || voltage_usage_2 == 0 || voltage_usage_3 == 0){\n    Serial.println(\"Phase failure detected...\");\n    phasefailureflag = true;\n    phasefailurenotification();\n  } else if(voltage_usage_1 < LOW_VOLTAGE_1_CUTOFF || voltage_usage_2 < LOW_VOLTAGE_2_CUTOFF || voltage_usage_3 < LOW_VOLTAGE_3_CUTOFF){\n    Serial.println(\"Low voltage detected...\");\n    lowvoltageflag = true;\n    swith_off();\n    low_volt_alert();\n  } else {\n      Serial.println(\"Voltage back to normal\");\n      lowvoltagenotificationflag = true;\n      phasefailurenotificationflag = true;\n      lowvoltageflag = false;\n      phasefailureflag = false;      \n  }\n}", "id": 195, "concepts": ["voltage measurement", "failure detection", "notification and response"], "instruction": "Design a C++ function `check_voltage(voltage)` to check the voltage level and trigger an alarm if the voltage exceeds the safe range of 10V to 14V. The function should return a boolean value indicating whether the alarm is triggered. Additionally, send an email to a predefined email address (e.g., ) if the alarm is triggered.\n\n```cpp\nassert check_voltage(12) == False\nassert check_voltage(10) == False\nassert check_voltage(14) == False\nassert check_voltage(9) == True\nassert check_voltage(15) == True\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bubble sort algorithm, in-place sorting, comparison-based sorting, worst-case time complexity of O(n^2)\n\n### Task", "fingerprint": null, "seed": "void BubbleSort( char* target, size_t count )\n{\n\tfor ( size_t i = 0; i < count - 1; ++i )\n\t{\n\t\tfor ( size_t j = 1; j < count - i; ++j )\n\t\t{\n\t\t\tif ( target[ j - 1 ] > target[ j ] )\n\t\t\t{\n\t\t\t\tchar temp = target[ j ];\n\t\t\t\ttarget[ j ] = target[ j - 1 ];\n\t\t\t\ttarget[ j - 1 ] = temp;\n\t\t\t}\n\t\t}\n\t}\n}", "id": 196, "concepts": ["bubble sort algorithm", "in-place sorting", "comparison-based sorting", "worst-case time complexity of O(n^2)"], "instruction": "Implement a C++ function `bubble_sort` to sort an array of integers in ascending order using the bubble sort algorithm. The function should modify the input array in-place and return the sorted array."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: hard\nconcepts: linked list implementation, push and pop operations, print method\n\n### Task", "fingerprint": null, "seed": "int main()\r\n{\r\n\tList<int> l1;\r\n\tl1.PushBack(1);\r\n\tl1.PushBack(2);\r\n\tl1.PushBack(3);\r\n\tl1.PushBack(4);\r\n\tl1.PrintList();\r\n    return 0;\r\n}", "id": 197, "concepts": ["linked list implementation", "push and pop operations", "print method"], "instruction": "Implement a C++ class `Stack` that represents a stack data structure using a linked list. The class should have the following methods:\n- `push`: adds an element to the top of the stack\n- `pop`: removes and returns the top element from the stack\n- `print`: prints the contents of the stack from top to bottom, separated by spaces\n\nA linked list should be implemented as a separate `Node` class with `data` and `next` fields. The `Stack` class should have a `top` field to keep track of the top element.\n\n```cpp\nclass Stack {\npublic:\n    void push(int data) {\n        Node* new_node = new Node(data);\n        new_node->next = top;\n        top = new_node;\n    }\n    int pop() {\n        if (top == NULL) {\n            throw std::runtime_error(\"Stack is empty\");\n        }\n        Node* popped_node = top;\n        top = top->next;\n        int popped_data = popped_node->data;\n        delete popped_node;\n        return popped_data;\n    }\n    void print() {\n        Node* current = top;\n        while (current != NULL) {\n            std::cout << current->data << \" \";\n            current = current->next;\n        }\n        std::cout << std::endl;\n    }\nprivate:\n    class Node {\n    public:\n        int data;\n        Node* next;\n        Node(int data) {\n            this->data = data;\n            this->next = NULL;\n        }\n    };\n    Node* top;\n};\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: easy\nconcepts: linked list traversal, pattern matching, conditional logic, string formatting\n\n### Task", "fingerprint": null, "seed": "void p5(Node *h){\n\tNode *p = h;\n\twhile(p){\n\t\tNode *pn = p->next;\n\t\tif(pn == NULL || pn->c == '.'){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tNode *pnn = pn->next;\n\t\tif(pnn == NULL || pnn->c != '.'){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tNode *pnnn = pnn->next;\n\t\tif(pnnn == NULL){\n//\t\t\tcout<<\"p5_1 \"<<p->c<<endl;\n\t\t\tNode *node;\n\t\t\tnode = new Node(' ');\n\t\t\tpn = insert(pn,node);\n\t\t\tnode = new Node(' ');\n\t\t\tpnn = insert(pnn,node);\n\t\t\tbreak;\n\t\t}\n\t\tNode *p1 = pnnn;\n\t\twhile(p1){\n\t\t\tif(p1->c != ']' &&\n\t\t\t   p1->c != ')' &&\n\t\t\t   p1->c != '}' &&\n\t\t\t   p1->c != '>' &&\n\t\t\t   p1->c != '\\\"'&&\n\t\t\t   p1->c != '\\'')\n\t\t\t\tbreak;\n\t\t\tp1 = p1->next;\n\t\t}\n\t\tNode *p2 = p1;\n\t\twhile(p2){\n\t\t\tif(p2->c != ' ' && p2->c != '\\t')\n\t\t\t\tbreak;\n\t\t\tp2 = p2->next;\n\t\t}\n\t\tif(p2){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n//\t\tcout<<\"p5_3\"<<endl;\n\t\tNode* node;\n\t\tnode = new Node(' ');\n\t\tpn = insert(pn, node);\n\t\tnode = new Node(' ');\n\t\tp1->c = ' ';\n\t\tclean_List(p1->next);\n\t\tp1->next = NULL;\n\t\tbreak;\n\t}\n}", "id": 198, "concepts": ["linked list traversal", "pattern matching", "conditional logic", "string formatting"], "instruction": "Implement a C++ program to traverse a singly linked list and find the first occurrence of a value that matches a given pattern. The program should return a string formatted as `'Found match at index {}'`, where the index is the position of the first matching node in the linked list. If no match is found, the program should return `'No match found'`.\n\nHere's how you can implement the program:\n\n```cpp\nclass Node {\npublic:\n    int value;\n    Node* next;\n    Node(int value) {\n        this->value = value;\n        this->next = nullptr;\n    }\n};\n\nstring find_match(Node* head, string pattern) {\n    int index = 0;\n    Node* current = head;\n    while (current != nullptr) {\n        if (to_string(current->value) == pattern) {\n            return \"Found match at index \" + to_string(index);\n        }\n        current = current->next;\n        index++;\n    }\n    return \"No match found\";\n}\n```\n\nYou can test your program with the following assertions:\n\n```cpp\nNode* head = new Node(1);\nhead->next = new Node(2);\nhead->next->next = new Node(3);\nhead->next->next->next = new Node(4);\nhead->next->next->next->next = new Node(5);\n\nassert find_match(head, \"3\") == \"Found match at index 2\";\nassert find_match(head, \"6\") == \"No match found\";\n```\n\nNote that the linked list is created with a head node and three additional nodes to test the program."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: coordinate system conversion, cell size calculation, integer rounding\n\n### Task", "fingerprint": null, "seed": "int RowFromYCoord(double yCoord){\n    double yBot = -616153.33419;\n    double cellSize = 270.0;\n    double result;\n    int retVal;\n    \n    result = (yCoord - yBot)/cellSize;\n    retVal = result;\n    return retVal;\n}", "id": 199, "concepts": ["coordinate system conversion", "cell size calculation", "integer rounding"], "instruction": "Given a pixel coordinate `(x, y)` and a cell size `cell_size`, create a C++ function to convert the pixel coordinate into a cell coordinate `(i, j)`, where `(i, j)` represents the cell index in a 2D grid with each cell of size `cell_size`. The resulting cell coordinate should be rounded to the nearest integer."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: hard\nconcepts: setup functionality, asynchronous time synchronization, data formatting, font customization, display layout, text animation, custom character definition\n\n### Task", "fingerprint": null, "seed": "void setup(void)\r\n{\r\n\r\n//////////STILL TRYING TO GET ZULU WITH A DIFFERENT LIBRARY\r\n    setSyncProvider(RTC.get);   // the function to get the time from the RTC\r\n\r\n//////////END STILL TRYING TO GET ZULU WITH A DIFFERENT LIBRARY\r\n\r\n\r\n    Serial.begin(115200);\r\n\r\n  dht.begin();\r\n\r\n  \r\n  P.begin(2);\r\n  P.setInvert(false);\r\n//  P.setIntensity(6);\r\n\r\n  P.setZone(0, 0, MAX_DEVICES-5);\r\n  P.setZone(1, MAX_DEVICES-4, MAX_DEVICES-1);\r\n  P.setFont(1, numeric7Seg);\r\n\r\n  P.displayZoneText(1, szTime, PA_CENTER, SPEED_TIME, PAUSE_TIME, PA_PRINT, PA_NO_EFFECT);\r\n //  COMMENT ABOVE and UNCOMMENT HERE LATER   P.displayZoneText(0, szMesg, PA_CENTER, SPEED_TIME, 0, PA_SCROLL_LEFT, PA_SCROLL_LEFT);\r\nP.displayZoneText(0, szMesg, PA_CENTER, SPEED_TIME, ZULU_PAUSE_TIME, PA_SCROLL_LEFT, PA_SCROLL_LEFT);\r\n\r\n  P.addChar('$', degC);       //NOT NEEDED?\r\n  P.addChar('&', degF);\r\n\r\n                    //  RTC.control(DS1307_CLOCK_HALT, DS1307_OFF);\r\n                    //  RTC.control(DS1307_12H, DS1307_OFF);\r\n\r\n//  getTime(szTime);\r\n}", "id": 200, "concepts": ["setup functionality", "asynchronous time synchronization", "data formatting", "font customization", "display layout", "text animation", "custom character definition"], "instruction": "Implement a C++ function to create a font that is based on the input string and display it as an ASCII art. The function should support different font styles and sizes. The output should be a string representation of the ASCII art, which can be displayed in the terminal or saved as a text file.\n\nFor example, given the input string \"Hello, World!\" and font style \"Bold\", the function should return the following string representation:\n\n```\n' _______________\n'|     |     |  |\n'|  H  |  e  |  |\n'|_____|_____|__|\n'|     |     |  |\n'|  l  |  l  |  |\n'|_____|_____|__|\n'|     |     |  |\n'|  o  |  ,  |  |\n'|_____|_____|__|\n'|     |     |     |\n'|  W  |  o  |  r  |\n'|_____|_____|_____|\n'|     |     |  |\n'|  l  |  d  |  |\n'|_____|_____|__|\n'|     |  |\n'|  !  |  |\n'|_____|__|\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: unit testing with assertions, code readability, code reusability\n\n### Task", "fingerprint": null, "seed": "int main() {\n\n    std::cout << \"starting\" << std::endl;\n    hfu::find_nth_index_test();\n    std::cout << \"find_nth_index_test passed\" << std::endl;\n    hfu::extract_airline_test();\n    std::cout << \"find_airline_test passed\" << std::endl;\n    hfu::create_frequencies_test();\n    std::cout << \"create_frequencies_test passed\" << std::endl;\n    std::cout << \"terminating\" << std::endl;\n    return 0;\n}", "id": 201, "concepts": ["unit testing with assertions", "code readability", "code reusability"], "instruction": "Implement a C++ function `get_max_profit` that calculates the maximum profit from buying and selling a stock based on a list of stock prices. The function should take a list of prices and return the maximum profit that can be made from a single buy and sell transaction. The function should handle edge cases such as empty lists and lists with fewer than two elements appropriately.\n\nThe function should satisfy the following assertions:\n\n```cpp\nassert get_max_profit([]) == 0\nassert get_max_profit([100]) == 0\nassert get_max_profit([100, 200, 100, 200]) == 0\nassert get_max_profit([100, 150, 200, 50]) == 100\nassert get_max_profit([50, 100, 150, 200]) == 150\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 9\n### Properties\ncategory: program implementation\nlanguage: C++\ndifficulty: easy\nconcepts: I/O optimization, file redirection, preprocessor directive for local testing\n\n### Task", "fingerprint": null, "seed": "void c_p_c()\n{\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#ifndef ONLINE_JUDGE\n    freopen(\"/Users/ishan/Desktop/fuzzy-chainsaw-algo/input.txt\", \"r\", stdin);\n    freopen(\"/Users/ishan/Desktop/fuzzy-chainsaw-algo/output.txt\", \"w\", stdout);\n#endif\n}", "id": 202, "concepts": ["I/O optimization", "file redirection", "preprocessor directive for local testing"], "instruction": "Implement a C++ program that reads the contents of a text file line by line and outputs the lines to the console in reverse order. The program should efficiently handle large files without loading the entire file into memory. Consider using the preprocessor directive to enable local testing."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 3\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: timer function for automatic reconnection, flag for reconnection status, counter for reconnection attempts\n\n### Task", "fingerprint": null, "seed": "void loop()\n{\n  timer.run();\n  if (Blynk.connected()) {                                                    // If connected run as normal\n    Blynk.run();\n  } \n  else if (ReCnctFlag == 0) {                                                 // If NOT connected and not already trying to reconnect, set timer to try to reconnect in 30 seconds\n      blynkConnectionStatusForNotification = false;\n      ReCnctFlag = 1;                                                         // Set reconnection Flag\n      Serial.println(\"Starting reconnection timer in 30 seconds...\");\n      timer.setTimeout(30000L, []() {                                         // Lambda Reconnection Timer Function\n      ReCnctFlag = 0;                                                         // Reset reconnection Flag\n      ReCnctCount++;                                                          // Increment reconnection Counter\n      Serial.print(\"Attempting reconnection #\");\n      Serial.println(ReCnctCount);\n      Blynk.connect();                                                        // Try to reconnect to the server\n    });                                                                       // END Timer Function\n    }\n}", "id": 203, "concepts": ["timer function for automatic reconnection", "flag for reconnection status", "counter for reconnection attempts"], "instruction": "Implement a C++ function `reconnect` that attempts to re-establish a connection to a remote server. The function should accept a function `connect` that attempts to establish a connection, a `timeout` parameter representing the maximum time allowed for connection establishment, and an optional `max_attempts` parameter representing the maximum number of reconnection attempts. The function should return the result of the `connect` function upon successful connection.\n\nAdditionally, the function should handle any exceptions raised by the `connect` function and attempt to re-establish the connection if it has not reached the maximum number of attempts. If the connection cannot be established within the specified timeout, the function should raise a ConnectionError exception.\n\nHere is the implementation of the `reconnect` function:\n\n```cpp\nfrom time import time, sleep\nfrom typing import Callable, Any\n\nclass ConnectionError(Exception):\n    def __init__(self, message: str):\n        super().__init__(message)\n\ndef reconnect(connect: Callable[[], Any], timeout: int, max_attempts: int = 3) -> Any:\n    attempt = 1\n    start_time = time()\n\n    while attempt <= max_attempts:\n        try:\n            return connect()\n        except Exception as e:\n            if time() - start_time >= timeout:\n                raise ConnectionError(\"Connection timeout\") from e\n            sleep(1)\n            attempt += 1\n    raise ConnectionError(\"Maximum number of attempts reached\")\n```\n\nThe `reconnect` function takes a `connect` function as an argument, which is expected to attempt to establish a connection to a remote server. The function also accepts a `timeout` parameter representing the maximum time allowed for connection establishment, and an optional `max_attempts` parameter representing the maximum number of reconnection attempts.\n\nThe function maintains a `start_time` to track the time when the reconnection process begins, and an `attempt` counter to keep track of the current attempt number. The function then attempts to establish a connection using the `connect` function. If an exception is raised, it checks if the elapsed time since `start_time` is greater than or equal to the specified timeout. If so, it raises a `ConnectionError` with the message \"Connection timeout\".\n\nIf the elapsed time is less than the timeout, the function sleeps for 1 second before incrementing the `attempt` counter and trying to establish a connection again. If the `attempt` counter exceeds the specified `max_attempts`, the function raises a `ConnectionError` with the message \"Maximum number of attempts reached\".\n\nIf the connection is successfully established, the function returns the result of the `connect` function.\n\nTo test the `reconnect` function, you can mock the `connect` function to simulate connection failures. For example:\n\n```cpp\ndef connect():\n    pass\ndef mock_connect():\n    raise Exception(\"Connection failure\")\n\ntry:\n    reconnect(mock_connect, 10)\n    assert False, \"Expected ConnectionError not raised\"\nexcept ConnectionError as e:\n    assert str(e) == \"Connection timeout\"\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 2\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: function call sequence, linked list creation and management, layer creation\n\n### Task", "fingerprint": null, "seed": "void fpcM_Init(void) {\n    fpcLy_Create(&rootlayer, NULL, queue, 10);\n    fpcLn_Create();\n}", "id": 204, "concepts": ["function call sequence", "linked list creation and management", "layer creation"], "instruction": "Implement a function `create_layers(values)` to create a linked list of layers, where each layer is a linked list containing a single value. The function should sequentially call `create_layer(value)` for each value in `values` to build the linked list."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: enum parsing for protocol buffer, type safety, inline function definition\n\n### Task", "fingerprint": null, "seed": "inline bool e_game_state_Parse(\n    const ::std::string& name, e_game_state* value) {\n  return ::google::protobuf::internal::ParseNamedEnum<e_game_state>(\n    e_game_state_descriptor(), name, value);\n}", "id": 205, "concepts": ["enum parsing for protocol buffer", "type safety", "inline function definition"], "instruction": "Implement a C++ function `parse_proto_enum` to parse a string representation of a protocol buffer enum value. The function should take two arguments: `enum_type`, a string representing the type of the enum, and `value`, a string representing the value of the enum. The function should return an integer representing the enum value. The function should raise an `invalid_argument` exception if the enum type or value is invalid.\n\nHere's an example:\n\n```cpp\nassert parse_proto_enum(\"Color\", \"RED\") == 0\nassert parse_proto_enum(\"Color\", \"GREEN\") == 1\nassert parse_proto_enum(\"Color\", \"BLUE\") == 2\ntry:\n    parse_proto_enum(\"Color\", \"YELLOW\")\nexcept invalid_argument:\n    pass\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: hard\nconcepts: http request handling, http status code handling, firmware update process\n\n### Task", "fingerprint": null, "seed": "void checkforupdate()\n{ \n  Serial.println( \"OTA Update Request Received\" );\n  Serial.print( \"Firmware URL: \" );\n  Serial.println( FIRMWARE_URL );\n\n  HTTPClient httpClient;\n  httpClient.begin( FIRMWARE_URL );\n  int httpCode = httpClient.GET();\n  if( httpCode == 200 ) {\n  Serial.println( \"Update file found, starting update\" );\n  Blynk.virtualWrite(VPIN_UPDATE_LED, 1023);\n  \n  t_httpUpdate_return ret = ESPhttpUpdate.update( FIRMWARE_URL );\n   \n  switch(ret) {\n    case HTTP_UPDATE_FAILED:\n        Serial.println(\"[update] Update failed.\");\n        break;\n    case HTTP_UPDATE_NO_UPDATES:\n        Serial.println(\"[update] Update no Update.\");\n        break;\n    case HTTP_UPDATE_OK:\n        Serial.println(\"[update] Update ok.\"); // may not called we reboot the ESP\n        break;\n              }\n           }  else {\n    Serial.print( \"Firmware check failed, got HTTP response code \" );\n    Serial.println( httpCode );\n           }\n  httpClient.end();\n  \n  Blynk.virtualWrite(VPIN_UPDATE_LED, 0);\n  Blynk.virtualWrite(VPIN_FIRMWARE_UPDATE, HIGH);  \n}", "id": 206, "concepts": ["http request handling", "http status code handling", "firmware update process"], "instruction": "Implement a C++ function `handle_firmware_update_request(request)` to handle HTTP requests for firmware updates. The function should accept a `request` object containing the relevant information, such as the HTTP method, path, and headers. The function should return a response with the appropriate status code and content. If the request is a GET request to the `/update` path, the function should return a response with status code 200 and the firmware update file. If the request is a POST request to the `/update` path, the function should process the firmware update and return a response with status code 200. If the request is a GET request to the `/version` path, the function should return a response with status code 200 and the current firmware version. If the request is a GET request to a different path, the function should return a response with status code 404. If the request is a POST request to a different path, the function should return a response with status code 405. If the request is a different HTTP method, the function should return a response with status code 405."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 5\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: coin identification using counterbalance, integer array representation of coin status, loop and function decomposition\n\n### Task", "fingerprint": null, "seed": "int main()\r\n{\r\n\tint i, j, n, fake;\r\n\tfor (cin >> n; n; n--)\r\n\t{\r\n\t\tfor (i = 0; i < COIN; i++)\r\n\t\t\tox[i] = coin[i] = 0;\r\n\t\tfor (i = 0; i < TIME; i++)\r\n\t\t{\r\n\t\t\tfor (j = 0; j < 3; j++)\r\n\t\t\t\tcin >> s[j];\r\n\t\t\tif (s[2] == \"even\")\r\n\t\t\t\tsetStatus(0, 1);\r\n\t\t\telse if (s[2] == \"up\")\r\n\t\t\t\tsetCoin(1);\r\n\t\t\telse setCoin(-1);\r\n\t\t}\r\n\t\tfor (i = fake = 0; i < COIN; i++)\r\n\t\t{\r\n\t\t\tif (abs(coin[i]) > abs(coin[fake])) fake = i;\r\n\t\t\telse ox[i] = 1;\r\n\t\t}\r\n\t\tprintf(\"%c is the counterfeit coin and it is %s.\\n\", fake + 'A', ((coin[fake] > 0) ? \"light\" : \"heavy\"));\r\n\t}\r\n}", "id": 207, "concepts": ["coin identification using counterbalance", "integer array representation of coin status", "loop and function decomposition"], "instruction": "Given a set of coins, use a counterbalance to identify the heavier coin. Each side of the counterbalance can hold a coin, and the scale is accurate. The problem is to identify the heavier coin from a set of $n$ coins, given that exactly one coin is heavier than the rest.\n\nImplement a C++ function `find_heavier_coin(n)` to find the heavier coin using the counterbalance. The function should take an integer $n$ as an argument, representing the number of coins, and return the index of the heavier coin.\n\nThe function should satisfy the following assertions:\n\n```cpp\nassert find_heavier_coin(1) == 0\nassert find_heavier_coin(2) == 1\nassert find_heavier_coin(3) == 2\nassert find_heavier_coin(4) == 3\nassert find_heavier_coin(5) == 4\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 9\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: easy\nconcepts: conditional logic for relay switching, flag checks for voltage values, serial output for debugging\n\n### Task", "fingerprint": null, "seed": "void auto_mode()                                      // Function to check if auto mode is ON and all voltage value is greater than voltage cutoff value, then turn on 2 relays\n{    \n  if(auto_mode_state_1 == LOW && lowvoltageflag == false && highvoltageflag == false && phasefailureflag == false){  //checks if auto mode is ON and voltage values is greater than min value  - Motor 1\n    Serial.println(\"All condition is TRUE...swtiching on relay 1 now.\");    \n    digitalWrite(RELAY_PIN_1, LOW);                  // Turn on Relay 1         \n    Blynk.virtualWrite(VPIN_BUTTON_1, LOW);          // Update Blynk button status to ON    \n    Serial.println(\"RELAY 1 Turned ON\"); \n  }\n\n    if(auto_mode_state_2 == LOW && lowvoltageflag == false && highvoltageflag == false && phasefailureflag == false){  //checks if auto mode is ON and voltage values is greater than min value - Motor 2 \n    Serial.println(\"All condition is TRUE...swtiching on relay 2 now.\");    \n    digitalWrite(RELAY_PIN_2, LOW);                  // Turn on Relay 2         \n    Blynk.virtualWrite(VPIN_BUTTON_2, LOW);          // Update Blynk button status to ON    \n    Serial.println(\"RELAY 2 Turned ON\"); \n  }\n  \n}", "id": 208, "concepts": ["conditional logic for relay switching", "flag checks for voltage values", "serial output for debugging"], "instruction": "Design a C++ class `Relay` with the following properties:\n\n- Each relay has an on/off state.\n- Each relay has a voltage value between 0 and 24 V.\n- Each relay can be turned on or off using the `on()` and `off()` methods.\n\nAdditionally, the class should include the following methods:\n\n- `is_on()`: Returns whether the relay is on or off.\n- `get_voltage()`: Returns the current voltage value of the relay.\n- `set_voltage(voltage)`: Sets the voltage value of the relay.\n\nImplement the class with the above properties and methods."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 6\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: status updating based on given conditions, 2D array traversal, bit manipulation\n\n### Task", "fingerprint": null, "seed": "void setStatus(int Scoin, int Sox)\r\n{\r\n\tint i, j;\r\n\tfor (i = 0; i < 2; i++)\r\n\t\tfor (j = 0; j < s[i].size(); j++)\r\n\t\t{\r\n\t\t\tcoin[s[i][j] - 'A'] = Scoin;\r\n\t\t\tox[s[i][j] - 'A'] = Sox;\r\n\t\t}\r\n\treturn ;\r\n}", "id": 209, "concepts": ["status updating based on given conditions", "2D array traversal", "bit manipulation"], "instruction": "Implement a C++ function that simulates a 2D soccer game with a team of 5 players on each side. The function should take a 2D array representing the game state and return the updated game state after each status update. The game state should be updated based on the following rules:\n\n- If a player is on the field, their status should be updated to \"In\"\n- If a player is off the field, their status should be updated to \"Out\"\n- If a player is injured, their status should be updated to \"Injured\"\n- If a player is playing, their status should be updated to \"Playing\"\n\nThe function should also handle bit manipulation to update the game state."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 4\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: arithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n### Task\nCreate a C++ function to format a file size in bytes into a human-readable string representation, using 'bytes', 'KB' (kilobytes), 'MB' (megabytes), 'GB' (gigabytes), or 'TB' (terabytes) units. The output should be rounded to one decimal place and follow the format: \"{X.Y}{Unit}\", where \"Unit\" is the appropriate size unit and \"X.Y\" is the rounded size. For example, `format_size(1024 * 512)` should return `'512.0KB'`, and `format_size(1024**2 - 1)` should return `'1024.0KB'`.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: VCC is an object that is used to update the value of the VCC. It is likely that the VCC is a voltage that is used to power the system. The update() method is likely used to update the value of the VCC to ensure that it is accurate and up-to-date.\n\n### Task", "fingerprint": null, "seed": "void loop(){\n  //update VCC\n  VCC.update(); \n\n}", "id": 211, "concepts": ["VCC is an object that is used to update the value of the VCC. It is likely that the VCC is a voltage that is used to power the system. The update() method is likely used to update the value of the VCC to ensure that it is accurate and up-to-date."], "instruction": "Implement a C++ function `update_vcc` that takes a `VCC` object and an integer `new_value` as arguments. The function should update the value of the `VCC` to `new_value` if `new_value` is greater than the current value of the `VCC`. The function should return `true` if the update was successful and `false` otherwise."}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: data partitioning and slicing, learning from input-output examples\n\n### Task\nConstruct a C++ function `create_folds(data, count)` to create a list of folds from the given data, where each fold is a subsequence of the original data. The length of each fold should be approximately equal with at most a difference of 1. The function should satisfy the following assertions:\n\n```cpp\nassert create_folds(range(12), 2) == [range(0, 6), range(6, 12)]\nassert create_folds(range(8), 2) == [range(0, 4), range(4, 8)]\nassert create_folds(range(25), -5) == []\nassert create_folds(range(6), 2) == [range(0, 3), range(3, 6)]\n```\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 7\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: discrete master property update logic, mixer handle value and strength evaluation, float4 value assignment\n\n### Task", "fingerprint": null, "seed": "void DiscreteMasterProperty__float4__OnComplete(DiscreteMasterProperty__float4* __this)\n{\n    ::app::Uno::Float4 nv = __this->RestValue();\n    float str = 0.5f;\n\n    for (::app::Uno::Collections::List1_Enumerator__Fuse_Animations_MixerHandle_float4_ enum_123 = ::uPtr< ::app::Uno::Collections::List__Fuse_Animations_MixerHandle_float4_*>(__this->Handles)->GetEnumerator(); enum_123.MoveNext(); )\n    {\n        ::app::Fuse::Animations::MixerHandle__float4* v = enum_123.Current();\n\n        if (::uPtr< ::app::Fuse::Animations::MixerHandle__float4*>(v)->HasValue() && (::uPtr< ::app::Fuse::Animations::MixerHandle__float4*>(v)->Strength > str))\n        {\n            nv = ::uPtr< ::app::Fuse::Animations::MixerHandle__float4*>(v)->Value;\n            str = v->Strength;\n        }\n    }\n\n    ::uPtr< ::app::Uno::UX::Property__float4*>(__this->Property)->Set(nv, (::uObject*)__this);\n}", "id": 212, "concepts": ["discrete master property update logic", "mixer handle value and strength evaluation", "float4 value assignment"], "instruction": "Implement a C++ function that updates the value of a float4 using the discrete master property of a mixer handle. The input parameters are as follows:\n\n- `value`: the value of the float4 to be updated\n- `strength`: the strength of the mixer handle, which determines how much the updated value should deviate from the original value\n- `min_value`: the minimum value of the float4\n- `max_value`: the maximum value of the float4\n\nThe updated value should be calculated as `value * (1.0 - strength) + min_value * strength` if the value is less than the minimum value, `value * (1.0 - strength) + max_value * strength` if the value is greater than the maximum value, or `value` otherwise.\n\nHere's an example implementation of the function in C++:\n\n```cpp\nfloat4 update_value(float4 value, float strength, float4 min_value, float4 max_value) {\n    if (value < min_value) {\n        return value * (1.0f - strength) + min_value * strength;\n    } else if (value > max_value) {\n        return value * (1.0f - strength) + max_value * strength;\n    } else {\n        return value;\n    }\n}\n```"}
{"prompt": "Create a series of independent coding tasks that are original, distinct, diverse, and high-quality, fostering logical thinking. Each task must adhere to specified properties:\n\n- category: the type of task (e.g., function implementation, class implementation, or program implementation)\n- language: the programming language to be used\n- difficulty: the complexity level of the task (e.g., easy, medium, or hard)\n- concepts: fundamental principles and techniques the task is designed to incorporate, which developers must understand to effectively solve the task\n\nDesign the tasks so that the relevant concepts emerge naturally as the most appropriate solutions, without explicitly mentioning that a particular concept should be used.\n\n## Example 1\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: 5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n### Task\nCreate a C++ function to encode an integer into a sequence of encoded characters, where each character represents a 5-bit chunk of the integer. The ASCII value of each chunk character is formed by adding 63 to the 5-bit chunk's value. For all chunks except the last one, set the 6th bit to 1 to indicate continuation. Employ bitwise operations for this encoding process.\n\n## Example 2\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: decoding compressed data, binary tree traversal, byte array processing\n\n### Task\nWrite a C++ function `huffman_decompress` that takes two arguments: `compressed_data`, a byte array of 0/1 sequence representing Huffman compressed data, and `huffman_tree`, a Huffman tree that stores the actual data (each leaf is associated with a character). The function should return the original uncompressed data as `bytes`. Define the `HuffmanNode` class yourself as a general tree structure with a `children` list.\n\n## Example 3\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: regular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n### Task\nCreate a C++ function that converts a string representation of a time duration into its total number of seconds.\nThe input string should follow a format that includes a numeric part followed by a time unit suffix without any spaces between.\nThe time unit can be seconds in the form of 's' or 'sec', minutes in the form of 'm' or 'min', hours in the form of 'h' or 'hour', and days in the form of 'd' or 'day' (units are in small case).\nIf the input format is invalid, the function should raise a ValueError.\n\nFor example, the function should pass the following assertions:\n\n```cpp\nassert parse_duration('15s') == 15\nassert parse_duration('2min') == 120\nassert parse_duration('1h') == 3600\nassert parse_duration('1d') == 86400\ntry:\n    parse_duration('30')\nexcept ValueError as e:\n    pass\n```\n\n## Example 4\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: list comprehension, unique string creation, precondition checking for type validation\n\n### Task\nDesign a C++ function to encode a list of strings into a unique list with the same length, order, and meaning. The new list is formed by appending asterisks (*) to duplicate strings. For instance, given ['a', 'a', 'b', 'a', 'c'], the function should return ['a', 'a*', 'b', 'a**', 'c'], while for ['a', 'b', 'c'] it should return ['a', 'b', 'c'] without any changes. Write assertions to ensure the input is a list of strings.\n\nSolve the problem in two lines of code, one for the precondition check and the other for the main logic.\n\n## Example 5\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: special formula implementation, odd and even number handling, function composition\n\n### Task\nHere are two special formulas:\n\n$$\nf_1(a, b) = (a + 1) \\cdot (b + 1) - 1\n$$\n\n$$\nf_2(k) = \\begin{cases}\n    \\frac{(k + 1)^2}{2} + k + 1 & \\text{if } k \\text{ is odd} \\\\\n    \\frac{k^2}{2} + 2k + 1 & \\text{if } k \\text{ is even}\n\\end{cases}\n$$\n\nWrite a C++ function to return $f_2(f_1(a, b))$ for given `a` and `b`.\n\n## Example 6\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: easy\nconcepts: insertion point for a sorted array, optimized time complexity\n\n### Task\nDesign a C++ function that takes a sorted array and a target value, and return a valid index where target can be inserted to maintain the array's sorted order. Optimize the function to run in logarithmic time complexity.\n\nFor example, given `array = [1, 3, 5, 5, 6]` and `target = 5`, the function should return either 2 or 3 because 5 presents at both indices 2 and 3.\n\n## Example 7\n### Properties\ncategory: class implementation\nlanguage: C++\ndifficulty: medium\nconcepts: prime number memoization, n-th prime calculation, efficiency in prime checks\n\n### Task\nImplement a C++ class with a method `find_nth_prime_memoized(n)` that returns the nth prime number, where n is a positive integer. Utilize memoization to store already found prime numbers in a list within the class to avoid recalculating primes for multiple method calls. Ensure the method efficiently updates and references this list to find new primes as needed. Additionally, enhance performance by avoiding unnecessary prime checks.\n\n## Example 8\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: bitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n### Task\nDevelop a C++ function `ceil_divide_without_div` that computes the ceiling of `n / 2**b` without using division, floating-point operations, built-in functions like `math.ceil`, or converting it into computing the floor. Instead, use bit manipulation to achieve the result. You write assertions to ensure both `n` and `b` are non-negative integers.\n\n## Example 9\n### Properties\ncategory: function implementation\nlanguage: C++\ndifficulty: medium\nconcepts: linked list traversal, insertion, recursion, backtracking\n\n### Task", "fingerprint": null, "seed": "void p14(Node *h, char *c, int l, int s){\n\tNode *p = h;\n\tNode *pn[15];\n\twhile(p){\n\t\tint i;\n\t\tfor(i = 0; i < l; i ++){\n\t\t\tif( i == 0) pn[i] = p->next;\n\t\t\telse pn[i] = pn[i-1]->next;\n\n\t\t\tif(pn[i] == NULL || pn[i]->c != c[i]){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(i != l) {\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n//\t\tcout<<\"p14\"<<endl;\n\t\tNode *node = new Node(' ');\n\t\tpn[s] = insert(pn[s],node);\n\t\tp = pn[l-1];\n\t}\n}", "id": 213, "concepts": ["linked list traversal", "insertion", "recursion", "backtracking"], "instruction": "Implement a C++ function that takes a linked list and a value, and insert a new node with the given value after the node with the smallest value in the linked list. The function must handle the case where the smallest value is the last node in the list.\n\nThe linked list is represented by a `Node` class:\n\n```cpp\nclass Node {\npublic:\n    int value;\n    Node* next;\n\n    Node(int value, Node* next = nullptr) : value(value), next(next) {}\n};\n```\n\nFor example, given the linked list `1 -> 3 -> 5 -> 2 -> 4` and the value `6`, the function should insert a new node with value `6` after the node with value `2`. The resulting linked list should be `1 -> 3 -> 5 -> 2 -> 6 -> 4`."}
