{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 3\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 5\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 6\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 8\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 9\n### Snippet\nint main() {\n\t// your code goes here\nstring s1,s2;\ncin>>s1>>s2;\nint m,n;\nm=s1.length();\nn=s2.length();\ncout<<editDistance(s1,s2,m,n);\n\treturn 0;\n}\n\n### Concepts", "fingerprint": null, "seed": "int main() {\n\t// your code goes here\nstring s1,s2;\ncin>>s1>>s2;\nint m,n;\nm=s1.length();\nn=s2.length();\ncout<<editDistance(s1,s2,m,n);\n\treturn 0;\n}", "id": 0, "concepts": ["dynamic programming", "recursion", "memoization"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 4\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 6\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 8\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 9\n### Snippet\nvoid read_sensors() { \n    num_hits = 0;   // global variable\n    num_hits += digitalRead(radar);\n    num_hits += digitalRead(pir1); \n    num_hits += digitalRead(pir2); \n    digitalWrite (led, (num_hits==0));  // active low\n}\n\n### Concepts", "fingerprint": null, "seed": "void read_sensors() { \n    num_hits = 0;   // global variable\n    num_hits += digitalRead(radar);\n    num_hits += digitalRead(pir1); \n    num_hits += digitalRead(pir2); \n    digitalWrite (led, (num_hits==0));  // active low\n}", "id": 1, "concepts": ["sensor reading and processing", "software design for efficient and accurate detection"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 6\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 8\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 9\n### Snippet\ninline double getBilinearInterpolatedValue(const Mat &img, const Vector2d &pt)\n{\n    uchar *d = &img.data[int(pt(1, 0)) * img.step + int(pt(0, 0))];\n    double xx = pt(0, 0) - floor(pt(0, 0));\n    double yy = pt(1, 0) - floor(pt(1, 0));\n    return ((1 - xx) * (1 - yy) * double(d[0]) +\n            xx * (1 - yy) * double(d[1]) +\n            (1 - xx) * yy * double(d[img.step]) +\n            xx * yy * double(d[img.step + 1])) / 255.0;\n}\n\n### Concepts", "fingerprint": null, "seed": "inline double getBilinearInterpolatedValue(const Mat &img, const Vector2d &pt)\n{\n    uchar *d = &img.data[int(pt(1, 0)) * img.step + int(pt(0, 0))];\n    double xx = pt(0, 0) - floor(pt(0, 0));\n    double yy = pt(1, 0) - floor(pt(1, 0));\n    return ((1 - xx) * (1 - yy) * double(d[0]) +\n            xx * (1 - yy) * double(d[1]) +\n            (1 - xx) * yy * double(d[img.step]) +\n            xx * yy * double(d[img.step + 1])) / 255.0;\n}", "id": 2, "concepts": ["bilinear interpolation", "2D image processing", "data type handling"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 4\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 5\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 9\n### Snippet\nint main() {\n\tfloat acum;\n\tfloat dato;\n\tint i;\n\tint n;\n\tfloat prom;\n\tcout << \"Ingrese la cantidad de alumnos:\" << endl;\n\tcin >> n;\n\tacum = 0;\n\tfor (i=1;i<=n;i++) {\n\t\tcout << \"Ingrese la edad \" << i << \":\" << endl;\n\t\tcin >> dato;\n\t\tacum = acum+dato;\n\t}\n\tprom = acum/n;\n\tcout << \"El promedio de las edades del grupo de \" << n << \" alumnos es: \" << prom << endl;\n\treturn 0;\n}\n\n### Concepts", "fingerprint": null, "seed": "int main() {\n\tfloat acum;\n\tfloat dato;\n\tint i;\n\tint n;\n\tfloat prom;\n\tcout << \"Ingrese la cantidad de alumnos:\" << endl;\n\tcin >> n;\n\tacum = 0;\n\tfor (i=1;i<=n;i++) {\n\t\tcout << \"Ingrese la edad \" << i << \":\" << endl;\n\t\tcin >> dato;\n\t\tacum = acum+dato;\n\t}\n\tprom = acum/n;\n\tcout << \"El promedio de las edades del grupo de \" << n << \" alumnos es: \" << prom << endl;\n\treturn 0;\n}", "id": 3, "concepts": ["variable declaration", "user input with `cin`", "arithmetic operations", "for loop for iteration"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 2\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 3\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 4\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 5\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 8\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 9\n### Snippet\nint main(){\n\tstring N;\n\tcin>>N;\n\tint d[10]={0};\n\tint len=N.length();\n\tfor(int i=0;i<len;i++)\n\t\td[N[i]-'0']++;\n\t\n\tfor(int i=0;i<10;i++){\n\t\tif(d[i]!=0)\n\t\t\tcout<<i<<\":\"<<d[i]<<endl;\n\t}\n\treturn 0;\n}\n\n### Concepts", "fingerprint": null, "seed": "int main(){\n\tstring N;\n\tcin>>N;\n\tint d[10]={0};\n\tint len=N.length();\n\tfor(int i=0;i<len;i++)\n\t\td[N[i]-'0']++;\n\t\n\tfor(int i=0;i<10;i++){\n\t\tif(d[i]!=0)\n\t\t\tcout<<i<<\":\"<<d[i]<<endl;\n\t}\n\treturn 0;\n}", "id": 4, "concepts": ["string processing", "character counting", "frequency table construction"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 2\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 4\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 5\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 6\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 9\n### Snippet\ninline bool e_server_msg_type_Parse(\n    const ::std::string& name, e_server_msg_type* value) {\n  return ::google::protobuf::internal::ParseNamedEnum<e_server_msg_type>(\n    e_server_msg_type_descriptor(), name, value);\n}\n\n### Concepts", "fingerprint": null, "seed": "inline bool e_server_msg_type_Parse(\n    const ::std::string& name, e_server_msg_type* value) {\n  return ::google::protobuf::internal::ParseNamedEnum<e_server_msg_type>(\n    e_server_msg_type_descriptor(), name, value);\n}", "id": 5, "concepts": ["regular expression for pattern matching", "dictionary lookup for suffix mapping", "error handling with exceptions"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 2\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 4\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 6\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 9\n### Snippet\nvoid add(int u,int v,int w){e[++ecnt]={v,w,head[u]};head[u]=ecnt;}\n\n### Concepts", "fingerprint": null, "seed": "void add(int u,int v,int w){e[++ecnt]={v,w,head[u]};head[u]=ecnt;}", "id": 6, "concepts": ["graph representation with adjacency list", "edge addition", "edge structure definition"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 4\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 5\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 6\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 8\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 9\n### Snippet\nint main()\n{\n    int s;\n\tfor(int a=1; a<=100;a=a+2)\n\t{\n\t\t\ts=s+a;\n\t\t\t\n\t}\tprintf(\"Tong so le den so 100 la: %d \\n\",s);\n\treturn 0;\n  \n\n}\n\n### Concepts", "fingerprint": null, "seed": "int main()\n{\n    int s;\n\tfor(int a=1; a<=100;a=a+2)\n\t{\n\t\t\ts=s+a;\n\t\t\t\n\t}\tprintf(\"Tong so le den so 100 la: %d \\n\",s);\n\treturn 0;\n  \n\n}", "id": 7, "concepts": ["summation of odd numbers from 1 to 100", "loop structure", "variable initialization and incrementation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 4\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 6\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 8\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 9\n### Snippet\nvoid low_volt_alert()                              // Function to send blynk push notifiction if low voltage is detected\n{\n  if(lowvoltagenotificationflag == true && underVoltageAlertOnOffState == 0 && blynkConnectionStatusForNotification == true){ \n    Serial.println(\"Sending Under voltage Blynk notification\");\n    Blynk.notify(\"Low Voltage Detected!\");\n    lowvoltagenotificationflag = false;\n  }\n}\n\n### Concepts", "fingerprint": null, "seed": "void low_volt_alert()                              // Function to send blynk push notifiction if low voltage is detected\n{\n  if(lowvoltagenotificationflag == true && underVoltageAlertOnOffState == 0 && blynkConnectionStatusForNotification == true){ \n    Serial.println(\"Sending Under voltage Blynk notification\");\n    Blynk.notify(\"Low Voltage Detected!\");\n    lowvoltagenotificationflag = false;\n  }\n}", "id": 8, "concepts": ["low voltage detection", "blynk push notification", "flag-based notification control"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 5\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 6\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 8\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 9\n### Snippet\nvoid setup(){\n  //setup all VCC main settings\n  VCC.setup();\n\n}\n\n### Concepts", "fingerprint": null, "seed": "void setup(){\n  //setup all VCC main settings\n  VCC.setup();\n\n}", "id": 9, "concepts": ["setup function for initialization", "library usage", "VCC object creation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 3\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 4\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 7\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 9\n### Snippet\nstatic int8_t CDC_Control_FS(uint8_t cmd, uint8_t* pbuf, uint16_t length)\r\n{\r\n    /* USER CODE BEGIN 5 */\r\n    switch (cmd)\r\n    {\r\n    case CDC_SEND_ENCAPSULATED_COMMAND:\r\n\r\n        break;\r\n\r\n    case CDC_GET_ENCAPSULATED_RESPONSE:\r\n\r\n        break;\r\n\r\n    case CDC_SET_COMM_FEATURE:\r\n\r\n        break;\r\n\r\n    case CDC_GET_COMM_FEATURE:\r\n\r\n        break;\r\n\r\n    case CDC_CLEAR_COMM_FEATURE:\r\n\r\n        break;\r\n\r\n        /*******************************************************************************/\r\n        /* Line Coding Structure                                                       */\r\n        /*-----------------------------------------------------------------------------*/\r\n        /* Offset | Field       | Size | Value  | Description                          */\r\n        /* 0      | dwDTERate   |   4  | Number |Data terminal rate, in bits per second*/\r\n        /* 4      | bCharFormat |   1  | Number | Stop bits                            */\r\n        /*                                        0 - 1 Stop bit                       */\r\n        /*                                        1 - 1.5 Stop bits                    */\r\n        /*                                        2 - 2 Stop bits                      */\r\n        /* 5      | bParityType |  1   | Number | Parity                               */\r\n        /*                                        0 - None                             */\r\n        /*                                        1 - Odd                              */\r\n        /*                                        2 - Even                             */\r\n        /*                                        3 - Mark                             */\r\n        /*                                        4 - Space                            */\r\n        /* 6      | bDataBits  |   1   | Number Data bits (5, 6, 7, 8 or 16).          */\r\n        /*******************************************************************************/\r\n    case CDC_SET_LINE_CODING:\r\n\r\n        break;\r\n\r\n    case CDC_GET_LINE_CODING:\r\n\r\n        break;\r\n\r\n    case CDC_SET_CONTROL_LINE_STATE:\r\n\r\n        break;\r\n\r\n    case CDC_SEND_BREAK:\r\n\r\n        break;\r\n\r\n    default:\r\n        break;\r\n    }\r\n\r\n    return (USBD_OK);\r\n    /* USER CODE END 5 */\r\n}\n\n### Concepts", "fingerprint": null, "seed": "static int8_t CDC_Control_FS(uint8_t cmd, uint8_t* pbuf, uint16_t length)\r\n{\r\n    /* USER CODE BEGIN 5 */\r\n    switch (cmd)\r\n    {\r\n    case CDC_SEND_ENCAPSULATED_COMMAND:\r\n\r\n        break;\r\n\r\n    case CDC_GET_ENCAPSULATED_RESPONSE:\r\n\r\n        break;\r\n\r\n    case CDC_SET_COMM_FEATURE:\r\n\r\n        break;\r\n\r\n    case CDC_GET_COMM_FEATURE:\r\n\r\n        break;\r\n\r\n    case CDC_CLEAR_COMM_FEATURE:\r\n\r\n        break;\r\n\r\n        /*******************************************************************************/\r\n        /* Line Coding Structure                                                       */\r\n        /*-----------------------------------------------------------------------------*/\r\n        /* Offset | Field       | Size | Value  | Description                          */\r\n        /* 0      | dwDTERate   |   4  | Number |Data terminal rate, in bits per second*/\r\n        /* 4      | bCharFormat |   1  | Number | Stop bits                            */\r\n        /*                                        0 - 1 Stop bit                       */\r\n        /*                                        1 - 1.5 Stop bits                    */\r\n        /*                                        2 - 2 Stop bits                      */\r\n        /* 5      | bParityType |  1   | Number | Parity                               */\r\n        /*                                        0 - None                             */\r\n        /*                                        1 - Odd                              */\r\n        /*                                        2 - Even                             */\r\n        /*                                        3 - Mark                             */\r\n        /*                                        4 - Space                            */\r\n        /* 6      | bDataBits  |   1   | Number Data bits (5, 6, 7, 8 or 16).          */\r\n        /*******************************************************************************/\r\n    case CDC_SET_LINE_CODING:\r\n\r\n        break;\r\n\r\n    case CDC_GET_LINE_CODING:\r\n\r\n        break;\r\n\r\n    case CDC_SET_CONTROL_LINE_STATE:\r\n\r\n        break;\r\n\r\n    case CDC_SEND_BREAK:\r\n\r\n        break;\r\n\r\n    default:\r\n        break;\r\n    }\r\n\r\n    return (USBD_OK);\r\n    /* USER CODE END 5 */\r\n}", "id": 10, "concepts": ["switch-case statement for command processing", "bitmask operations for flag management", "error handling and return"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 3\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 5\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 9\n### Snippet\nbool cmp(const eg& e1,const eg&e2)\n{\n    return e1.v<e2.v;\n}\n\n### Concepts", "fingerprint": null, "seed": "bool cmp(const eg& e1,const eg&e2)\n{\n    return e1.v<e2.v;\n}", "id": 11, "concepts": ["comparator function for sorting", "comparison-based programming"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 2\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 4\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 6\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 8\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 9\n### Snippet\nvoid fpcM_Execute(void* pProc) {\n    fpcEx_Execute((base_process_class*)pProc);\n}\n\n### Concepts", "fingerprint": null, "seed": "void fpcM_Execute(void* pProc) {\n    fpcEx_Execute((base_process_class*)pProc);\n}", "id": 12, "concepts": ["function pointer casting", "function call with arguments"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 3\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 4\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 6\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 9\n### Snippet\nvoid loop() {\n        // The transmitter sends in this example the signal A90 (hex. dezimal form) in the encoding \"RC5\"\n        // It will be transmitted 3 times after that it will make a 5 second break\n    for (int i = 0; i < 3; i++) {\n        // irsend.sendRC5(0xA90, 12); // [0xA90] signal | [12] Bit-length signal (hex A90=1010 1001 0000)\n        irsend.sendSAMSUNG(0xE0E0F00F,32); // Parametros: Tecla MUTE sacada del receptor, numero de bits del codigo de Samsung\n        delay(40);\n    }\n    delay(5000); // 5 second break between the sending impulses\n}\n\n### Concepts", "fingerprint": null, "seed": "void loop() {\n        // The transmitter sends in this example the signal A90 (hex. dezimal form) in the encoding \"RC5\"\n        // It will be transmitted 3 times after that it will make a 5 second break\n    for (int i = 0; i < 3; i++) {\n        // irsend.sendRC5(0xA90, 12); // [0xA90] signal | [12] Bit-length signal (hex A90=1010 1001 0000)\n        irsend.sendSAMSUNG(0xE0E0F00F,32); // Parametros: Tecla MUTE sacada del receptor, numero de bits del codigo de Samsung\n        delay(40);\n    }\n    delay(5000); // 5 second break between the sending impulses\n}", "id": 13, "concepts": ["IR signal encoding", "remote control communication", "bit-length specification"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 2\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 4\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 7\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 8\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 9\n### Snippet\nvoid Exact_Source(float *b, int Nx) \n{ \n\tint i,j; \n\tfloat x, y, h; \n\th = 1.0/(Nx+1); \n\t#pragma acc parallel loop gang present(b) \n\tfor(i=0;i<Nx;++i) \n\t{ \n\t\tx = (i+1)*h; \n\t\t#pragma acc loop vector \n\t\tfor(j=0;j<Nx;++j) \n\t\t{ \n\t\t\t//k = j + i*(N-1); \n\t\t\ty = (j+1)*h; \n\t\t\tb[Nx*i+j] = -(1.0+4.0)*h*h*M_PI*M_PI*sin(M_PI*x)*sin(2*M_PI*y); \n\t\t} \n\t} \n}\n\n### Concepts", "fingerprint": null, "seed": "void Exact_Source(float *b, int Nx) \n{ \n\tint i,j; \n\tfloat x, y, h; \n\th = 1.0/(Nx+1); \n\t#pragma acc parallel loop gang present(b) \n\tfor(i=0;i<Nx;++i) \n\t{ \n\t\tx = (i+1)*h; \n\t\t#pragma acc loop vector \n\t\tfor(j=0;j<Nx;++j) \n\t\t{ \n\t\t\t//k = j + i*(N-1); \n\t\t\ty = (j+1)*h; \n\t\t\tb[Nx*i+j] = -(1.0+4.0)*h*h*M_PI*M_PI*sin(M_PI*x)*sin(2*M_PI*y); \n\t\t} \n\t} \n}", "id": 14, "concepts": ["computational physics simulation", "two-dimensional array handling", "vectorization with OpenMP"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 2\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 3\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 8\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 9\n### Snippet\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\n\tcin >> m >> n >> h; totalnum = m * n * h;\n\tfor (int k = 1; k <= h; k++) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t\tcin >> map1[i][j][k];\n\t\t\t\tif (map1[i][j][k] == '1') {\n\t\t\t\t\tq.push({ i,j,k });\n\t\t\t\t\ttomato++;\n\t\t\t\t}\n\t\t\t\telse if (map1[i][j][k] == '-') {\n\t\t\t\t\tchar s;\n\t\t\t\t\tcin >> s;\n\t\t\t\t\ttotalnum--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile (!q.empty()) {\n\t\tbool flag = true;\n\t\tint qs = q.size();\n\t\tcnt++;\n\t\twhile (qs--) {\n\t\t\tint x = q.front().x;\n\t\t\tint y = q.front().y;\n\t\t\tint z = q.front().z;\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\tint nx = x + dr[i];\n\t\t\t\tint ny = y + dc[i];\n\t\t\t\tint nz = z + dz[i];\n\t\t\t\tif (nx <= 0 || nx > n || ny <= 0 || ny > m || nz <= 0 || nz > h) continue;\n\n\t\t\t\tif (map1[nx][ny][nz] == '0') {\n\t\t\t\t\ttomato++;\n\t\t\t\t\tmap1[nx][ny][nz] = '1';\n\t\t\t\t\tq.push({ nx,ny, nz });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (totalnum != tomato) {\n\t\tcout << \"-1\\n\";\n\t\treturn 0;\n\t}\n\tcout << cnt << '\\n';\n\treturn 0;\n}\n\n### Concepts", "fingerprint": null, "seed": "int main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\n\tcin >> m >> n >> h; totalnum = m * n * h;\n\tfor (int k = 1; k <= h; k++) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t\tcin >> map1[i][j][k];\n\t\t\t\tif (map1[i][j][k] == '1') {\n\t\t\t\t\tq.push({ i,j,k });\n\t\t\t\t\ttomato++;\n\t\t\t\t}\n\t\t\t\telse if (map1[i][j][k] == '-') {\n\t\t\t\t\tchar s;\n\t\t\t\t\tcin >> s;\n\t\t\t\t\ttotalnum--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\twhile (!q.empty()) {\n\t\tbool flag = true;\n\t\tint qs = q.size();\n\t\tcnt++;\n\t\twhile (qs--) {\n\t\t\tint x = q.front().x;\n\t\t\tint y = q.front().y;\n\t\t\tint z = q.front().z;\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\tint nx = x + dr[i];\n\t\t\t\tint ny = y + dc[i];\n\t\t\t\tint nz = z + dz[i];\n\t\t\t\tif (nx <= 0 || nx > n || ny <= 0 || ny > m || nz <= 0 || nz > h) continue;\n\n\t\t\t\tif (map1[nx][ny][nz] == '0') {\n\t\t\t\t\ttomato++;\n\t\t\t\t\tmap1[nx][ny][nz] = '1';\n\t\t\t\t\tq.push({ nx,ny, nz });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (totalnum != tomato) {\n\t\tcout << \"-1\\n\";\n\t\treturn 0;\n\t}\n\tcout << cnt << '\\n';\n\treturn 0;\n}", "id": 15, "concepts": ["bfs implementation", "3-dimensional matrix traversal", "queue usage for level traversal"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 4\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 6\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 8\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 9\n### Snippet\nvoid p3(Node *h){\n\tNode *p = h;\n\twhile(p){\n\t\tNode *pn = p->next;\n\t\tif(pn == NULL || pn->c != '.') {\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tNode *pnn = pn->next;\n\t\tif(pnn == NULL || pnn->c != '.') {\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tNode *pnnn = pnn->next;\n\t\tif(pnnn == NULL || pnnn->c != '.') {\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n//\t\tcout<<\"p3\"<<endl;\n\t\tNode *node;\n\t\tnode = new Node(' ');\n\t\tp = insert(p,node);\n\t\tnode = new Node(' ');\n\t\tpnnn = insert(pnnn,node);\n\t\tp = pnnn;\n\t}\n}\n\n### Concepts", "fingerprint": null, "seed": "void p3(Node *h){\n\tNode *p = h;\n\twhile(p){\n\t\tNode *pn = p->next;\n\t\tif(pn == NULL || pn->c != '.') {\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tNode *pnn = pn->next;\n\t\tif(pnn == NULL || pnn->c != '.') {\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tNode *pnnn = pnn->next;\n\t\tif(pnnn == NULL || pnnn->c != '.') {\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n//\t\tcout<<\"p3\"<<endl;\n\t\tNode *node;\n\t\tnode = new Node(' ');\n\t\tp = insert(p,node);\n\t\tnode = new Node(' ');\n\t\tpnnn = insert(pnnn,node);\n\t\tp = pnnn;\n\t}\n}", "id": 16, "concepts": ["string manipulation", "linked list traversal", "insertion"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 2\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 4\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 6\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 9\n### Snippet\nvoid DiscreteMasterProperty__float4___ObjInit_2(DiscreteMasterProperty__float4* __this, ::app::Uno::UX::Property__float4* property, ::app::Fuse::Animations::MixerBase* mixerBase)\n{\n    ::app::Fuse::Animations::MasterProperty__float4___ObjInit_1(__this, property, mixerBase);\n}\n\n### Concepts", "fingerprint": null, "seed": "void DiscreteMasterProperty__float4___ObjInit_2(DiscreteMasterProperty__float4* __this, ::app::Uno::UX::Property__float4* property, ::app::Fuse::Animations::MixerBase* mixerBase)\n{\n    ::app::Fuse::Animations::MasterProperty__float4___ObjInit_1(__this, property, mixerBase);\n}", "id": 17, "concepts": ["function definition", "member function initialization", "argument passing", "type specification"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 3\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 4\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 7\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 9\n### Snippet\nvoid ticker(){\n    read_sensors();  // read PIR and radar...\n    update_status(); // ...and then compute occupancy status\n    if (network.available())  // this is usually a while() loop  \n        read_command();        \n}\n\n### Concepts", "fingerprint": null, "seed": "void ticker(){\n    read_sensors();  // read PIR and radar...\n    update_status(); // ...and then compute occupancy status\n    if (network.available())  // this is usually a while() loop  \n        read_command();        \n}", "id": 18, "concepts": ["system design", "sensor data processing", "network command handling"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 3\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 5\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 8\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 9\n### Snippet\nvoid sendtoBlynk()                                                           // Here we are sending PZEM data to blynk\n{\n  Blynk.virtualWrite(vPIN_VOLTAGE_1,               voltage_usage_1);\n  Blynk.virtualWrite(vPIN_CURRENT_USAGE_1,         current_usage_1);\n  Blynk.virtualWrite(vPIN_ACTIVE_POWER_1,          active_power_1);\n  Blynk.virtualWrite(vPIN_ACTIVE_ENERGY_1,         active_energy_1);\n  Blynk.virtualWrite(vPIN_FREQUENCY_1,             frequency_1);\n  Blynk.virtualWrite(vPIN_POWER_FACTOR_1,          power_factor_1);\n\n  Blynk.virtualWrite(vPIN_VOLTAGE_2,               voltage_usage_2);\n  Blynk.virtualWrite(vPIN_CURRENT_USAGE_2,         current_usage_2);\n  Blynk.virtualWrite(vPIN_ACTIVE_POWER_2,          active_power_2);\n  Blynk.virtualWrite(vPIN_ACTIVE_ENERGY_2,         active_energy_2);\n  Blynk.virtualWrite(vPIN_FREQUENCY_2,             frequency_2);\n  Blynk.virtualWrite(vPIN_POWER_FACTOR_2,          power_factor_2);\n\n  Blynk.virtualWrite(vPIN_VOLTAGE_3,               voltage_usage_3);\n  Blynk.virtualWrite(vPIN_CURRENT_USAGE_3,         current_usage_3);\n  Blynk.virtualWrite(vPIN_ACTIVE_POWER_3,          active_power_3);\n  Blynk.virtualWrite(vPIN_ACTIVE_ENERGY_3,         active_energy_3);\n  Blynk.virtualWrite(vPIN_FREQUENCY_3,             frequency_3);\n  Blynk.virtualWrite(vPIN_POWER_FACTOR_3,          power_factor_3);\n\n  Blynk.virtualWrite(vPIN_SUM_VOLTAGE,             sum_of_voltage);\n  Blynk.virtualWrite(vPIN_SUM_CURRENT_USAGE,       sum_of_current);\n  Blynk.virtualWrite(vPIN_SUM_ACTIVE_POWER,        sum_of_power);\n  Blynk.virtualWrite(vPIN_SUM_ACTIVE_ENERGY,       sum_of_active_energy);\n  Blynk.virtualWrite(vPIN_SUM_FREQUENCY,           sum_of_frequency);\n  Blynk.virtualWrite(vPIN_SUM_POWER_FACTOR,        sum_of_power_factor);\n\n  Blynk.virtualWrite(VPIN_BUILD_NUMBER,            BUILD_NUMBER);  \n}\n\n### Concepts", "fingerprint": null, "seed": "void sendtoBlynk()                                                           // Here we are sending PZEM data to blynk\n{\n  Blynk.virtualWrite(vPIN_VOLTAGE_1,               voltage_usage_1);\n  Blynk.virtualWrite(vPIN_CURRENT_USAGE_1,         current_usage_1);\n  Blynk.virtualWrite(vPIN_ACTIVE_POWER_1,          active_power_1);\n  Blynk.virtualWrite(vPIN_ACTIVE_ENERGY_1,         active_energy_1);\n  Blynk.virtualWrite(vPIN_FREQUENCY_1,             frequency_1);\n  Blynk.virtualWrite(vPIN_POWER_FACTOR_1,          power_factor_1);\n\n  Blynk.virtualWrite(vPIN_VOLTAGE_2,               voltage_usage_2);\n  Blynk.virtualWrite(vPIN_CURRENT_USAGE_2,         current_usage_2);\n  Blynk.virtualWrite(vPIN_ACTIVE_POWER_2,          active_power_2);\n  Blynk.virtualWrite(vPIN_ACTIVE_ENERGY_2,         active_energy_2);\n  Blynk.virtualWrite(vPIN_FREQUENCY_2,             frequency_2);\n  Blynk.virtualWrite(vPIN_POWER_FACTOR_2,          power_factor_2);\n\n  Blynk.virtualWrite(vPIN_VOLTAGE_3,               voltage_usage_3);\n  Blynk.virtualWrite(vPIN_CURRENT_USAGE_3,         current_usage_3);\n  Blynk.virtualWrite(vPIN_ACTIVE_POWER_3,          active_power_3);\n  Blynk.virtualWrite(vPIN_ACTIVE_ENERGY_3,         active_energy_3);\n  Blynk.virtualWrite(vPIN_FREQUENCY_3,             frequency_3);\n  Blynk.virtualWrite(vPIN_POWER_FACTOR_3,          power_factor_3);\n\n  Blynk.virtualWrite(vPIN_SUM_VOLTAGE,             sum_of_voltage);\n  Blynk.virtualWrite(vPIN_SUM_CURRENT_USAGE,       sum_of_current);\n  Blynk.virtualWrite(vPIN_SUM_ACTIVE_POWER,        sum_of_power);\n  Blynk.virtualWrite(vPIN_SUM_ACTIVE_ENERGY,       sum_of_active_energy);\n  Blynk.virtualWrite(vPIN_SUM_FREQUENCY,           sum_of_frequency);\n  Blynk.virtualWrite(vPIN_SUM_POWER_FACTOR,        sum_of_power_factor);\n\n  Blynk.virtualWrite(VPIN_BUILD_NUMBER,            BUILD_NUMBER);  \n}", "id": 19, "concepts": ["data transfer between devices", "real-time monitoring and control", "energy consumption analysis"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 3\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 6\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 8\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 9\n### Snippet\nvoid printDateTime(time_t t, const char *tz)\r\n{\r\n    char buf[32];\r\n    char m[4];    // temporary storage for month string (DateStrings.cpp uses shared buffer)\r\n    strcpy(m, monthShortStr(month(t)));\r\n    sprintf(buf, \"%.2d:%.2d:%.2d %s %.2d %s %d %s\",\r\n        hour(t), minute(t), second(t), dayShortStr(weekday(t)), day(t), m, year(t), tz);\r\n    Serial.println(buf);\r\n}\n\n### Concepts", "fingerprint": null, "seed": "void printDateTime(time_t t, const char *tz)\r\n{\r\n    char buf[32];\r\n    char m[4];    // temporary storage for month string (DateStrings.cpp uses shared buffer)\r\n    strcpy(m, monthShortStr(month(t)));\r\n    sprintf(buf, \"%.2d:%.2d:%.2d %s %.2d %s %d %s\",\r\n        hour(t), minute(t), second(t), dayShortStr(weekday(t)), day(t), m, year(t), tz);\r\n    Serial.println(buf);\r\n}", "id": 20, "concepts": ["date and time formatting", "string formatting", "time zone consideration"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 4\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 5\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 7\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 9\n### Snippet\nbool isScramble(string& s1, string& s2) {\n    if (s1.size() != s2.size()) return false;\n    if (s1.size() == 1) return s1 == s2; \n    \n    string combined(s1);\n    combined.append(s2);\n    if (memo.find(combined) != memo.end()) return memo.at(combined);\n    \n    int size = s1.size();\n    \n    int part_length = 1; \n    \n    while (part_length <= size/2) {\n        string s1_k1_p1 = s1.substr(0, part_length); \n        string s1_k1_p2 = s1.substr(part_length);\n        string s1_k2_p1 = s1.substr(size - part_length); \n        string s1_k2_p2 = s1.substr(0, size - part_length); \n        string s2_k1_p1 = s2.substr(0, part_length); \n        string s2_k1_p2 = s2.substr(part_length); \n        string s2_k2_p1 = s2.substr(size - part_length); \n        string s2_k2_p2 = s2.substr(0, size - part_length);\n\n        string sorted_s1_k1_p1 = genSortedString(s1_k1_p1);\n        string sorted_s1_k1_p2 = genSortedString(s1_k1_p2);\n        string sorted_s1_k2_p1 = genSortedString(s1_k2_p1);\n        string sorted_s1_k2_p2 = genSortedString(s1_k2_p2);\n        string sorted_s2_k1_p1 = genSortedString(s2_k1_p1);\n        string sorted_s2_k1_p2 = genSortedString(s2_k1_p2);\n        string sorted_s2_k2_p1 = genSortedString(s2_k2_p1);\n        string sorted_s2_k2_p2 = genSortedString(s2_k2_p2);\n        \n        if (sorted_s1_k1_p1 == sorted_s2_k1_p1 && sorted_s1_k1_p2 == sorted_s2_k1_p2) {\n            if (isScramble(s1_k1_p1, s2_k1_p1) && isScramble(s1_k1_p2, s2_k1_p2)) {\n                return true;\n            }\n        }\n        \n        if (sorted_s1_k2_p1 == sorted_s2_k1_p1 && sorted_s1_k2_p2 == sorted_s2_k1_p2) {\n            if (isScramble(s1_k2_p1, s2_k1_p1) && isScramble(s1_k2_p2, s2_k1_p2)) {\n                return true;\n            }\n        }  \n\n        if (sorted_s1_k1_p1 == sorted_s2_k2_p1 && sorted_s1_k1_p2 == sorted_s2_k2_p2) {\n            if (isScramble(s1_k1_p1, s2_k2_p1) && isScramble(s1_k1_p2, s2_k2_p2)) {\n                return true;\n            }\n        }\n        \n        if (sorted_s1_k2_p1 == sorted_s2_k2_p1 && sorted_s1_k2_p2 == sorted_s2_k2_p2) {\n            if (isScramble(s1_k2_p1, s2_k2_p1) && isScramble(s1_k2_p2, s2_k2_p2)) {\n                return true;\n            }\n        }\n        \n        part_length ++;\n    }\n    \n    memo[combined] = false;\n    return false; \n}\n\n### Concepts", "fingerprint": null, "seed": "bool isScramble(string& s1, string& s2) {\n    if (s1.size() != s2.size()) return false;\n    if (s1.size() == 1) return s1 == s2; \n    \n    string combined(s1);\n    combined.append(s2);\n    if (memo.find(combined) != memo.end()) return memo.at(combined);\n    \n    int size = s1.size();\n    \n    int part_length = 1; \n    \n    while (part_length <= size/2) {\n        string s1_k1_p1 = s1.substr(0, part_length); \n        string s1_k1_p2 = s1.substr(part_length);\n        string s1_k2_p1 = s1.substr(size - part_length); \n        string s1_k2_p2 = s1.substr(0, size - part_length); \n        string s2_k1_p1 = s2.substr(0, part_length); \n        string s2_k1_p2 = s2.substr(part_length); \n        string s2_k2_p1 = s2.substr(size - part_length); \n        string s2_k2_p2 = s2.substr(0, size - part_length);\n\n        string sorted_s1_k1_p1 = genSortedString(s1_k1_p1);\n        string sorted_s1_k1_p2 = genSortedString(s1_k1_p2);\n        string sorted_s1_k2_p1 = genSortedString(s1_k2_p1);\n        string sorted_s1_k2_p2 = genSortedString(s1_k2_p2);\n        string sorted_s2_k1_p1 = genSortedString(s2_k1_p1);\n        string sorted_s2_k1_p2 = genSortedString(s2_k1_p2);\n        string sorted_s2_k2_p1 = genSortedString(s2_k2_p1);\n        string sorted_s2_k2_p2 = genSortedString(s2_k2_p2);\n        \n        if (sorted_s1_k1_p1 == sorted_s2_k1_p1 && sorted_s1_k1_p2 == sorted_s2_k1_p2) {\n            if (isScramble(s1_k1_p1, s2_k1_p1) && isScramble(s1_k1_p2, s2_k1_p2)) {\n                return true;\n            }\n        }\n        \n        if (sorted_s1_k2_p1 == sorted_s2_k1_p1 && sorted_s1_k2_p2 == sorted_s2_k1_p2) {\n            if (isScramble(s1_k2_p1, s2_k1_p1) && isScramble(s1_k2_p2, s2_k1_p2)) {\n                return true;\n            }\n        }  \n\n        if (sorted_s1_k1_p1 == sorted_s2_k2_p1 && sorted_s1_k1_p2 == sorted_s2_k2_p2) {\n            if (isScramble(s1_k1_p1, s2_k2_p1) && isScramble(s1_k1_p2, s2_k2_p2)) {\n                return true;\n            }\n        }\n        \n        if (sorted_s1_k2_p1 == sorted_s2_k2_p1 && sorted_s1_k2_p2 == sorted_s2_k2_p2) {\n            if (isScramble(s1_k2_p1, s2_k2_p1) && isScramble(s1_k2_p2, s2_k2_p2)) {\n                return true;\n            }\n        }\n        \n        part_length ++;\n    }\n    \n    memo[combined] = false;\n    return false; \n}", "id": 21, "concepts": ["recursive algorithm design", "string sorting for comparison", "string slicing for subproblem creation", "memoization for optimization"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 3\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 4\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 5\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 9\n### Snippet\nvoid dfs(ll i, ll sum,ll arr[])\n{\n    if(i==n)\n    {\n        st[sum]++;\n        return;\n    }\n    dfs(i+1,sum+arr[i],arr);\n    dfs(i+1,sum,arr);\n}\n\n### Concepts", "fingerprint": null, "seed": "void dfs(ll i, ll sum,ll arr[])\n{\n    if(i==n)\n    {\n        st[sum]++;\n        return;\n    }\n    dfs(i+1,sum+arr[i],arr);\n    dfs(i+1,sum,arr);\n}", "id": 22, "concepts": ["depth-first search", "summation calculation", "recursive function call"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 3\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 4\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 5\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 7\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 9\n### Snippet\nvoid checkPhysicalButton()                                  // Here we are going to check push button pressed or not and change relay state\n{\n  if (digitalRead(PUSH_BUTTON_1) == LOW) {\n    if (pushButton1State != LOW && (lowvoltageflag == false && highvoltageflag == false && phasefailureflag == false) ) {                          // pushButton1State is used to avoid sequential toggles  \n      relay1State = !relay1State;                           // Toggle Relay state\n      digitalWrite(RELAY_PIN_1, relay1State);            \n      Blynk.virtualWrite(VPIN_BUTTON_1, relay1State);       // Update Button Widget\n    }\n    pushButton1State = LOW;\n  } else {\n    pushButton1State = HIGH;\n  }\n  \n  if (digitalRead(PUSH_BUTTON_2) == LOW) {\n    if (pushButton2State != LOW && (lowvoltageflag == false && highvoltageflag == false && phasefailureflag == false) ) {                        // pushButton2State is used to avoid sequential toggles     \n      relay2State = !relay2State;                         // Toggle Relay state\n      digitalWrite(RELAY_PIN_2, relay2State);\n      Blynk.virtualWrite(VPIN_BUTTON_2, relay2State);     // Update Button Widget\n    }\n    pushButton2State = LOW;\n  } else {\n    pushButton2State = HIGH;\n  }\n}\n\n### Concepts", "fingerprint": null, "seed": "void checkPhysicalButton()                                  // Here we are going to check push button pressed or not and change relay state\n{\n  if (digitalRead(PUSH_BUTTON_1) == LOW) {\n    if (pushButton1State != LOW && (lowvoltageflag == false && highvoltageflag == false && phasefailureflag == false) ) {                          // pushButton1State is used to avoid sequential toggles  \n      relay1State = !relay1State;                           // Toggle Relay state\n      digitalWrite(RELAY_PIN_1, relay1State);            \n      Blynk.virtualWrite(VPIN_BUTTON_1, relay1State);       // Update Button Widget\n    }\n    pushButton1State = LOW;\n  } else {\n    pushButton1State = HIGH;\n  }\n  \n  if (digitalRead(PUSH_BUTTON_2) == LOW) {\n    if (pushButton2State != LOW && (lowvoltageflag == false && highvoltageflag == false && phasefailureflag == false) ) {                        // pushButton2State is used to avoid sequential toggles     \n      relay2State = !relay2State;                         // Toggle Relay state\n      digitalWrite(RELAY_PIN_2, relay2State);\n      Blynk.virtualWrite(VPIN_BUTTON_2, relay2State);     // Update Button Widget\n    }\n    pushButton2State = LOW;\n  } else {\n    pushButton2State = HIGH;\n  }\n}", "id": 23, "concepts": ["push button state tracking", "relay state toggling", "Blynk widget updating", "push button debouncing", "sequential toggle prevention", "sequential button state tracking"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 3\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 4\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 9\n### Snippet\nvoid p11(Node *h){\n\tNode *p = h;\n\twhile(p){\n\t\tNode *pn = p->next;\n\t\tif(pn == NULL || pn->c == '\\''){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tNode *pnn = pn->next;\n\t\tif(pnn == NULL || pnn->c != '\\''){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tNode *pnnn = pnn->next;\n\t\tif(pnnn == NULL || pnnn->c != ' '){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n//\t\tcout<<\"p11\"<<endl;\n\t\tNode *node = new Node(' ');\n\t\tpn = insert(pn,node);\n\t\tp = pnnn;\n\t}\n}\n\n### Concepts", "fingerprint": null, "seed": "void p11(Node *h){\n\tNode *p = h;\n\twhile(p){\n\t\tNode *pn = p->next;\n\t\tif(pn == NULL || pn->c == '\\''){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tNode *pnn = pn->next;\n\t\tif(pnn == NULL || pnn->c != '\\''){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tNode *pnnn = pnn->next;\n\t\tif(pnnn == NULL || pnnn->c != ' '){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n//\t\tcout<<\"p11\"<<endl;\n\t\tNode *node = new Node(' ');\n\t\tpn = insert(pn,node);\n\t\tp = pnnn;\n\t}\n}", "id": 24, "concepts": ["text processing", "linked list manipulation", "input-output examples for error handling"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 2\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 4\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 6\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 8\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 9\n### Snippet\nint Pow(int x,int k){int t=1;for(;k;k>>=1,x=1ll*x*x%mod) if(k&1) t=1ll*t*x%mod;return t;}\n\n### Concepts", "fingerprint": null, "seed": "int Pow(int x,int k){int t=1;for(;k;k>>=1,x=1ll*x*x%mod) if(k&1) t=1ll*t*x%mod;return t;}", "id": 25, "concepts": ["fast exponentiation", "modular arithmetic", "bitwise operation for exponentiation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 2\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 3\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 8\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 9\n### Snippet\nvoid calc_error(const char *s)\n{\n\tstd::cout << s << std::endl;\n}\n\n### Concepts", "fingerprint": null, "seed": "void calc_error(const char *s)\n{\n\tstd::cout << s << std::endl;\n}", "id": 26, "concepts": ["error handling", "input validation for error messages"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 5\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 6\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 8\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 9\n### Snippet\nvoid p12(Node *h){\n\tNode *p = h;\n\twhile(p){\n\t\tNode *pn = p->next;\n\t\tif(pn == NULL || pn->c != '\\''){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tNode *pnn = pn->next;\n\t\tif(pnn == NULL || (\n\t\t   pnn->c != 's' &&\n\t\t   pnn->c != 'S' &&\n\t\t   pnn->c != 'm' &&\n\t\t   pnn->c != 'M' &&\n\t\t   pnn->c != 'd' &&\n\t\t   pnn->c != 'D')){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tNode *pnnn = pnn->next;\n\t\tif(pnnn == NULL || pnnn->c != ' '){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n//\t\tcout<<\"p12 \"<<p->c<<endl;\n\t\tNode *node = new Node(' ');\n\t\tp = insert(p,node);\n\t\tp = pnnn;\n\t}\n}\n\n### Concepts", "fingerprint": null, "seed": "void p12(Node *h){\n\tNode *p = h;\n\twhile(p){\n\t\tNode *pn = p->next;\n\t\tif(pn == NULL || pn->c != '\\''){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tNode *pnn = pn->next;\n\t\tif(pnn == NULL || (\n\t\t   pnn->c != 's' &&\n\t\t   pnn->c != 'S' &&\n\t\t   pnn->c != 'm' &&\n\t\t   pnn->c != 'M' &&\n\t\t   pnn->c != 'd' &&\n\t\t   pnn->c != 'D')){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tNode *pnnn = pnn->next;\n\t\tif(pnnn == NULL || pnnn->c != ' '){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n//\t\tcout<<\"p12 \"<<p->c<<endl;\n\t\tNode *node = new Node(' ');\n\t\tp = insert(p,node);\n\t\tp = pnnn;\n\t}\n}", "id": 27, "concepts": ["pattern matching", "string interpolation", "function composition", "error handling with exceptions"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 3\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 5\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 6\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 8\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 9\n### Snippet\nint main(int argc,char **argv){\n    ros::init(argc,argv,\"listener\");\n    ros::NodeHandle n;\n    ros::Subscriber sub=n.subscribe(\"filePub\",1000,chatterCallback);\n    ros::spin();//\u7b2c\u4e00\u6b21\u64cd\u4f5c\n}\n\n### Concepts", "fingerprint": null, "seed": "int main(int argc,char **argv){\n    ros::init(argc,argv,\"listener\");\n    ros::NodeHandle n;\n    ros::Subscriber sub=n.subscribe(\"filePub\",1000,chatterCallback);\n    ros::spin();//\u7b2c\u4e00\u6b21\u64cd\u4f5c\n}", "id": 28, "concepts": ["Node initialization", "topic subscription", "callback function", "spinning"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 3\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 5\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 6\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 9\n### Snippet\nvoid p8(Node *h){\n\tNode *p = h;\n\twhile(p){\n\t\tNode *pn = p->next;\n\t\tif(pn == NULL || pn->c != '-'){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tNode *pnn = pn->next;\n\t\tif(pnn == NULL || pnn->c != '-'){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n//\t\tcout<<\"p8\"<<endl;\n\t\tNode *node = new Node(' ');\n\t\tp = insert(p,node);\n\t\tnode = new Node(' ');\n\t\tpnn = insert(pnn,node);\n\t\tp = pnn;\n\t}\n}\n\n### Concepts", "fingerprint": null, "seed": "void p8(Node *h){\n\tNode *p = h;\n\twhile(p){\n\t\tNode *pn = p->next;\n\t\tif(pn == NULL || pn->c != '-'){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tNode *pnn = pn->next;\n\t\tif(pnn == NULL || pnn->c != '-'){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n//\t\tcout<<\"p8\"<<endl;\n\t\tNode *node = new Node(' ');\n\t\tp = insert(p,node);\n\t\tnode = new Node(' ');\n\t\tpnn = insert(pnn,node);\n\t\tp = pnn;\n\t}\n}", "id": 29, "concepts": ["linked list traversal with a pointer", "character insertion at a specific position", "error handling for null pointers"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 3\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 4\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 5\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 6\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 9\n### Snippet\nint test(int size) {\n    if (size <= 0) return 0;\n\n    double *A = new double[size * size];\n    std::fill(A, A + size * size, 0.0);\n\n    if (size > 1) {\n      A[0] =  2.0;\n      A[1] = -1.0;\n      for (int i = 1; i < size - 1; ++i) {\n        A[i * size + i - 1] = -1.0;\n        A[i * size + i    ] =  2.0;\n        A[i * size + i + 1] = -1.0;\n      }\n      A[size * size - 2] = -1.0;\n      A[size * size - 1] =  2.0;\n    } else if (size == 1) {\n      A[0] = 2.0;\n    }\n\n    int *rowptr, *colidx;\n    double *values;\n    full_to_csr_ref(size, size, A, size, &rowptr, &colidx, &values);\n\n    double *d_A;\n    cudaError_t cudaErr = cudaMalloc(reinterpret_cast<void **>(&d_A), size * size * sizeof(double));\n    assert(cudaErr == cudaSuccess);\n\n    cudaErr = cudaMemcpy(d_A, A, size * size * sizeof(double), cudaMemcpyHostToDevice);\n    assert(cudaErr == cudaSuccess);\n\n    int    *d_rowptr, *d_colidx;\n    double *d_values;\n    full_to_csr(size, size, d_A, size, &d_rowptr, &d_colidx, &d_values);\n\n    // Verify results\n    int    *h_rowptr = new int[size + 1];\n    int    *h_colidx = new int[rowptr[size]];\n    double *h_values = new double[rowptr[size]];\n\n    cudaErr = cudaMemcpy(h_rowptr, d_rowptr, (size + 1) * sizeof(int), cudaMemcpyDeviceToHost);\n    assert(cudaErr == cudaSuccess);\n    cudaErr = cudaMemcpy(h_colidx, d_colidx, h_rowptr[size] * sizeof(int), cudaMemcpyDeviceToHost);\n    assert(cudaErr == cudaSuccess);\n    cudaErr = cudaMemcpy(h_values, d_values, h_rowptr[size] * sizeof(double), cudaMemcpyDeviceToHost);\n    assert(cudaErr == cudaSuccess);\n\n    int errcnt = 0;\n    for (int i = 0; i < size + 1; ++i) {\n      if (rowptr[i] != h_rowptr[i]) errcnt += 1;\n    }\n    for (int i = 0; i < rowptr[size]; ++i) {\n      if (colidx[i] != h_colidx[i]) errcnt += 1;\n    }\n    for (int i = 0; i < rowptr[size]; ++i) {\n      if (values[i] != h_values[i]) errcnt += 1;\n    }\n\n    cudaFree(d_A);\n    cudaFree(d_rowptr);\n    cudaFree(d_colidx);\n    cudaFree(d_values);\n\n    delete[] rowptr;\n    delete[] colidx;\n    delete[] values;\n    delete[] h_rowptr;\n    delete[] h_colidx;\n    delete[] h_values;\n\n    return errcnt;\n}\n\n### Concepts", "fingerprint": null, "seed": "int test(int size) {\n    if (size <= 0) return 0;\n\n    double *A = new double[size * size];\n    std::fill(A, A + size * size, 0.0);\n\n    if (size > 1) {\n      A[0] =  2.0;\n      A[1] = -1.0;\n      for (int i = 1; i < size - 1; ++i) {\n        A[i * size + i - 1] = -1.0;\n        A[i * size + i    ] =  2.0;\n        A[i * size + i + 1] = -1.0;\n      }\n      A[size * size - 2] = -1.0;\n      A[size * size - 1] =  2.0;\n    } else if (size == 1) {\n      A[0] = 2.0;\n    }\n\n    int *rowptr, *colidx;\n    double *values;\n    full_to_csr_ref(size, size, A, size, &rowptr, &colidx, &values);\n\n    double *d_A;\n    cudaError_t cudaErr = cudaMalloc(reinterpret_cast<void **>(&d_A), size * size * sizeof(double));\n    assert(cudaErr == cudaSuccess);\n\n    cudaErr = cudaMemcpy(d_A, A, size * size * sizeof(double), cudaMemcpyHostToDevice);\n    assert(cudaErr == cudaSuccess);\n\n    int    *d_rowptr, *d_colidx;\n    double *d_values;\n    full_to_csr(size, size, d_A, size, &d_rowptr, &d_colidx, &d_values);\n\n    // Verify results\n    int    *h_rowptr = new int[size + 1];\n    int    *h_colidx = new int[rowptr[size]];\n    double *h_values = new double[rowptr[size]];\n\n    cudaErr = cudaMemcpy(h_rowptr, d_rowptr, (size + 1) * sizeof(int), cudaMemcpyDeviceToHost);\n    assert(cudaErr == cudaSuccess);\n    cudaErr = cudaMemcpy(h_colidx, d_colidx, h_rowptr[size] * sizeof(int), cudaMemcpyDeviceToHost);\n    assert(cudaErr == cudaSuccess);\n    cudaErr = cudaMemcpy(h_values, d_values, h_rowptr[size] * sizeof(double), cudaMemcpyDeviceToHost);\n    assert(cudaErr == cudaSuccess);\n\n    int errcnt = 0;\n    for (int i = 0; i < size + 1; ++i) {\n      if (rowptr[i] != h_rowptr[i]) errcnt += 1;\n    }\n    for (int i = 0; i < rowptr[size]; ++i) {\n      if (colidx[i] != h_colidx[i]) errcnt += 1;\n    }\n    for (int i = 0; i < rowptr[size]; ++i) {\n      if (values[i] != h_values[i]) errcnt += 1;\n    }\n\n    cudaFree(d_A);\n    cudaFree(d_rowptr);\n    cudaFree(d_colidx);\n    cudaFree(d_values);\n\n    delete[] rowptr;\n    delete[] colidx;\n    delete[] values;\n    delete[] h_rowptr;\n    delete[] h_colidx;\n    delete[] h_values;\n\n    return errcnt;\n}", "id": 30, "concepts": ["sparse matrix storage", "memory allocation and deallocation", "data transfer between host and device", "error handling with assertions"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 3\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 6\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 7\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 9\n### Snippet\nvoid p1(Node *h){\n\tNode *p = h;\n\tNode *pn = p->next;\n\tif(pn != NULL && pn->c == '\\\"'){\n//\t\tcout<<\"p1\"<<endl;\n\t\tNode *node;\n\t\tnode = new Node('`');\n\t\tp = insert(p,node);\t\t\n\t\tnode = new Node('`');\n\t\tp = insert(p,node);\n\t\tnode = new Node(' ');\n\t\tp = insert(p,node);\n\n\t\tdel(p);\n\t}\n}\n\n### Concepts", "fingerprint": null, "seed": "void p1(Node *h){\n\tNode *p = h;\n\tNode *pn = p->next;\n\tif(pn != NULL && pn->c == '\\\"'){\n//\t\tcout<<\"p1\"<<endl;\n\t\tNode *node;\n\t\tnode = new Node('`');\n\t\tp = insert(p,node);\t\t\n\t\tnode = new Node('`');\n\t\tp = insert(p,node);\n\t\tnode = new Node(' ');\n\t\tp = insert(p,node);\n\n\t\tdel(p);\n\t}\n}", "id": 31, "concepts": ["string processing", "pattern recognition", "pointer manipulation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 3\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 5\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 7\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 9\n### Snippet\nstatic int8_t CDC_DeInit_FS(void)\r\n{\r\n    /* USER CODE BEGIN 4 */\r\n    return (USBD_OK);\r\n    /* USER CODE END 4 */\r\n}\n\n### Concepts", "fingerprint": null, "seed": "static int8_t CDC_DeInit_FS(void)\r\n{\r\n    /* USER CODE BEGIN 4 */\r\n    return (USBD_OK);\r\n    /* USER CODE END 4 */\r\n}", "id": 32, "concepts": ["static function definition", "global variable access", "function return value"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 2\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 5\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 9\n### Snippet\nint main(int argc, char** argv){\n\tstring a;\n\tNode* h;\n\tchar c[20];\n\tistream *in;\n\tif(argc >= 2) in = new ifstream(argv[1]);\n\telse in = &std::cin;\n\n\tostream *out;\n\tif(argc >= 3) out = new ofstream(argv[2]);\n\telse out = &std::cout;\n\n\twhile(getline(*in,a)){\n\t\th = new Node();\n\t\tinit_List(h,a);\n\t\tp1(h);\n\t\tp2(h);\n\t\tp3(h);\n\t\tp4(h);\n\t\tp5(h);\n\t\tp6(h);\n\t\tp7(h);\n\t\tp8(h);\n\t\tp9(h);\n\t\tp10(h);\n\t\tp11(h);\n\t\tp12(h);\n\t\tmemcpy(c,\"'ll\",3); p13(h,c);\n\t\tmemcpy(c,\"'re\",3); p13(h,c);\n\t\tmemcpy(c,\"'ve\",3); p13(h,c);\n\t\tmemcpy(c,\"n't\",3); p13(h,c);\n\t\tmemcpy(c,\"'LL\",3); p13(h,c);\n\t\tmemcpy(c,\"'RE\",3); p13(h,c);\n\t\tmemcpy(c,\"'VE\",3); p13(h,c);\n\t\tmemcpy(c,\"N'T\",3); p13(h,c);\n\n\t\tmemcpy(c,\" cannot \",8); p14(h,c,8,3);\n\t\tmemcpy(c,\" Cannot \",8); p14(h,c,8,3);\n\t\tmemcpy(c,\" d'ye \",6); p14(h,c,6,2);\n\t\tmemcpy(c,\" D'ye \",6); p14(h,c,6,2);\n\t\tmemcpy(c,\" gimme \",7); p14(h,c,7,3);\n\t\tmemcpy(c,\" Gimme \",7); p14(h,c,7,3);\n\t\tmemcpy(c,\" gonna \",7); p14(h,c,7,3);\n\t\tmemcpy(c,\" Gonna \",7); p14(h,c,7,3);\n\t\tmemcpy(c,\" gotta \",7); p14(h,c,7,3);\n\t\tmemcpy(c,\" Gotta \",7); p14(h,c,7,3);\n\t\tmemcpy(c,\" lemme \",7); p14(h,c,7,3);\n\t\tmemcpy(c,\" Lemme \",7); p14(h,c,7,3);\n\t\tmemcpy(c,\" more'n \",8); p14(h,c,8,4);\n\t\tmemcpy(c,\" More'n \",8); p14(h,c,8,4);\n\t\tmemcpy(c,\" 'tis \",6); p14(h,c,6,2);\n\t\tmemcpy(c,\" 'Tis \",6); p14(h,c,6,2);\n\t\tmemcpy(c,\" 'twas \",7); p14(h,c,7,2);\n\t\tmemcpy(c,\" 'Twas \",7); p14(h,c,7,2);\n\t\tmemcpy(c,\" wanna \",7); p14(h,c,7,3);\n\t\tmemcpy(c,\" Wanna \",7); p14(h,c,7,3);\n\n\t\tp15(h);\n//\t\tcout<<\"ok\"<<endl;\n\t\tNode *p = h->next;\n\t\twhile(p){\n\t\t\tif(p->c == '(') (*out)<<\"-LRB-\";\n\t\t\telse if(p->c == ')') (*out)<<\"-RRB-\";\n\t\t\telse if(p->c == '[') (*out)<<\"-LSB-\";\n\t\t\telse if(p->c == ']') (*out)<<\"-RSB-\";\n\t\t\telse if(p->c == '{') (*out)<<\"-LCB-\";\n\t\t\telse if(p->c == '}') (*out)<<\"-RCB-\";\n\t\t\telse (*out)<<p->c;\n\t\t\tp = p->next;\n\t\t}\n\t\t(*out)<<endl;\n\t\tclean_List(h);\n\t}\n\treturn 0;\n}\n\n### Concepts", "fingerprint": null, "seed": "int main(int argc, char** argv){\n\tstring a;\n\tNode* h;\n\tchar c[20];\n\tistream *in;\n\tif(argc >= 2) in = new ifstream(argv[1]);\n\telse in = &std::cin;\n\n\tostream *out;\n\tif(argc >= 3) out = new ofstream(argv[2]);\n\telse out = &std::cout;\n\n\twhile(getline(*in,a)){\n\t\th = new Node();\n\t\tinit_List(h,a);\n\t\tp1(h);\n\t\tp2(h);\n\t\tp3(h);\n\t\tp4(h);\n\t\tp5(h);\n\t\tp6(h);\n\t\tp7(h);\n\t\tp8(h);\n\t\tp9(h);\n\t\tp10(h);\n\t\tp11(h);\n\t\tp12(h);\n\t\tmemcpy(c,\"'ll\",3); p13(h,c);\n\t\tmemcpy(c,\"'re\",3); p13(h,c);\n\t\tmemcpy(c,\"'ve\",3); p13(h,c);\n\t\tmemcpy(c,\"n't\",3); p13(h,c);\n\t\tmemcpy(c,\"'LL\",3); p13(h,c);\n\t\tmemcpy(c,\"'RE\",3); p13(h,c);\n\t\tmemcpy(c,\"'VE\",3); p13(h,c);\n\t\tmemcpy(c,\"N'T\",3); p13(h,c);\n\n\t\tmemcpy(c,\" cannot \",8); p14(h,c,8,3);\n\t\tmemcpy(c,\" Cannot \",8); p14(h,c,8,3);\n\t\tmemcpy(c,\" d'ye \",6); p14(h,c,6,2);\n\t\tmemcpy(c,\" D'ye \",6); p14(h,c,6,2);\n\t\tmemcpy(c,\" gimme \",7); p14(h,c,7,3);\n\t\tmemcpy(c,\" Gimme \",7); p14(h,c,7,3);\n\t\tmemcpy(c,\" gonna \",7); p14(h,c,7,3);\n\t\tmemcpy(c,\" Gonna \",7); p14(h,c,7,3);\n\t\tmemcpy(c,\" gotta \",7); p14(h,c,7,3);\n\t\tmemcpy(c,\" Gotta \",7); p14(h,c,7,3);\n\t\tmemcpy(c,\" lemme \",7); p14(h,c,7,3);\n\t\tmemcpy(c,\" Lemme \",7); p14(h,c,7,3);\n\t\tmemcpy(c,\" more'n \",8); p14(h,c,8,4);\n\t\tmemcpy(c,\" More'n \",8); p14(h,c,8,4);\n\t\tmemcpy(c,\" 'tis \",6); p14(h,c,6,2);\n\t\tmemcpy(c,\" 'Tis \",6); p14(h,c,6,2);\n\t\tmemcpy(c,\" 'twas \",7); p14(h,c,7,2);\n\t\tmemcpy(c,\" 'Twas \",7); p14(h,c,7,2);\n\t\tmemcpy(c,\" wanna \",7); p14(h,c,7,3);\n\t\tmemcpy(c,\" Wanna \",7); p14(h,c,7,3);\n\n\t\tp15(h);\n//\t\tcout<<\"ok\"<<endl;\n\t\tNode *p = h->next;\n\t\twhile(p){\n\t\t\tif(p->c == '(') (*out)<<\"-LRB-\";\n\t\t\telse if(p->c == ')') (*out)<<\"-RRB-\";\n\t\t\telse if(p->c == '[') (*out)<<\"-LSB-\";\n\t\t\telse if(p->c == ']') (*out)<<\"-RSB-\";\n\t\t\telse if(p->c == '{') (*out)<<\"-LCB-\";\n\t\t\telse if(p->c == '}') (*out)<<\"-RCB-\";\n\t\t\telse (*out)<<p->c;\n\t\t\tp = p->next;\n\t\t}\n\t\t(*out)<<endl;\n\t\tclean_List(h);\n\t}\n\treturn 0;\n}", "id": 33, "concepts": ["tokenization", "string manipulation", "string interpolation", "error handling"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 3\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 4\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 5\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 6\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 9\n### Snippet\nint main()\n{\n\tint n;\n\tint avgta=0;\n\tint avgwt=0;\n\tcout<<\"Enter number process:\";cin>>n;\n\tPriority*ob=new Priority[n];\n\t\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>ob[i];\n\t}\n\n\tfor(int i=0;i<n;i++)\n \t{\n\t\tfor(int j=i;j<n;j++)\n  \t\t{\n   \t\t\tif(ob[i].pt<ob[j].pt)\n   \t\t\t{\n\t\t\t\tMyswap(ob[i],ob[j]);\n   \t\t\t}\n   \t\t\tif(ob[i].pt==ob[j].pt&&ob[i].bt>ob[j].bt)\n   \t\t\t{\n\t\t\t    Myswap(ob[i],ob[j]);\t\t\n   \t\t\t}\t\n  \t\t}\n \t}\n\n\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tob[i].calc_ct();\n\t\tob[i].calc_ta();\n\t\tob[i].calc_wt();\n\t\tavgta+=ob[i].ta;\n\t\tavgwt+=ob[i].wt;\n\t}\n\n\tfor(int i=0;i<n;i++)\n\t{\t\n\t\tcout<<ob[i];\n \t\tcout<<\"ta: \"<<ob[i].ta<<endl;\n \t\tcout<<\"wt: \"<<ob[i].wt<<endl;\n\t\tcout<<endl;\n\t}\n\n\tcout<<\"Avg wating time: \"<<(avgwt/n)<<endl;\n\tcout<<\"Avg turn around time: \"<<(avgta/n)<<endl;\n\n\tdelete []ob;\n\treturn 0;\n}\n\n### Concepts", "fingerprint": null, "seed": "int main()\n{\n\tint n;\n\tint avgta=0;\n\tint avgwt=0;\n\tcout<<\"Enter number process:\";cin>>n;\n\tPriority*ob=new Priority[n];\n\t\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>ob[i];\n\t}\n\n\tfor(int i=0;i<n;i++)\n \t{\n\t\tfor(int j=i;j<n;j++)\n  \t\t{\n   \t\t\tif(ob[i].pt<ob[j].pt)\n   \t\t\t{\n\t\t\t\tMyswap(ob[i],ob[j]);\n   \t\t\t}\n   \t\t\tif(ob[i].pt==ob[j].pt&&ob[i].bt>ob[j].bt)\n   \t\t\t{\n\t\t\t    Myswap(ob[i],ob[j]);\t\t\n   \t\t\t}\t\n  \t\t}\n \t}\n\n\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tob[i].calc_ct();\n\t\tob[i].calc_ta();\n\t\tob[i].calc_wt();\n\t\tavgta+=ob[i].ta;\n\t\tavgwt+=ob[i].wt;\n\t}\n\n\tfor(int i=0;i<n;i++)\n\t{\t\n\t\tcout<<ob[i];\n \t\tcout<<\"ta: \"<<ob[i].ta<<endl;\n \t\tcout<<\"wt: \"<<ob[i].wt<<endl;\n\t\tcout<<endl;\n\t}\n\n\tcout<<\"Avg wating time: \"<<(avgwt/n)<<endl;\n\tcout<<\"Avg turn around time: \"<<(avgta/n)<<endl;\n\n\tdelete []ob;\n\treturn 0;\n}", "id": 34, "concepts": ["priority scheduling algorithm", "context switch", "average waiting and turnaround time calculation", "time complexity/src/extract-code-samples-from-pdf.py\nimport re\nimport sys\nimport os\nimport json\nimport argparse\n\ndef extract_code_samples(text):\n    \"\"\"\n    Extract code samples from a given text.\n    \"\"\"\n    pattern = r\"```.*```\"\n    matches = re.findall(pattern", "text", "re.DOTALL)\n    return matches\n\ndef main(args):\n    \"\"\"\n    Main function to extract code samples.\n    \"\"\"\n    file_path = args.file_path\n    output_path = args.output_path\n    with open(file_path", "\"r\") as file:\n        text = file.read()\n    code_samples = extract_code_samples(text)\n    if not os.path.exists(output_path):\n        os.makedirs(output_path)\n    for index", "code_sample in enumerate(code_samples):\n        file_name = f\"code_sample_{index}.txt\"\n        file_path = os.path.join(output_path", "file_name)\n        with open(file_path", "\"w\") as file:\n            file.write(code_sample)\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"Extract code samples from a given file.\")\n    parser.add_argument(\"--file_path\"", "type=str", "help=\"Path of the file to extract code samples from.\")\n    parser.add_argument(\"--output_path\"", "type=str", "help=\"Path of the directory to save the extracted code samples.\")\n    args = parser.parse_args()\n    main(args)\n/src/extract-code-samples-from-pdf.sh\n#!/bin/bash\n\npdftotext $1 $1.txt\npython extract-code-samples-from-pdf.py --file_path $1.txt --output_path code_samples\n/src/extract-code-samples-from-pdf.cpp\n#include <iostream>\n#include <regex>\n#include <string>\n#include <vector>\n\nstd::vector<std::string> extractCodeSamples(const std::string& text) {\n    std::vector<std::string> codeSamples;\n    std::regex regex(\"```.*```\");\n    std::sregex_iterator it(text.begin()", "text.end()", "regex);\n    std::sregex_iterator end;\n    while (it != end) {\n        codeSamples.push_back(it->str());\n        ++it;\n    }\n    return codeSamples;\n}\n\nint main() {\n    std::string text = \"This is a string containing ```code samples``` and other text.\";\n    std::vector<std::string> codeSamples = extractCodeSamples(text);\n    for (const std::string& codeSample : codeSamples) {\n        std::cout << codeSample << std::endl;\n    }\n    return 0;\n}"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 2\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 3\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 4\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 7\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 8\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 9\n### Snippet\ndouble rootMeanSquare(double valueSum, int valueCount) {\n  return sqrt(valueSum / valueCount);\n}\n\n### Concepts", "fingerprint": null, "seed": "double rootMeanSquare(double valueSum, int valueCount) {\n  return sqrt(valueSum / valueCount);\n}", "id": 35, "concepts": ["root mean square calculation", "mathematical formula implementation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 3\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 4\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 5\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 7\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 9\n### Snippet\nvoid bfs() {\n\twhile (!q.empty()) {\n\t\tbool flag = true;\n\t\tint qs = q.size();\n\t\tcnt++;\n\t\twhile (qs--) {\n\t\t\tint x = q.front().x;\n\t\t\tint y = q.front().y;\n\t\t\tint z = q.front().z;\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\tint nx = x + dr[i];\n\t\t\t\tint ny = y + dc[i];\n\t\t\t\tint nz = z + dz[i];\n\t\t\t\tif (nx <= 0 || nx > n || ny <= 0 || ny > m || nz <= 0 || nz > h) continue;\n\n\t\t\t\tif (map1[nx][ny][nz] == '0') {\n\t\t\t\t\ttomato++;\n\t\t\t\t\tmap1[nx][ny][nz] = '1';\n\t\t\t\t\tq.push({ nx,ny, nz });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n### Concepts", "fingerprint": null, "seed": "void bfs() {\n\twhile (!q.empty()) {\n\t\tbool flag = true;\n\t\tint qs = q.size();\n\t\tcnt++;\n\t\twhile (qs--) {\n\t\t\tint x = q.front().x;\n\t\t\tint y = q.front().y;\n\t\t\tint z = q.front().z;\n\t\t\tq.pop();\n\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\tint nx = x + dr[i];\n\t\t\t\tint ny = y + dc[i];\n\t\t\t\tint nz = z + dz[i];\n\t\t\t\tif (nx <= 0 || nx > n || ny <= 0 || ny > m || nz <= 0 || nz > h) continue;\n\n\t\t\t\tif (map1[nx][ny][nz] == '0') {\n\t\t\t\t\ttomato++;\n\t\t\t\t\tmap1[nx][ny][nz] = '1';\n\t\t\t\t\tq.push({ nx,ny, nz });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "id": 36, "concepts": ["breadth-first search (BFS) algorithm for graph traversal", "tomato farming simulation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 3\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 4\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 6\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 7\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 9\n### Snippet\nvoid loop() {\n  measureAndCalculateRMS();\n  sendValuesAsIntegerPerPrint(rmsFrontSensor, rmsBackSensor);\n}\n\n### Concepts", "fingerprint": null, "seed": "void loop() {\n  measureAndCalculateRMS();\n  sendValuesAsIntegerPerPrint(rmsFrontSensor, rmsBackSensor);\n}", "id": 37, "concepts": ["main loop for continuous operation", "RMS measurement and calculation", "integer transmission per print"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 2\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 4\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 5\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 8\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 9\n### Snippet\nint main() {\n    ProductManager manager;\n\n    while (manager.canAddProduct()) {\n        handleUI(manager);\n    }\n}\n\n### Concepts", "fingerprint": null, "seed": "int main() {\n    ProductManager manager;\n\n    while (manager.canAddProduct()) {\n        handleUI(manager);\n    }\n}", "id": 38, "concepts": ["product management system", "user interface handling", "program flow control"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 2\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 5\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 6\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 8\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 9\n### Snippet\nint main()\r\n{\r\n  deque<int> coll;\r\n  for(int i=1; i<=9; ++i) {\r\n    coll.push_back(i);\r\n    coll.push_front(i);\r\n  }\r\n  PrintAll(coll, \"coll default without sort\");\r\n  sort(coll.begin(), coll.end());\r\n  PrintAll(coll, \"coll sort default\");\r\n  \r\n  sort(coll.begin(), coll.end(), greater<int>());\r\n  PrintAll(coll, \"coll sort greater\");\r\n  return 0;\r\n}\n\n### Concepts", "fingerprint": null, "seed": "int main()\r\n{\r\n  deque<int> coll;\r\n  for(int i=1; i<=9; ++i) {\r\n    coll.push_back(i);\r\n    coll.push_front(i);\r\n  }\r\n  PrintAll(coll, \"coll default without sort\");\r\n  sort(coll.begin(), coll.end());\r\n  PrintAll(coll, \"coll sort default\");\r\n  \r\n  sort(coll.begin(), coll.end(), greater<int>());\r\n  PrintAll(coll, \"coll sort greater\");\r\n  return 0;\r\n}", "id": 39, "concepts": ["data structure initialization", "element insertion", "sorting with predicates"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 2\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 3\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 4\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 8\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 9\n### Snippet\nvoid DisplayItem(InventoryItem* const e)\n{\n   for(int index = 0; index < 5; index++)\n   {\n\t   cout << setw(5) << index + 1\n\t\t   << setw(20) << e[index].getDescription()\n\t\t   << setw(20) << e[index].getUnits() << endl;\n   }\n}\n\n### Concepts", "fingerprint": null, "seed": "void DisplayItem(InventoryItem* const e)\n{\n   for(int index = 0; index < 5; index++)\n   {\n\t   cout << setw(5) << index + 1\n\t\t   << setw(20) << e[index].getDescription()\n\t\t   << setw(20) << e[index].getUnits() << endl;\n   }\n}", "id": 40, "concepts": ["layout and formatting for tabular data", "indexing and iteration for array access"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 7\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 8\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 9\n### Snippet\nint main()\r\n{\r\n\tint T;\r\n\tcin >> T;\r\n\twhile (T--) {\r\n\t\tint N, M;\r\n\t\tcin >> N >> M;\r\n\t\tint u, v;\r\n\t\tGraph g(N);\r\n\t\twhile (M--) {\r\n\t\t\tcin >> u >> v;\r\n\t\t\tg.addEdge(u, v);\r\n\t\t}\r\n\t\tint s, e;\r\n\t\tcin >> s >> e;\r\n\t\tcout << g.countPaths(s, e) << endl;\r\n\t}\r\n\treturn 0;\r\n}\n\n### Concepts", "fingerprint": null, "seed": "int main()\r\n{\r\n\tint T;\r\n\tcin >> T;\r\n\twhile (T--) {\r\n\t\tint N, M;\r\n\t\tcin >> N >> M;\r\n\t\tint u, v;\r\n\t\tGraph g(N);\r\n\t\twhile (M--) {\r\n\t\t\tcin >> u >> v;\r\n\t\t\tg.addEdge(u, v);\r\n\t\t}\r\n\t\tint s, e;\r\n\t\tcin >> s >> e;\r\n\t\tcout << g.countPaths(s, e) << endl;\r\n\t}\r\n\treturn 0;\r\n}", "id": 41, "concepts": ["graph traversal", "depth-first search", "breadth-first search", "count paths from one node to another"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 2\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 4\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 5\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 9\n### Snippet\nvoid update_status() {    \n    if (!occupied && auto_mode)\n        if (num_hits > 1)    // at least two sensors fired - occupy the room\n            occupy_room();\n    if (num_hits > 0)        // at least one fired; so the room is in use\n          tick_counter = 0;  // keep resetting it, if there is any motion\n    tick_counter++;          // Note: the sensors can keep tick_counter perpetually zero! So,\n    status_counter++;        // you need a separate status_counter\n\n    if (status_counter == status_ticks) { \n        send_status();\n        status_counter = 0;\n    }\n    if (tick_counter == buzzer_ticks) {\n        if (occupied && auto_mode)\n            warn();  // warn about the imminent release\n    }\n    else        \n    if (tick_counter >= release_ticks){\n         tick_counter = 0;\n         if (occupied && auto_mode)\n            release_room();  \n    }  \n}\n\n### Concepts", "fingerprint": null, "seed": "void update_status() {    \n    if (!occupied && auto_mode)\n        if (num_hits > 1)    // at least two sensors fired - occupy the room\n            occupy_room();\n    if (num_hits > 0)        // at least one fired; so the room is in use\n          tick_counter = 0;  // keep resetting it, if there is any motion\n    tick_counter++;          // Note: the sensors can keep tick_counter perpetually zero! So,\n    status_counter++;        // you need a separate status_counter\n\n    if (status_counter == status_ticks) { \n        send_status();\n        status_counter = 0;\n    }\n    if (tick_counter == buzzer_ticks) {\n        if (occupied && auto_mode)\n            warn();  // warn about the imminent release\n    }\n    else        \n    if (tick_counter >= release_ticks){\n         tick_counter = 0;\n         if (occupied && auto_mode)\n            release_room();  \n    }  \n}", "id": 42, "concepts": ["event-driven programming", "state-machine design", "sensor handling"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 2\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 4\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 5\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 8\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 9\n### Snippet\nvoid beeper (int mode) {\n    switch (mode) {\n      case 0: // useful before entering T.update loop\n          digitalWrite(buzzer, LOW);  // active low\n          delay(200);  \n          digitalWrite(buzzer, HIGH);\n          break;\n      case 1:\n          T.pulse(buzzer, 4000, HIGH); // active low\n          break;\n      default:\n          T.pulse(buzzer, 200, HIGH); // active low\n          break;\n    }\n}\n\n### Concepts", "fingerprint": null, "seed": "void beeper (int mode) {\n    switch (mode) {\n      case 0: // useful before entering T.update loop\n          digitalWrite(buzzer, LOW);  // active low\n          delay(200);  \n          digitalWrite(buzzer, HIGH);\n          break;\n      case 1:\n          T.pulse(buzzer, 4000, HIGH); // active low\n          break;\n      default:\n          T.pulse(buzzer, 200, HIGH); // active low\n          break;\n    }\n}", "id": 43, "concepts": ["beeping mechanism for different modes", "active-low buzzer control", "switch-case to handle different actions"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 4\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 5\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 6\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 8\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 9\n### Snippet\nint gcd(int a,int b)\n{\n    if(b==0)\n    {\n        return a;\n    }\n\n    return(gcd(b,a%b));\n}\n\n### Concepts", "fingerprint": null, "seed": "int gcd(int a,int b)\n{\n    if(b==0)\n    {\n        return a;\n    }\n\n    return(gcd(b,a%b));\n}", "id": 44, "concepts": ["recursive function", "base case", "modulo operation", "Euclidean algorithm"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 2\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 3\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 7\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 8\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 9\n### Snippet\nvoid loop() {\n    T.update();   \n    mesh.update();   // keep the network updated\n}\n\n### Concepts", "fingerprint": null, "seed": "void loop() {\n    T.update();   \n    mesh.update();   // keep the network updated\n}", "id": 45, "concepts": ["looping through code", "updating a network"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 3\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 4\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 5\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 6\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 9\n### Snippet\nint main(int argc, char** argv)\r\n{\r\n\r\n\tint next_option;\r\n\r\n\t/* A string listing valid short options letters.  */\r\n\tconst char* const short_options = \"hc:sxgvna:\";\r\n\t/* An array describing valid long options.  */\r\n\tconst struct option long_options[] =\r\n\t{\r\n\t{ \"help\", 0, NULL, 'h' },\r\n\t{ \"config\", 1, NULL, 'c' },\r\n\t{ \"standard\", 0, NULL, 's' },\r\n\t{ \"xml\", 0, NULL, 'x' },\r\n\t{ \"graphic\", 0, NULL, 'g' },\r\n\t{ \"verbose\", 0, NULL, 'v' },\r\n\t{ \"height\", 1, NULL, 'e' },\r\n\t{ \"width\", 1, NULL, 'w' },\r\n\t{ \"rough\", 1, NULL, 'r' },\r\n\t{ \"seed\", 1, NULL, 'd' },\r\n\t{ \"offset\", 1, NULL, 'f' },\r\n\t{ \"plate\", 1, NULL, 'p' },\r\n\t{ \"erosion\", 1, NULL, 'o' },\r\n\t{ \"negative\", 0, NULL, 'n' },\r\n\t{ \"randomseed\", 1, NULL, 'a' },\r\n\t{ NULL, 0, NULL, 0 } /* Required at end of array.  */\r\n\t};\r\n\r\n\t/* Remember the name of the program, to incorporate in messages.\r\n\t The name is stored in argv[0].  */\r\n\tchar* program_name = argv[0];\r\n\r\n\tif (fopen(config_file.c_str(), \"r\"))\r\n\t\tread_json_config();\r\n\r\n\tdo\r\n\t{\r\n\r\n\t\tnext_option = getopt_long(argc, argv, short_options, long_options,\r\n\t\t\t\tNULL);\r\n\t\tswitch (next_option)\r\n\t\t{\r\n\t\tcase 'h': /* -h or --help */\r\n\t\t\t/* User has requested usage information.  Print it to standard\r\n\t\t\t output, and exit with exit code zero (normal termination).  */\r\n\t\t\tprint_usage(stdout, 0, program_name);\r\n\t\t\tbreak;\r\n\r\n\t\t\tcase 'c': //config file\r\n\r\n\t\t\t\t\tif(strcmp(config_file.c_str(),optarg) != 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tconfig_file = optarg;\r\n\t\t\t\t\t\tread_json_config();\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 's': /* -s --standard */\r\n\r\n\t\t\t\t\t//Use default output format\r\n\t\t\t\t\t//do nothing\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'x': /* -x --xml*/\r\n\r\n\t\t\t\t\t//Use xml output format\r\n\t\t\t\t\toutput_format = STANDARD_XML;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'g': /* -g --graphical*/\r\n\r\n\t\t\t\t\t//Display the map as 3d opengl representation\r\n\t\t\t\t\toutput_format = OPENGL_VIEW;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'v': /* -v or --verbose */\r\n\t\t\t\t\tverbose = 1;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'e': /* --height use next argument as crop height */\r\n\r\n\t\t\t\t\tcrop_height = atoi(optarg);\r\n\t\t\t\t\tif(crop_height < 1)\r\n\t\t\t\t\tprint_usage(stderr, 1, program_name);\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'w': /* --width use next argument as crop width */\r\n\r\n\t\t\t\t\tcrop_width = atoi(optarg);\r\n\t\t\t\t\tif(crop_width < 1)\r\n\t\t\t\t\tprint_usage(stderr, 1, program_name);\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'r': /* --rough roughness ratio */\r\n\r\n\t\t\t\t\toffset_dr = atof(optarg);\r\n\t\t\t\t\tif(offset_dr<0 || offset_dr>1)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tprint_usage(stderr, 1, program_name);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'd': /* --seed value */\r\n\r\n\t\t\t\t\tseed = atoi(optarg);\r\n\t\t\t\t\tif(seed<0)\r\n\t\t\t\t\tprint_usage(stderr, 1, program_name);\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'f': /* --offset value */\r\n\r\n\t\t\t\t\trandom_offset = atoi(optarg);\r\n\t\t\t\t\tif(random_offset<0)\r\n\t\t\t\t\tprint_usage(stderr, 1, program_name);\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'p': /* --plate  vonornoi interpolation value */\r\n\r\n\t\t\t\t\tvoronoi_alpha = atof(optarg);\r\n\t\t\t\t\tif(voronoi_alpha<0 || voronoi_alpha>1)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tprint_usage(stderr, 1, program_name);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'o': /* --erosion number of erosion iterations */\r\n\r\n\t\t\t\t\terosion_steps = atoi(optarg);\r\n\t\t\t\t\tif(erosion_steps<0)\r\n\t\t\t\t\tprint_usage(stderr, 1, program_name);\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'n': /* allow negative values */\r\n\r\n\t\t\t\t\tneg = true;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'a': /* random seed value */\r\n\r\n//\t\t\tsrand ( time(NULL) );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase '?': /* The user specified an invalid option.  */\r\n\t\t\t\t\t/* Print usage information to standard error, and exit with exit\r\n\t\t\t\t\t code one (indicating abnormal termination).  */\r\n\t\t\t\t\tprint_usage(stderr, 1, program_name);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase -1: /* Done with options.  */\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault: /* Something else: unexpected.  */\r\n\t\t\t\t\tabort();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t} while (next_option != -1);\r\n\r\n\tgenerate();\r\n\r\n\treturn 0;\r\n}\n\n### Concepts", "fingerprint": null, "seed": "int main(int argc, char** argv)\r\n{\r\n\r\n\tint next_option;\r\n\r\n\t/* A string listing valid short options letters.  */\r\n\tconst char* const short_options = \"hc:sxgvna:\";\r\n\t/* An array describing valid long options.  */\r\n\tconst struct option long_options[] =\r\n\t{\r\n\t{ \"help\", 0, NULL, 'h' },\r\n\t{ \"config\", 1, NULL, 'c' },\r\n\t{ \"standard\", 0, NULL, 's' },\r\n\t{ \"xml\", 0, NULL, 'x' },\r\n\t{ \"graphic\", 0, NULL, 'g' },\r\n\t{ \"verbose\", 0, NULL, 'v' },\r\n\t{ \"height\", 1, NULL, 'e' },\r\n\t{ \"width\", 1, NULL, 'w' },\r\n\t{ \"rough\", 1, NULL, 'r' },\r\n\t{ \"seed\", 1, NULL, 'd' },\r\n\t{ \"offset\", 1, NULL, 'f' },\r\n\t{ \"plate\", 1, NULL, 'p' },\r\n\t{ \"erosion\", 1, NULL, 'o' },\r\n\t{ \"negative\", 0, NULL, 'n' },\r\n\t{ \"randomseed\", 1, NULL, 'a' },\r\n\t{ NULL, 0, NULL, 0 } /* Required at end of array.  */\r\n\t};\r\n\r\n\t/* Remember the name of the program, to incorporate in messages.\r\n\t The name is stored in argv[0].  */\r\n\tchar* program_name = argv[0];\r\n\r\n\tif (fopen(config_file.c_str(), \"r\"))\r\n\t\tread_json_config();\r\n\r\n\tdo\r\n\t{\r\n\r\n\t\tnext_option = getopt_long(argc, argv, short_options, long_options,\r\n\t\t\t\tNULL);\r\n\t\tswitch (next_option)\r\n\t\t{\r\n\t\tcase 'h': /* -h or --help */\r\n\t\t\t/* User has requested usage information.  Print it to standard\r\n\t\t\t output, and exit with exit code zero (normal termination).  */\r\n\t\t\tprint_usage(stdout, 0, program_name);\r\n\t\t\tbreak;\r\n\r\n\t\t\tcase 'c': //config file\r\n\r\n\t\t\t\t\tif(strcmp(config_file.c_str(),optarg) != 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tconfig_file = optarg;\r\n\t\t\t\t\t\tread_json_config();\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 's': /* -s --standard */\r\n\r\n\t\t\t\t\t//Use default output format\r\n\t\t\t\t\t//do nothing\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'x': /* -x --xml*/\r\n\r\n\t\t\t\t\t//Use xml output format\r\n\t\t\t\t\toutput_format = STANDARD_XML;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'g': /* -g --graphical*/\r\n\r\n\t\t\t\t\t//Display the map as 3d opengl representation\r\n\t\t\t\t\toutput_format = OPENGL_VIEW;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'v': /* -v or --verbose */\r\n\t\t\t\t\tverbose = 1;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'e': /* --height use next argument as crop height */\r\n\r\n\t\t\t\t\tcrop_height = atoi(optarg);\r\n\t\t\t\t\tif(crop_height < 1)\r\n\t\t\t\t\tprint_usage(stderr, 1, program_name);\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'w': /* --width use next argument as crop width */\r\n\r\n\t\t\t\t\tcrop_width = atoi(optarg);\r\n\t\t\t\t\tif(crop_width < 1)\r\n\t\t\t\t\tprint_usage(stderr, 1, program_name);\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'r': /* --rough roughness ratio */\r\n\r\n\t\t\t\t\toffset_dr = atof(optarg);\r\n\t\t\t\t\tif(offset_dr<0 || offset_dr>1)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tprint_usage(stderr, 1, program_name);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'd': /* --seed value */\r\n\r\n\t\t\t\t\tseed = atoi(optarg);\r\n\t\t\t\t\tif(seed<0)\r\n\t\t\t\t\tprint_usage(stderr, 1, program_name);\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'f': /* --offset value */\r\n\r\n\t\t\t\t\trandom_offset = atoi(optarg);\r\n\t\t\t\t\tif(random_offset<0)\r\n\t\t\t\t\tprint_usage(stderr, 1, program_name);\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'p': /* --plate  vonornoi interpolation value */\r\n\r\n\t\t\t\t\tvoronoi_alpha = atof(optarg);\r\n\t\t\t\t\tif(voronoi_alpha<0 || voronoi_alpha>1)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tprint_usage(stderr, 1, program_name);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'o': /* --erosion number of erosion iterations */\r\n\r\n\t\t\t\t\terosion_steps = atoi(optarg);\r\n\t\t\t\t\tif(erosion_steps<0)\r\n\t\t\t\t\tprint_usage(stderr, 1, program_name);\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'n': /* allow negative values */\r\n\r\n\t\t\t\t\tneg = true;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'a': /* random seed value */\r\n\r\n//\t\t\tsrand ( time(NULL) );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase '?': /* The user specified an invalid option.  */\r\n\t\t\t\t\t/* Print usage information to standard error, and exit with exit\r\n\t\t\t\t\t code one (indicating abnormal termination).  */\r\n\t\t\t\t\tprint_usage(stderr, 1, program_name);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase -1: /* Done with options.  */\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault: /* Something else: unexpected.  */\r\n\t\t\t\t\tabort();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t} while (next_option != -1);\r\n\r\n\tgenerate();\r\n\r\n\treturn 0;\r\n}", "id": 46, "concepts": ["command-line argument parsing", "JSON configuration parsing", "graphical output", "error handling", "usage information generation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 2\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 5\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 7\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 8\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 9\n### Snippet\nint main(int argc, char *argv[]) {\n    SwarmValues *v = new SwarmValues();\n    v->proj_weight = 0;\n    v->align_weight = 0;\n    v->noise_weight = 1-v->proj_weight-v->align_weight;\n\n    environment_food_init(200);\n    Environment *env = new Environment();\n    env->onDraw = &environment_food_onDraw;\n    env->onFrame = &environment_food_onFrame;\n\n/*\n    //environment_food_init(200);\n    Environment *env = new Environment();\n    env->onDraw = &environment_displacement_onDraw;\n    env->onFrame = &environment_displacement_onFrame;\n*/\n    Simulation *s = new Simulation(50, v);\n    s->reset();\n    s->setEnvironment(env); //uncomment this to add an environment\n\n    //s->runSimulation(10000);\n\n    double i, j;\n    int k;\n    double step = 0.04;\n    #define SAMPLE_NUMBER 7\n    #define RUN_TIME 1000\n\n    float progress = 0.0;\n    float progress_step_size = 1.0/(float)( ((1/step)*(1/step))/2);\n    //                                      ^Points in a grid      \n\n    long start_time = time(NULL);\n\n    cerr << endl;\n    cerr << \"                                                                   \\r\";\n\n        cout << \"  [\" << endl; //Grid start\n        for(i=0.0; i<1.0; i+=step) {\n            cout << \"    [\" << endl; //Row start\n            for(j=0.0; j<1.0; j+=step) {\n                long long value_a[SAMPLE_NUMBER] = {0};\n                if(i+j<=1.0) {\n                    //long runCount = 0;\n                    for(k=0; k<SAMPLE_NUMBER; k++) {\n                        s->reset();\n                        srand(time(NULL) ^ (k<<8) ^ ((int)i<<16) ^ ((int)j<<24));\n                        v->proj_weight = i;\n                        v->align_weight = j;\n                        v->noise_weight = 1 - v->proj_weight - v->align_weight;\n                        s->setSwarmValues(v);\n                        //environment_displacement_init(200);\n                        environment_food_init(200);\n                        s->setScore(0);\n                        s->runSimulation(RUN_TIME);\n                        environment_food_destroy();\n                        //if(s->getScore() >=0) {\n                           // runCount++;\n                            value_a[k] = s->getScore();\n                        //}\n                        //environment_displacement_destroy();\n                    }\n                    sort(value_a, value_a+SAMPLE_NUMBER);\n                    cout << \"      [\"; //COL start\n                    for(int a=0; a<SAMPLE_NUMBER; a++) {\n                        cout<<value_a[a];\n                        if(a != SAMPLE_NUMBER-1) cout << \",\";\n                    }\n                    cout << \"],\" << endl; //COL end\n\n                    //Give an indication of the progress so far\n                    progress += progress_step_size;\n\n                    long time_taken = time(NULL)-start_time;\n                    long total_time_prediction = time_taken * 1/progress;\n\n                    // Carriage return (\\r) makes it re-write the line again\n                    // with the up to date information\n                    cerr << \"\\r Progress: \";\n\n                    fprintf(stderr, \"%5.2f\", progress*100 );\n                    cerr << \"%   Remaining: \" \n                            << ((total_time_prediction-time_taken)/60.0)\n                            << \"min       \\r\";\n                } else {\n                    cout << \"      [],\" << endl;\n                }\n                //cout << value << \" \";\n            }\n            cout << \"      []\" << endl; //To fix the floating comma in the row\n            cout << \"    ],\" << endl; //ROW end\n        }\n        cout << \"    []\" << endl; //To fix the floating comma in the column\n        cout << \"  ]\" << endl; // end GRID\n\n\n    //Print info on the time taken\n    cerr << endl << endl;\n    long time_taken = time(NULL)-start_time;\n    int hours = floor(time_taken/(60*60));\n    int mins = floor((time_taken%60)/(60));\n    int secs = floor((time_taken%(60*60)));\n    cerr << \"Time taken: \"\n            << hours << \"h \"\n            << mins  << \"m \"\n            << secs   << \"s\"\n            << \"  (\" << time_taken << \"s)\"\n            << endl;\n\n    delete s;\n    delete v;\n    delete env;\n}\n\n### Concepts", "fingerprint": null, "seed": "int main(int argc, char *argv[]) {\n    SwarmValues *v = new SwarmValues();\n    v->proj_weight = 0;\n    v->align_weight = 0;\n    v->noise_weight = 1-v->proj_weight-v->align_weight;\n\n    environment_food_init(200);\n    Environment *env = new Environment();\n    env->onDraw = &environment_food_onDraw;\n    env->onFrame = &environment_food_onFrame;\n\n/*\n    //environment_food_init(200);\n    Environment *env = new Environment();\n    env->onDraw = &environment_displacement_onDraw;\n    env->onFrame = &environment_displacement_onFrame;\n*/\n    Simulation *s = new Simulation(50, v);\n    s->reset();\n    s->setEnvironment(env); //uncomment this to add an environment\n\n    //s->runSimulation(10000);\n\n    double i, j;\n    int k;\n    double step = 0.04;\n    #define SAMPLE_NUMBER 7\n    #define RUN_TIME 1000\n\n    float progress = 0.0;\n    float progress_step_size = 1.0/(float)( ((1/step)*(1/step))/2);\n    //                                      ^Points in a grid      \n\n    long start_time = time(NULL);\n\n    cerr << endl;\n    cerr << \"                                                                   \\r\";\n\n        cout << \"  [\" << endl; //Grid start\n        for(i=0.0; i<1.0; i+=step) {\n            cout << \"    [\" << endl; //Row start\n            for(j=0.0; j<1.0; j+=step) {\n                long long value_a[SAMPLE_NUMBER] = {0};\n                if(i+j<=1.0) {\n                    //long runCount = 0;\n                    for(k=0; k<SAMPLE_NUMBER; k++) {\n                        s->reset();\n                        srand(time(NULL) ^ (k<<8) ^ ((int)i<<16) ^ ((int)j<<24));\n                        v->proj_weight = i;\n                        v->align_weight = j;\n                        v->noise_weight = 1 - v->proj_weight - v->align_weight;\n                        s->setSwarmValues(v);\n                        //environment_displacement_init(200);\n                        environment_food_init(200);\n                        s->setScore(0);\n                        s->runSimulation(RUN_TIME);\n                        environment_food_destroy();\n                        //if(s->getScore() >=0) {\n                           // runCount++;\n                            value_a[k] = s->getScore();\n                        //}\n                        //environment_displacement_destroy();\n                    }\n                    sort(value_a, value_a+SAMPLE_NUMBER);\n                    cout << \"      [\"; //COL start\n                    for(int a=0; a<SAMPLE_NUMBER; a++) {\n                        cout<<value_a[a];\n                        if(a != SAMPLE_NUMBER-1) cout << \",\";\n                    }\n                    cout << \"],\" << endl; //COL end\n\n                    //Give an indication of the progress so far\n                    progress += progress_step_size;\n\n                    long time_taken = time(NULL)-start_time;\n                    long total_time_prediction = time_taken * 1/progress;\n\n                    // Carriage return (\\r) makes it re-write the line again\n                    // with the up to date information\n                    cerr << \"\\r Progress: \";\n\n                    fprintf(stderr, \"%5.2f\", progress*100 );\n                    cerr << \"%   Remaining: \" \n                            << ((total_time_prediction-time_taken)/60.0)\n                            << \"min       \\r\";\n                } else {\n                    cout << \"      [],\" << endl;\n                }\n                //cout << value << \" \";\n            }\n            cout << \"      []\" << endl; //To fix the floating comma in the row\n            cout << \"    ],\" << endl; //ROW end\n        }\n        cout << \"    []\" << endl; //To fix the floating comma in the column\n        cout << \"  ]\" << endl; // end GRID\n\n\n    //Print info on the time taken\n    cerr << endl << endl;\n    long time_taken = time(NULL)-start_time;\n    int hours = floor(time_taken/(60*60));\n    int mins = floor((time_taken%60)/(60));\n    int secs = floor((time_taken%(60*60)));\n    cerr << \"Time taken: \"\n            << hours << \"h \"\n            << mins  << \"m \"\n            << secs   << \"s\"\n            << \"  (\" << time_taken << \"s)\"\n            << endl;\n\n    delete s;\n    delete v;\n    delete env;\n}", "id": 47, "concepts": ["value iteration", "2D grid traversal", "sample collection", "progress tracking", "time estimation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 4\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 5\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 7\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 8\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 9\n### Snippet\nint main(int argc, char *argv[]) {\n    Elev elev;\n    cout << elev.GetAge() << endl;\n    ++elev;\n    cout << elev.GetAge() << endl;\n    elev++;\n    cout << elev.GetAge() << endl;\n    return 0;\n}\n\n### Concepts", "fingerprint": null, "seed": "int main(int argc, char *argv[]) {\n    Elev elev;\n    cout << elev.GetAge() << endl;\n    ++elev;\n    cout << elev.GetAge() << endl;\n    elev++;\n    cout << elev.GetAge() << endl;\n    return 0;\n}", "id": 48, "concepts": ["operator overloading for `++` and custom type `Elev`", "encapsulation and abstraction"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 3\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 4\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 7\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 8\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 9\n### Snippet\nvoid p2(Node *h){\n\tNode *p = h;\n\twhile(p){\n\t\tNode *pn = p->next;\n\t\tif(pn == NULL || (pn->c != '(' &&\n\t\t   pn->c != '[' &&\n\t\t   pn->c != ' ' &&\n\t\t   pn->c != '{' &&\n\t\t   pn->c != '<')){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tNode *pnn = pn->next;\n\t\tif(pnn == NULL || pnn->c != '\\\"'){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n//\t\tcout<<\"p2\"<<endl;\n\t\tNode *node;\n\t\tnode = new Node(' ');\n\t\tpn = insert(pn,node);\n\t\tnode = new Node('`');\n\t\tpn = insert(pn,node);\n\t\tnode = new Node('`');\n\t\tpn = insert(pn,node);\n\t\tnode = new Node(' ');\n\t\tpn = insert(pn,node);\n\t\t\n\t\tdel(pn);\n\t\tp = pn;\n\t}\n}\n\n### Concepts", "fingerprint": null, "seed": "void p2(Node *h){\n\tNode *p = h;\n\twhile(p){\n\t\tNode *pn = p->next;\n\t\tif(pn == NULL || (pn->c != '(' &&\n\t\t   pn->c != '[' &&\n\t\t   pn->c != ' ' &&\n\t\t   pn->c != '{' &&\n\t\t   pn->c != '<')){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tNode *pnn = pn->next;\n\t\tif(pnn == NULL || pnn->c != '\\\"'){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n//\t\tcout<<\"p2\"<<endl;\n\t\tNode *node;\n\t\tnode = new Node(' ');\n\t\tpn = insert(pn,node);\n\t\tnode = new Node('`');\n\t\tpn = insert(pn,node);\n\t\tnode = new Node('`');\n\t\tpn = insert(pn,node);\n\t\tnode = new Node(' ');\n\t\tpn = insert(pn,node);\n\t\t\n\t\tdel(pn);\n\t\tp = pn;\n\t}\n}", "id": 49, "concepts": ["node insertion", "node deletion", "special character handling", "text formatting"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 2\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 6\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 9\n### Snippet\nstatic int8_t CDC_Init_FS(void)\r\n{\r\n    /* USER CODE BEGIN 3 */\r\n    /* Set Application Buffers */\r\n    USBD_CDC_SetTxBuffer(&hUsbDeviceFS, UserTxBufferFS, 0);\r\n    USBD_CDC_SetRxBuffer(&hUsbDeviceFS, UserRxBufferFS);\r\n    return (USBD_OK);\r\n    /* USER CODE END 3 */\r\n}\n\n### Concepts", "fingerprint": null, "seed": "static int8_t CDC_Init_FS(void)\r\n{\r\n    /* USER CODE BEGIN 3 */\r\n    /* Set Application Buffers */\r\n    USBD_CDC_SetTxBuffer(&hUsbDeviceFS, UserTxBufferFS, 0);\r\n    USBD_CDC_SetRxBuffer(&hUsbDeviceFS, UserRxBufferFS);\r\n    return (USBD_OK);\r\n    /* USER CODE END 3 */\r\n}", "id": 50, "concepts": ["API function call for USB initialization", "memory allocation for data buffers", "return value handling for status"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 4\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 5\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 7\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 8\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 9\n### Snippet\nvoid setup()\n{\n}\n\n### Concepts", "fingerprint": null, "seed": "void setup()\n{\n}", "id": 51, "concepts": ["setup function for initialization", "state preparation", "dependency resolution"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 4\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 5\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 6\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 7\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 9\n### Snippet\nvoid fpcM_PauseDisable(void* pProc, u8 param_2) {\n    fpcPause_Disable((process_node_class*)pProc, param_2 & 0xFF);\n}\n\n### Concepts", "fingerprint": null, "seed": "void fpcM_PauseDisable(void* pProc, u8 param_2) {\n    fpcPause_Disable((process_node_class*)pProc, param_2 & 0xFF);\n}", "id": 52, "concepts": ["function pointer call", "parameter passing and processing", "bitwise operation for masking"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 4\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 5\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 6\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 7\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 8\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 9\n### Snippet\nvoid DiscreteMasterProperty__bool___ObjInit_2(DiscreteMasterProperty__bool* __this, ::app::Uno::UX::Property__bool* property, ::app::Fuse::Animations::MixerBase* mixerBase)\n{\n    ::app::Fuse::Animations::MasterProperty__bool___ObjInit_1(__this, property, mixerBase);\n}\n\n### Concepts", "fingerprint": null, "seed": "void DiscreteMasterProperty__bool___ObjInit_2(DiscreteMasterProperty__bool* __this, ::app::Uno::UX::Property__bool* property, ::app::Fuse::Animations::MixerBase* mixerBase)\n{\n    ::app::Fuse::Animations::MasterProperty__bool___ObjInit_1(__this, property, mixerBase);\n}", "id": 53, "concepts": ["C++ class definition", "function signature", "object initialization"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 3\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 6\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 7\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 9\n### Snippet\nvoid DiscreteMasterProperty__float__OnComplete(DiscreteMasterProperty__float* __this)\n{\n    float nv = __this->RestValue();\n    float str = 0.5f;\n\n    for (::app::Uno::Collections::List1_Enumerator__Fuse_Animations_MixerHandle_float_ enum_123 = ::uPtr< ::app::Uno::Collections::List__Fuse_Animations_MixerHandle_float_*>(__this->Handles)->GetEnumerator(); enum_123.MoveNext(); )\n    {\n        ::app::Fuse::Animations::MixerHandle__float* v = enum_123.Current();\n\n        if (::uPtr< ::app::Fuse::Animations::MixerHandle__float*>(v)->HasValue() && (::uPtr< ::app::Fuse::Animations::MixerHandle__float*>(v)->Strength > str))\n        {\n            nv = ::uPtr< ::app::Fuse::Animations::MixerHandle__float*>(v)->Value;\n            str = v->Strength;\n        }\n    }\n\n    ::uPtr< ::app::Uno::UX::Property__float*>(__this->Property)->Set(nv, (::uObject*)__this);\n}\n\n### Concepts", "fingerprint": null, "seed": "void DiscreteMasterProperty__float__OnComplete(DiscreteMasterProperty__float* __this)\n{\n    float nv = __this->RestValue();\n    float str = 0.5f;\n\n    for (::app::Uno::Collections::List1_Enumerator__Fuse_Animations_MixerHandle_float_ enum_123 = ::uPtr< ::app::Uno::Collections::List__Fuse_Animations_MixerHandle_float_*>(__this->Handles)->GetEnumerator(); enum_123.MoveNext(); )\n    {\n        ::app::Fuse::Animations::MixerHandle__float* v = enum_123.Current();\n\n        if (::uPtr< ::app::Fuse::Animations::MixerHandle__float*>(v)->HasValue() && (::uPtr< ::app::Fuse::Animations::MixerHandle__float*>(v)->Strength > str))\n        {\n            nv = ::uPtr< ::app::Fuse::Animations::MixerHandle__float*>(v)->Value;\n            str = v->Strength;\n        }\n    }\n\n    ::uPtr< ::app::Uno::UX::Property__float*>(__this->Property)->Set(nv, (::uObject*)__this);\n}", "id": 54, "concepts": ["discrete master property implementation", "mixer handle management", "float value handling", "property update"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 4\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 5\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 7\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 9\n### Snippet\nfloat getFilteredSignal(int pin_x, int pin_y, int pin_z)\n{\n  float instant_value_x = analogRead(pin_x) - mean_x;\n  float instant_value_y = analogRead(pin_y) - mean_y;\n  float instant_value_z = analogRead(pin_z) - mean_z;\n\n  float instant_value = sqrt(pow(instant_value_x,2) + pow(instant_value_y,2) + pow(instant_value_z,2));\n  accel_values_put(instant_value);\n  float result = RMS(accel_values);\n\n  return result;\n}\n\n### Concepts", "fingerprint": null, "seed": "float getFilteredSignal(int pin_x, int pin_y, int pin_z)\n{\n  float instant_value_x = analogRead(pin_x) - mean_x;\n  float instant_value_y = analogRead(pin_y) - mean_y;\n  float instant_value_z = analogRead(pin_z) - mean_z;\n\n  float instant_value = sqrt(pow(instant_value_x,2) + pow(instant_value_y,2) + pow(instant_value_z,2));\n  accel_values_put(instant_value);\n  float result = RMS(accel_values);\n\n  return result;\n}", "id": 55, "concepts": ["signal processing", "square root approximation", "array manipulation", "RMS calculation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 3\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 6\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 7\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 8\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 9\n### Snippet\nvoid release_room() {\n    if (!NORELAY)  \n        digitalWrite(relay, LOW);  // active high  \n    occupied = false; \n    send_status(); \n}\n\n### Concepts", "fingerprint": null, "seed": "void release_room() {\n    if (!NORELAY)  \n        digitalWrite(relay, LOW);  // active high  \n    occupied = false; \n    send_status(); \n}", "id": 56, "concepts": ["I/O control", "relay activation", "room occupancy state tracking"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 3\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 4\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 6\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 9\n### Snippet\nint main()\n{    \n    Game game;\n    if(!game.init())\n        return EXIT_FAILURE;    \n\n    return game.run();\n}\n\n### Concepts", "fingerprint": null, "seed": "int main()\n{    \n    Game game;\n    if(!game.init())\n        return EXIT_FAILURE;    \n\n    return game.run();\n}", "id": 57, "concepts": ["game loop", "game state management", "game logic implementation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 5\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 6\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 9\n### Snippet\nstatic int8_t CDC_Receive_FS(uint8_t* Buf, uint32_t *Len)\r\n{\r\n    /* USER CODE BEGIN 6 */\r\n    uint8_t n = *Len;\r\n    uint8_t i;\r\n    for (i = 0; i < n; i++)\r\n    {\r\n        if (Buf[i] == '\\r')\r\n        {\r\n            //slcan_parse_str(slcan_str, slcan_str_index);\r\n            //slcan_str_index = 0;\r\n\r\n            auto result = slcan_parse_str(slcan_str, slcan_str_index);\r\n            slcan_str_index = 0;\r\n\r\n            if(result == -1)\r\n            {\r\n                CDC_Transmit_FS((uint8_t *)\"\\a\", 1);\r\n            }\r\n            else if(result == 0)\r\n            {\r\n                CDC_Transmit_FS((uint8_t *)\"\\r\", 1);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            slcan_str[slcan_str_index++] = Buf[i];\r\n        }\r\n    }\r\n\r\n\r\n    // prepare for next read\r\n    //USBD_CDC_SetRxBuffer(hUsbDevice_0, UserRxBufferFS);\r\n    //USBD_CDC_ReceivePacket(hUsbDevice_0);\r\n\r\n    USBD_CDC_SetRxBuffer(&hUsbDeviceFS, &Buf[0]);\r\n    USBD_CDC_ReceivePacket(&hUsbDeviceFS);\r\n    return (USBD_OK);\r\n    /* USER CODE END 6 */\r\n}\n\n### Concepts", "fingerprint": null, "seed": "static int8_t CDC_Receive_FS(uint8_t* Buf, uint32_t *Len)\r\n{\r\n    /* USER CODE BEGIN 6 */\r\n    uint8_t n = *Len;\r\n    uint8_t i;\r\n    for (i = 0; i < n; i++)\r\n    {\r\n        if (Buf[i] == '\\r')\r\n        {\r\n            //slcan_parse_str(slcan_str, slcan_str_index);\r\n            //slcan_str_index = 0;\r\n\r\n            auto result = slcan_parse_str(slcan_str, slcan_str_index);\r\n            slcan_str_index = 0;\r\n\r\n            if(result == -1)\r\n            {\r\n                CDC_Transmit_FS((uint8_t *)\"\\a\", 1);\r\n            }\r\n            else if(result == 0)\r\n            {\r\n                CDC_Transmit_FS((uint8_t *)\"\\r\", 1);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            slcan_str[slcan_str_index++] = Buf[i];\r\n        }\r\n    }\r\n\r\n\r\n    // prepare for next read\r\n    //USBD_CDC_SetRxBuffer(hUsbDevice_0, UserRxBufferFS);\r\n    //USBD_CDC_ReceivePacket(hUsbDevice_0);\r\n\r\n    USBD_CDC_SetRxBuffer(&hUsbDeviceFS, &Buf[0]);\r\n    USBD_CDC_ReceivePacket(&hUsbDeviceFS);\r\n    return (USBD_OK);\r\n    /* USER CODE END 6 */\r\n}", "id": 58, "concepts": ["USB receive callback function", "character parsing", "string manipulation", "error handling with beeps"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 2\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 3\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 4\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 5\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 7\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 9\n### Snippet\nvoid sendValuesAsIntegerPerPrint(double value1, double value2) {\n  int v1 = value1 * 100;\n  int v2 = value2 * 100;\n  \n  Serial.print(v1);\n  Serial.print(',');\n  Serial.println(v2);\n}\n\n### Concepts", "fingerprint": null, "seed": "void sendValuesAsIntegerPerPrint(double value1, double value2) {\n  int v1 = value1 * 100;\n  int v2 = value2 * 100;\n  \n  Serial.print(v1);\n  Serial.print(',');\n  Serial.println(v2);\n}", "id": 59, "concepts": ["data type conversion", "serial communication", "fixed-point representation", "precision selection"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 2\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 3\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 6\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 7\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 9\n### Snippet\nvoid clean_List(Node *h){\n\tNode *p;\n\twhile(h){\n\t\tp = h->next;\n\t\tdelete h;\n\t\th = p;\n\t}\n}\n\n### Concepts", "fingerprint": null, "seed": "void clean_List(Node *h){\n\tNode *p;\n\twhile(h){\n\t\tp = h->next;\n\t\tdelete h;\n\t\th = p;\n\t}\n}", "id": 60, "concepts": ["memory management in linked lists", "freeing memory to avoid memory leaks", "error handling with exceptions"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 2\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 6\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 8\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 9\n### Snippet\nvoid setup() {\n    pinMode(led, OUTPUT);   \n    pinMode(relay, OUTPUT); \n    pinMode(buzzer, OUTPUT); \n    if (!NORELAY)\n        digitalWrite(relay, HIGH);    // active high; start with relay operated   \n    digitalWrite(led, HIGH);      // active low       \n    digitalWrite(buzzer, HIGH);   // active low   \n    pinMode(dhtsensor, INPUT);     \n    pinMode(radar, INPUT);   \n    pinMode(pir1, INPUT);           \n    pinMode(pir2, INPUT);      \n    //beeper(0);  // TODO: disable this for production\n    blinker();      \n    \n    Serial.begin(9600);\n    Serial.println(F(\"Occupancy sensor starting...\"));\n    //EEPROM.get(0, mute_buzzer); // TODO: save tick interval also in EEPROM\n    // Set the nodeID manually\n    mesh.setNodeID(nodeID);  // increment this when burning every device\n    status_payload.node_id = nodeID;\n    Serial.print(F(\"Slave Node ID: \"));    \n    Serial.println(nodeID);    \n    Serial.print(F(\"Simulation = \"));Serial.println(SIMULATION);\n    Serial.print(F(\"NORELAY = \"));Serial.println(NORELAY);\n    Serial.println(F(\"Connecting to the mesh...\"));\n    unsigned long ms = millis();\n    bool result = mesh.begin(MESH_DEFAULT_CHANNEL,RF24_1MBPS,8000);    \n    Serial.println(F(\"Time taken: \"));\n    Serial.println(millis()-ms);\n    if (result)\n        Serial.println(F(\"Connected to mesh.\"));\n    else\n        Serial.println(F(\"Connection timed out.\"));    \n    /*\n    int palevel = radio.getPALevel();\n    Serial.print(F(\"Radio PA level: \"));\n    Serial.println(palevel);\n    radio.setPALevel (RF24_PA_LOW);\n    Serial.print(F(\"New PA level: \"));\n    palevel = radio.getPALevel();\n    Serial.println(palevel);     \n    Serial.println(F(\"Joined the meash.\"));\n    */\n    randomSeed(analogRead(FREE_PIN));  // noise from an unconnected pin\n    status_ticks = status_ticks + random(0, 10); // stagger the transmissions\n    Serial.print(F(\"Status tick interval: \"));\n    Serial.println(status_ticks*100U);  // convert to mSec\n    T.every(tick_interval, ticker);     \n    T.every(data_interval, read_temperature);  // just update readings; do not send it\n    T.every(network_check_interval, renew_network); // check connection and renew if necessary\n    occupy_room();    // start life in occupied state (this needs the mesh running)\n}\n\n### Concepts", "fingerprint": null, "seed": "void setup() {\n    pinMode(led, OUTPUT);   \n    pinMode(relay, OUTPUT); \n    pinMode(buzzer, OUTPUT); \n    if (!NORELAY)\n        digitalWrite(relay, HIGH);    // active high; start with relay operated   \n    digitalWrite(led, HIGH);      // active low       \n    digitalWrite(buzzer, HIGH);   // active low   \n    pinMode(dhtsensor, INPUT);     \n    pinMode(radar, INPUT);   \n    pinMode(pir1, INPUT);           \n    pinMode(pir2, INPUT);      \n    //beeper(0);  // TODO: disable this for production\n    blinker();      \n    \n    Serial.begin(9600);\n    Serial.println(F(\"Occupancy sensor starting...\"));\n    //EEPROM.get(0, mute_buzzer); // TODO: save tick interval also in EEPROM\n    // Set the nodeID manually\n    mesh.setNodeID(nodeID);  // increment this when burning every device\n    status_payload.node_id = nodeID;\n    Serial.print(F(\"Slave Node ID: \"));    \n    Serial.println(nodeID);    \n    Serial.print(F(\"Simulation = \"));Serial.println(SIMULATION);\n    Serial.print(F(\"NORELAY = \"));Serial.println(NORELAY);\n    Serial.println(F(\"Connecting to the mesh...\"));\n    unsigned long ms = millis();\n    bool result = mesh.begin(MESH_DEFAULT_CHANNEL,RF24_1MBPS,8000);    \n    Serial.println(F(\"Time taken: \"));\n    Serial.println(millis()-ms);\n    if (result)\n        Serial.println(F(\"Connected to mesh.\"));\n    else\n        Serial.println(F(\"Connection timed out.\"));    \n    /*\n    int palevel = radio.getPALevel();\n    Serial.print(F(\"Radio PA level: \"));\n    Serial.println(palevel);\n    radio.setPALevel (RF24_PA_LOW);\n    Serial.print(F(\"New PA level: \"));\n    palevel = radio.getPALevel();\n    Serial.println(palevel);     \n    Serial.println(F(\"Joined the meash.\"));\n    */\n    randomSeed(analogRead(FREE_PIN));  // noise from an unconnected pin\n    status_ticks = status_ticks + random(0, 10); // stagger the transmissions\n    Serial.print(F(\"Status tick interval: \"));\n    Serial.println(status_ticks*100U);  // convert to mSec\n    T.every(tick_interval, ticker);     \n    T.every(data_interval, read_temperature);  // just update readings; do not send it\n    T.every(network_check_interval, renew_network); // check connection and renew if necessary\n    occupy_room();    // start life in occupied state (this needs the mesh running)\n}", "id": 61, "concepts": ["pin mode configuration", "signal inversion", "device initialization", "serial communication", "random number generation", "timer scheduling", "state management"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 2\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 4\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 5\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 8\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 9\n### Snippet\ninline void getline(std::istream& cin, std::string& s) {\n    char c = cin.get();\n    std::getline(cin, s);\n    if (c != '\\n') s = c + s;\n}\n\n### Concepts", "fingerprint": null, "seed": "inline void getline(std::istream& cin, std::string& s) {\n    char c = cin.get();\n    std::getline(cin, s);\n    if (c != '\\n') s = c + s;\n}", "id": 62, "concepts": ["custom function for reading a line from a stream", "handling special cases for first character", "inline function definition"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 2\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 3\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 4\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 6\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 9\n### Snippet\nvoid read_temperature() { \n    // Reading the DHT11 takes about 250 milliseconds\n    D.read11(dhtsensor);\n    temperature = D.temperature;\n    humidity = D.humidity;  \n}\n\n### Concepts", "fingerprint": null, "seed": "void read_temperature() { \n    // Reading the DHT11 takes about 250 milliseconds\n    D.read11(dhtsensor);\n    temperature = D.temperature;\n    humidity = D.humidity;  \n}", "id": 63, "concepts": ["sensor data reading", "measurement handling", "time complexity analysis"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 3\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 4\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 6\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 8\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 9\n### Snippet\nvoid generate()\r\n{\r\n\r\n\t//set crop height and width\r\n\tif (crop_height < 1)\r\n\t\tcrop_height = tmap_size;\r\n\tif (crop_width < 1)\r\n\t\tcrop_width = tmap_size;\r\n\r\n\t//if a crop value is set\r\n\t//set tmap_size to fit the cropped values\r\n\tint max_size = std::max(crop_height, crop_width);\r\n\tint max_size_tmp = max_size - 1;\r\n\r\n\tif ((max_size_tmp & (max_size_tmp - 1)) == 0)\r\n\t{\r\n\t\t//leave set size as highest crop value\r\n\t\ttmap_size = max_size;\r\n\t}\r\n\telse\r\n\t{\r\n\t\t//find smallest value such that (value is power of 2) + 1 and value > max_size\r\n\t\tint t = ceil(log2(max_size)) + 1;\r\n\t\ttmap_size = (1 << t) + 1;\r\n\t}\r\n\r\n\tdouble finish = 0;\r\n\t//display info\r\n\tif (verbose)\r\n\t{\r\n\t\tstd::cout << \"Using \" << config_file << std::endl;\r\n\t\tstd::cout << \"Staring square diamond\" << std::endl;\r\n\t\tstd::cout << \"Size: \" << crop_width << \" x \" << crop_height\r\n\t\t\t\t<< \" original size \" << tmap_size << std::endl;\r\n\t\tstd::cout << \"Starting seed value \" << seed << std::endl;\r\n\t\tstd::cout << \"Starting random offset \" << random_offset << std::endl;\r\n\t\tstd::cout << \"Random offset decrease ratio \" << offset_dr << std::endl;\r\n\r\n\t}\r\n\r\n\t//init map array\r\n\ttmap = new int*[tmap_size];\r\n\tfor (int i = 0; i < tmap_size; ++i)\r\n\t{\r\n\t\ttmap[i] = new int[tmap_size];\r\n\t\tfor (int j = 0; j < tmap_size; j++)\r\n\t\t\ttmap[i][j] = 0;\r\n\t}\r\n\r\n//\tinitialize random seed:\r\n//\tuse for generating a random map every time\r\n//  srand ( time(NULL) );\r\n\t//harcoded for now as produces a nice map for testing\r\n\tsrand(12);\r\n\r\n\t//fill the array with values\r\n\tsquare_diamond();\r\n\r\n\t//interpolate voronoi diagram\r\n\t//TODO: add noise to voronoi\r\n\tif (verbose)\r\n\t{\r\n\t\tstd::cout << \"Voronoi points \" << voronoi_size << std::endl;\r\n\t\t/*\r\n\t\t for (int i = 0; i < voronoi_size; ++i) {\r\n\t\t std::cout << \"\\t\" << voronoi_points[i][0] << \",\" << voronoi_points[i][1] << std::endl;\r\n\t\t }\r\n\t\t */\r\n\t}\r\n\tvoronoi();\r\n\r\n\terosion();\r\n\r\n\tif (!neg)\r\n\t\tclear_neg();\r\n\r\n//\t\tfinish = clock() - start;\r\n\tif (verbose)\r\n\t\tstd::cout << \"Finished square diamond \" << (finish / 1000000)\r\n\t\t\t\t<< std::endl;\r\n\tdouble sqadia = (finish / 1000000);\r\n\r\n\tif (normalise)\r\n\t{\r\n\t\tif (verbose)\r\n\t\t\tstd::cout << \"Normalising with value range \" << normalise_min << \"-\"\r\n\t\t\t\t\t<< normalise_max << std::endl;\r\n\t\tnormalise_map();\r\n\t}\r\n\r\n\tif (output_format == STANDRARD_HEIGHTS)\r\n\t{\r\n\t\tprint_map(fopen(output_file.c_str(), \"w\"));\r\n\t}\r\n\telse if (output_format == STANDARD_XML)\r\n\t{\r\n\t\tprint_map_xml(fopen(output_file.c_str(), \"w\"));\r\n\t}\r\n\r\n\tif (scale > 0 && crop_height > 256 && crop_width > 256)\r\n\t{\r\n\r\n//\t\t\tstart = clock();\r\n\t\tif (verbose)\r\n\t\t\tstd::cout << \"Generating rivers\" << std::endl;\r\n\t\trivers();\r\n//\t\t\tfinish = clock() - start;\r\n\t\tif (verbose)\r\n\t\t\tstd::cout << \"Done \" << (finish / 1000000) << std::endl;\r\n\t\tdouble rivers_time = (finish / 1000000);\r\n\t\tprint_rivers(0);\r\n\r\n//\t\t\tstart = clock();\r\n\t\tif (verbose)\r\n\t\t\tstd::cout << \"Generating vegetation\" << std::endl;\r\n\t\tvegetation(verbose);\r\n//\t\t\tfinish = clock() - start;\r\n\t\tif (verbose)\r\n\t\t\tstd::cout << \"Done \" << (finish / 1000000) << std::endl;\r\n\t\tdouble veg_time = (finish / 1000000);\r\n\t\tprint_vegetation(0);\r\n\r\n\t\tif (verbose)\r\n\t\t\tstd::cout << \"Generating settlements\" << std::endl;\r\n\t\tsettlements();\r\n//\t\t\tfinish = clock() - start;\r\n\t\tif (verbose)\r\n\t\t\tstd::cout << \"Done \" << (finish / 1000000) << std::endl;\r\n\t\tdouble settlement_time = (finish / 1000000);\r\n\t\tprint_settlements(0);\r\n\r\n\t\tstd::cout << crop_height << \"\\t\"\r\n\t\t\t\t<< (sqadia + rivers_time + veg_time + settlement_time) << \"\\t\"\r\n\t\t\t\t<< sqadia << \"\\t \" << rivers_time << \"\\t\" << veg_time << \"\\t\"\r\n\t\t\t\t<< settlement_time << std::endl;\r\n\t}\r\n\r\n\tstd::cout << \"Drawing contours\" << std::endl;\r\n\tcontour_map(32, 32, verbose);\r\n\tprint_contour(0);\r\n\tprint_kf(0);\r\n\r\n}\n\n### Concepts", "fingerprint": null, "seed": "void generate()\r\n{\r\n\r\n\t//set crop height and width\r\n\tif (crop_height < 1)\r\n\t\tcrop_height = tmap_size;\r\n\tif (crop_width < 1)\r\n\t\tcrop_width = tmap_size;\r\n\r\n\t//if a crop value is set\r\n\t//set tmap_size to fit the cropped values\r\n\tint max_size = std::max(crop_height, crop_width);\r\n\tint max_size_tmp = max_size - 1;\r\n\r\n\tif ((max_size_tmp & (max_size_tmp - 1)) == 0)\r\n\t{\r\n\t\t//leave set size as highest crop value\r\n\t\ttmap_size = max_size;\r\n\t}\r\n\telse\r\n\t{\r\n\t\t//find smallest value such that (value is power of 2) + 1 and value > max_size\r\n\t\tint t = ceil(log2(max_size)) + 1;\r\n\t\ttmap_size = (1 << t) + 1;\r\n\t}\r\n\r\n\tdouble finish = 0;\r\n\t//display info\r\n\tif (verbose)\r\n\t{\r\n\t\tstd::cout << \"Using \" << config_file << std::endl;\r\n\t\tstd::cout << \"Staring square diamond\" << std::endl;\r\n\t\tstd::cout << \"Size: \" << crop_width << \" x \" << crop_height\r\n\t\t\t\t<< \" original size \" << tmap_size << std::endl;\r\n\t\tstd::cout << \"Starting seed value \" << seed << std::endl;\r\n\t\tstd::cout << \"Starting random offset \" << random_offset << std::endl;\r\n\t\tstd::cout << \"Random offset decrease ratio \" << offset_dr << std::endl;\r\n\r\n\t}\r\n\r\n\t//init map array\r\n\ttmap = new int*[tmap_size];\r\n\tfor (int i = 0; i < tmap_size; ++i)\r\n\t{\r\n\t\ttmap[i] = new int[tmap_size];\r\n\t\tfor (int j = 0; j < tmap_size; j++)\r\n\t\t\ttmap[i][j] = 0;\r\n\t}\r\n\r\n//\tinitialize random seed:\r\n//\tuse for generating a random map every time\r\n//  srand ( time(NULL) );\r\n\t//harcoded for now as produces a nice map for testing\r\n\tsrand(12);\r\n\r\n\t//fill the array with values\r\n\tsquare_diamond();\r\n\r\n\t//interpolate voronoi diagram\r\n\t//TODO: add noise to voronoi\r\n\tif (verbose)\r\n\t{\r\n\t\tstd::cout << \"Voronoi points \" << voronoi_size << std::endl;\r\n\t\t/*\r\n\t\t for (int i = 0; i < voronoi_size; ++i) {\r\n\t\t std::cout << \"\\t\" << voronoi_points[i][0] << \",\" << voronoi_points[i][1] << std::endl;\r\n\t\t }\r\n\t\t */\r\n\t}\r\n\tvoronoi();\r\n\r\n\terosion();\r\n\r\n\tif (!neg)\r\n\t\tclear_neg();\r\n\r\n//\t\tfinish = clock() - start;\r\n\tif (verbose)\r\n\t\tstd::cout << \"Finished square diamond \" << (finish / 1000000)\r\n\t\t\t\t<< std::endl;\r\n\tdouble sqadia = (finish / 1000000);\r\n\r\n\tif (normalise)\r\n\t{\r\n\t\tif (verbose)\r\n\t\t\tstd::cout << \"Normalising with value range \" << normalise_min << \"-\"\r\n\t\t\t\t\t<< normalise_max << std::endl;\r\n\t\tnormalise_map();\r\n\t}\r\n\r\n\tif (output_format == STANDRARD_HEIGHTS)\r\n\t{\r\n\t\tprint_map(fopen(output_file.c_str(), \"w\"));\r\n\t}\r\n\telse if (output_format == STANDARD_XML)\r\n\t{\r\n\t\tprint_map_xml(fopen(output_file.c_str(), \"w\"));\r\n\t}\r\n\r\n\tif (scale > 0 && crop_height > 256 && crop_width > 256)\r\n\t{\r\n\r\n//\t\t\tstart = clock();\r\n\t\tif (verbose)\r\n\t\t\tstd::cout << \"Generating rivers\" << std::endl;\r\n\t\trivers();\r\n//\t\t\tfinish = clock() - start;\r\n\t\tif (verbose)\r\n\t\t\tstd::cout << \"Done \" << (finish / 1000000) << std::endl;\r\n\t\tdouble rivers_time = (finish / 1000000);\r\n\t\tprint_rivers(0);\r\n\r\n//\t\t\tstart = clock();\r\n\t\tif (verbose)\r\n\t\t\tstd::cout << \"Generating vegetation\" << std::endl;\r\n\t\tvegetation(verbose);\r\n//\t\t\tfinish = clock() - start;\r\n\t\tif (verbose)\r\n\t\t\tstd::cout << \"Done \" << (finish / 1000000) << std::endl;\r\n\t\tdouble veg_time = (finish / 1000000);\r\n\t\tprint_vegetation(0);\r\n\r\n\t\tif (verbose)\r\n\t\t\tstd::cout << \"Generating settlements\" << std::endl;\r\n\t\tsettlements();\r\n//\t\t\tfinish = clock() - start;\r\n\t\tif (verbose)\r\n\t\t\tstd::cout << \"Done \" << (finish / 1000000) << std::endl;\r\n\t\tdouble settlement_time = (finish / 1000000);\r\n\t\tprint_settlements(0);\r\n\r\n\t\tstd::cout << crop_height << \"\\t\"\r\n\t\t\t\t<< (sqadia + rivers_time + veg_time + settlement_time) << \"\\t\"\r\n\t\t\t\t<< sqadia << \"\\t \" << rivers_time << \"\\t\" << veg_time << \"\\t\"\r\n\t\t\t\t<< settlement_time << std::endl;\r\n\t}\r\n\r\n\tstd::cout << \"Drawing contours\" << std::endl;\r\n\tcontour_map(32, 32, verbose);\r\n\tprint_contour(0);\r\n\tprint_kf(0);\r\n\r\n}", "id": 64, "concepts": ["random number generation", "map generation algorithms", "noise reduction techniques"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 4\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 8\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 9\n### Snippet\nvoid solve()\r\n{\r\n    double k1, k2, k3, v;\r\n    cin >> k1 >> k2 >> k3 >> v;\r\n\r\n    const int DISTANCE = 100,RECORD = 958;\r\n\r\n    double speed = k1*k2*k3*v;\r\n    int time = round(100*DISTANCE/speed);\r\n\r\n    cout << (time < RECORD ? \"Yes\" : \"No\") << \"\\n\";\r\n}\n\n### Concepts", "fingerprint": null, "seed": "void solve()\r\n{\r\n    double k1, k2, k3, v;\r\n    cin >> k1 >> k2 >> k3 >> v;\r\n\r\n    const int DISTANCE = 100,RECORD = 958;\r\n\r\n    double speed = k1*k2*k3*v;\r\n    int time = round(100*DISTANCE/speed);\r\n\r\n    cout << (time < RECORD ? \"Yes\" : \"No\") << \"\\n\";\r\n}", "id": 65, "concepts": ["formula calculation", "round function", "ternary operator for short-circuiting"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 2\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 3\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 4\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 5\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 7\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 9\n### Snippet\nint setColor(String command)    {\n    // Look through the list of colors to find the one that was requested\n    for(int iColor = 0; iColor < NUM_COLORS; iColor++)\n    {\n        if(command == colorName[iColor]) {\n            // When it matches, look up the RGB values for that color in the table,\n            // and write the red, green, and blue values.\n            RGB.control(true);\n            RGB.color(colorRGB[iColor][0], colorRGB[iColor][1], colorRGB[iColor][2]);\n\n            analogWrite(pinRed,colorRGB[iColor][0]);\n            analogWrite(pinGreen,colorRGB[iColor][1]);\n            analogWrite(pinBlue,colorRGB[iColor][2]);\n            return 0;\n        }\n    }\n\n    return -1;\n}\n\n### Concepts", "fingerprint": null, "seed": "int setColor(String command)    {\n    // Look through the list of colors to find the one that was requested\n    for(int iColor = 0; iColor < NUM_COLORS; iColor++)\n    {\n        if(command == colorName[iColor]) {\n            // When it matches, look up the RGB values for that color in the table,\n            // and write the red, green, and blue values.\n            RGB.control(true);\n            RGB.color(colorRGB[iColor][0], colorRGB[iColor][1], colorRGB[iColor][2]);\n\n            analogWrite(pinRed,colorRGB[iColor][0]);\n            analogWrite(pinGreen,colorRGB[iColor][1]);\n            analogWrite(pinBlue,colorRGB[iColor][2]);\n            return 0;\n        }\n    }\n\n    return -1;\n}", "id": 66, "concepts": ["command parsing", "lookup table usage", "conditional branching", "error handling"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 2\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 3\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 5\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 6\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 9\n### Snippet\nint main(int argc, char const *argv[])\n{\n\tgoodGrowArray<double> a(4);\n\t\n\ta.insertStart(10.1);\n\ta.insertStart(20.1);\n\ta.insertStart(30.1);\n\ta.insertStart(40.1);\n\ta.insert(2, 1111);\n\ta.remove(3);\n\tint len = a.getlen();\n\tint capacity = a.getCapacity();\n\tdouble* data = a.getData();\n\tcout << len << \" \" << capacity << endl;\n\tfor(int i=0; i<len; i++){\n\t\tcout << data[i] <<\" \";\n\t}\n\tcout << endl;\n\treturn 0;\n}\n\n### Concepts", "fingerprint": null, "seed": "int main(int argc, char const *argv[])\n{\n\tgoodGrowArray<double> a(4);\n\t\n\ta.insertStart(10.1);\n\ta.insertStart(20.1);\n\ta.insertStart(30.1);\n\ta.insertStart(40.1);\n\ta.insert(2, 1111);\n\ta.remove(3);\n\tint len = a.getlen();\n\tint capacity = a.getCapacity();\n\tdouble* data = a.getData();\n\tcout << len << \" \" << capacity << endl;\n\tfor(int i=0; i<len; i++){\n\t\tcout << data[i] <<\" \";\n\t}\n\tcout << endl;\n\treturn 0;\n}", "id": 67, "concepts": ["array implementation", "data structure design", "error handling"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 4\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 6\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 7\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 8\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 9\n### Snippet\nchar checkForFloat(char *s) {\n    char decimalPoint = false;\n    int i;\n    for(i=0; s[i] != '\\0'; i++) {\n        switch(s[i]) {\n            case '.':\n                if(decimalPoint) return false;\n                decimalPoint = true;\n                break;\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n                break;\n            default:\n                return false;\n        }\n    }\n    return true;\n}\n\n### Concepts", "fingerprint": null, "seed": "char checkForFloat(char *s) {\n    char decimalPoint = false;\n    int i;\n    for(i=0; s[i] != '\\0'; i++) {\n        switch(s[i]) {\n            case '.':\n                if(decimalPoint) return false;\n                decimalPoint = true;\n                break;\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n            case '4':\n            case '5':\n            case '6':\n            case '7':\n            case '8':\n            case '9':\n                break;\n            default:\n                return false;\n        }\n    }\n    return true;\n}", "id": 68, "concepts": ["string parsing", "float representation", "decimal point handling"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 2\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 3\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 7\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 8\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 9\n### Snippet\nvoid fpcM_PauseEnable(void* pProc, u8 param_2) {\n    fpcPause_Enable((process_node_class*)pProc, param_2 & 0xFF);\n}\n\n### Concepts", "fingerprint": null, "seed": "void fpcM_PauseEnable(void* pProc, u8 param_2) {\n    fpcPause_Enable((process_node_class*)pProc, param_2 & 0xFF);\n}", "id": 69, "concepts": ["bitmasking", "function pointer casting", "bit flag manipulation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 2\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 5\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 6\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 8\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 9\n### Snippet\nvoid init_List(Node *h, const string &a){\n\tNode *p = h;\n\tfor(int i = 0; i < a.size(); i ++){\n\t\tNode *current = new Node(a[i]);\n\t\tp->next = current;\n\t\tp = current;\n\t}\n}\n\n### Concepts", "fingerprint": null, "seed": "void init_List(Node *h, const string &a){\n\tNode *p = h;\n\tfor(int i = 0; i < a.size(); i ++){\n\t\tNode *current = new Node(a[i]);\n\t\tp->next = current;\n\t\tp = current;\n\t}\n}", "id": 70, "concepts": ["linked list creation", "pointer manipulation", "string processing"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 3\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 7\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 9\n### Snippet\nbool comp(ll i,ll j)\n{\n    return i>j;\n}\n\n### Concepts", "fingerprint": null, "seed": "bool comp(ll i,ll j)\n{\n    return i>j;\n}", "id": 71, "concepts": ["function definition", "comparison function for sorting"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 3\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 6\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 7\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 8\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 9\n### Snippet\nfloat RMS(float values[])\n{\n  float result;\n  result = 0;\n  \n  for(int i = 0; i < RMS_window; i++)\n  {\n    result += pow(values[i], 2);\n  }\n\n  result = sqrt(result/10);\n\n  return result;\n}\n\n### Concepts", "fingerprint": null, "seed": "float RMS(float values[])\n{\n  float result;\n  result = 0;\n  \n  for(int i = 0; i < RMS_window; i++)\n  {\n    result += pow(values[i], 2);\n  }\n\n  result = sqrt(result/10);\n\n  return result;\n}", "id": 72, "concepts": ["root mean square calculation", "power calculation", "array processing"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 3\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 6\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 7\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 9\n### Snippet\nvoid high_voltage_check()\n{\n  if(voltage_usage_1 > HIGH_VOLTAGE_1_CUTOFF || voltage_usage_2 > HIGH_VOLTAGE_2_CUTOFF || voltage_usage_3 > HIGH_VOLTAGE_3_CUTOFF){\n    Serial.println(\"High voltage detected...\");\n    highvoltageflag = true;\n    swith_off();\n  } else {\n     highvoltageflag = false;\n  }\n}\n\n### Concepts", "fingerprint": null, "seed": "void high_voltage_check()\n{\n  if(voltage_usage_1 > HIGH_VOLTAGE_1_CUTOFF || voltage_usage_2 > HIGH_VOLTAGE_2_CUTOFF || voltage_usage_3 > HIGH_VOLTAGE_3_CUTOFF){\n    Serial.println(\"High voltage detected...\");\n    highvoltageflag = true;\n    swith_off();\n  } else {\n     highvoltageflag = false;\n  }\n}", "id": 73, "concepts": ["voltage monitoring", "high-voltage detection", "flag setting", "serial output"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 2\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 4\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 7\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 8\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 9\n### Snippet\nbool renew_network() {\n    if (mesh.checkConnection()) {\n        return (true);\n    }\n    else {\n        Serial.println(F(\"Renewing network address...\"));\n        unsigned int addr = mesh.renewAddress(3000UL);  \n        if (addr != 0) {        \n            Serial.print(F(\"New address: \"));\n            Serial.println(addr);\n            return (true);\n        }\n    }   \n    return (false);\n}\n\n### Concepts", "fingerprint": null, "seed": "bool renew_network() {\n    if (mesh.checkConnection()) {\n        return (true);\n    }\n    else {\n        Serial.println(F(\"Renewing network address...\"));\n        unsigned int addr = mesh.renewAddress(3000UL);  \n        if (addr != 0) {        \n            Serial.print(F(\"New address: \"));\n            Serial.println(addr);\n            return (true);\n        }\n    }   \n    return (false);\n}", "id": 74, "concepts": ["network management", "address renewal", "connection check"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 4\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 5\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 6\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 9\n### Snippet\nvoid pzemdevice3()                                                            // Function to get PZEM device 1 data\n{\n  Serial.println(\"====================================================\");     // PZEM Device 1 data fetching code starts here\n  Serial.println(\"Now checking PZEM Device 3\");\n  uint8_t result3;\n\n  ESP.wdtDisable();                                                           // Disable watchdog during modbus read or else ESP crashes when no slave connected\n  result3 = node3.readInputRegisters(0x0000, 10);\n  ESP.wdtEnable(1);                                                           // Enable watchdog during modbus read\n\n  if (result3 == node3.ku8MBSuccess)\n  {\n    voltage_usage_3      = (node3.getResponseBuffer(0x00) / 10.0f);\n    current_usage_3      = (node3.getResponseBuffer(0x01) / 1000.000f);\n    active_power_3       = (node3.getResponseBuffer(0x03) / 10.0f);\n    active_energy_3      = (node3.getResponseBuffer(0x05) / 1000.0f);\n    frequency_3          = (node3.getResponseBuffer(0x07) / 10.0f);\n    power_factor_3       = (node3.getResponseBuffer(0x08) / 100.0f);\n\n    Serial.print(\"VOLTAGE:           \");   Serial.println(voltage_usage_3);       // V\n    Serial.print(\"CURRENT_USAGE:     \");   Serial.println(current_usage_3, 3);    // A\n    Serial.print(\"ACTIVE_POWER:      \");   Serial.println(active_power_3);        // W\n    Serial.print(\"ACTIVE_ENERGY:     \");   Serial.println(active_energy_3, 3);    // kWh\n    Serial.print(\"FREQUENCY:         \");   Serial.println(frequency_3);           // Hz\n    Serial.print(\"POWER_FACTOR:      \");   Serial.println(power_factor_3);\n    Serial.println(\"====================================================\");\n  }\n  else {\n    Serial.println(\"Failed to read PZEM Device 3\");\n    Serial.println(\"PZEM Device 3 Data\");\n    voltage_usage_3      = 0;                                                     // Assigning 0 if it fails to read PZEM device\n    current_usage_3      = 0;\n    active_power_3       = 0;\n    active_energy_3      = 0;\n    frequency_3          = 0;\n    power_factor_3       = 0;\n    Serial.print(\"VOLTAGE:           \");   Serial.println(voltage_usage_3);       // V\n    Serial.print(\"CURRENT_USAGE:     \");   Serial.println(current_usage_3, 3);    // A\n    Serial.print(\"ACTIVE_POWER:      \");   Serial.println(active_power_3);        // W\n    Serial.print(\"ACTIVE_ENERGY:     \");   Serial.println(active_energy_3, 3);    // kWh\n    Serial.print(\"FREQUENCY:         \");   Serial.println(frequency_3);           // Hz\n    Serial.print(\"POWER_FACTOR:      \");   Serial.println(power_factor_3);\n    Serial.println(\"====================================================\");\n    swith_off();\n  }\n}\n\n### Concepts", "fingerprint": null, "seed": "void pzemdevice3()                                                            // Function to get PZEM device 1 data\n{\n  Serial.println(\"====================================================\");     // PZEM Device 1 data fetching code starts here\n  Serial.println(\"Now checking PZEM Device 3\");\n  uint8_t result3;\n\n  ESP.wdtDisable();                                                           // Disable watchdog during modbus read or else ESP crashes when no slave connected\n  result3 = node3.readInputRegisters(0x0000, 10);\n  ESP.wdtEnable(1);                                                           // Enable watchdog during modbus read\n\n  if (result3 == node3.ku8MBSuccess)\n  {\n    voltage_usage_3      = (node3.getResponseBuffer(0x00) / 10.0f);\n    current_usage_3      = (node3.getResponseBuffer(0x01) / 1000.000f);\n    active_power_3       = (node3.getResponseBuffer(0x03) / 10.0f);\n    active_energy_3      = (node3.getResponseBuffer(0x05) / 1000.0f);\n    frequency_3          = (node3.getResponseBuffer(0x07) / 10.0f);\n    power_factor_3       = (node3.getResponseBuffer(0x08) / 100.0f);\n\n    Serial.print(\"VOLTAGE:           \");   Serial.println(voltage_usage_3);       // V\n    Serial.print(\"CURRENT_USAGE:     \");   Serial.println(current_usage_3, 3);    // A\n    Serial.print(\"ACTIVE_POWER:      \");   Serial.println(active_power_3);        // W\n    Serial.print(\"ACTIVE_ENERGY:     \");   Serial.println(active_energy_3, 3);    // kWh\n    Serial.print(\"FREQUENCY:         \");   Serial.println(frequency_3);           // Hz\n    Serial.print(\"POWER_FACTOR:      \");   Serial.println(power_factor_3);\n    Serial.println(\"====================================================\");\n  }\n  else {\n    Serial.println(\"Failed to read PZEM Device 3\");\n    Serial.println(\"PZEM Device 3 Data\");\n    voltage_usage_3      = 0;                                                     // Assigning 0 if it fails to read PZEM device\n    current_usage_3      = 0;\n    active_power_3       = 0;\n    active_energy_3      = 0;\n    frequency_3          = 0;\n    power_factor_3       = 0;\n    Serial.print(\"VOLTAGE:           \");   Serial.println(voltage_usage_3);       // V\n    Serial.print(\"CURRENT_USAGE:     \");   Serial.println(current_usage_3, 3);    // A\n    Serial.print(\"ACTIVE_POWER:      \");   Serial.println(active_power_3);        // W\n    Serial.print(\"ACTIVE_ENERGY:     \");   Serial.println(active_energy_3, 3);    // kWh\n    Serial.print(\"FREQUENCY:         \");   Serial.println(frequency_3);           // Hz\n    Serial.print(\"POWER_FACTOR:      \");   Serial.println(power_factor_3);\n    Serial.println(\"====================================================\");\n    swith_off();\n  }\n}", "id": 75, "concepts": ["modbus communication with a PZEM device", "error handling for failed modbus read", "8-bit integer arithmetic for voltage and current calculations", "power factor calculation", "serial output formatting"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 2\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 3\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 5\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 7\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 9\n### Snippet\nvoid p6(Node *h){\n\tNode *p = h;\n\twhile(p){\n\t\tNode *pn = p->next;\n\t\tif(pn == NULL || (pn->c != '?' && pn->c != '!')){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n//\t\tcout<<\"p6\"<<endl;\n\t\tNode *node = new Node(' ');\n\t\tp = insert(p,node);\n\t\tnode = new Node(' ');\n\t\tpn = insert(pn,node);\n\t\tp = pn;\n\t}\n}\n\n### Concepts", "fingerprint": null, "seed": "void p6(Node *h){\n\tNode *p = h;\n\twhile(p){\n\t\tNode *pn = p->next;\n\t\tif(pn == NULL || (pn->c != '?' && pn->c != '!')){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n//\t\tcout<<\"p6\"<<endl;\n\t\tNode *node = new Node(' ');\n\t\tp = insert(p,node);\n\t\tnode = new Node(' ');\n\t\tpn = insert(pn,node);\n\t\tp = pn;\n\t}\n}", "id": 76, "concepts": ["node insertion", "pattern matching", "text processing"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 3\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 5\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 6\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 8\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 9\n### Snippet\nint askdist(int u,int v)\n{\n\tint res=0;\n\tif(deep[u]<deep[v]) std::swap(u,v);\n\tfor(int i=19;~i;i--) if(deep[fa[u][i]]>=deep[v]) res=mul(res+val[u][i]),u=fa[u][i];\n\tif(u==v) return res;\n\tfor(int i=19;~i;i--)\n\t\tif(fa[u][i]!=fa[v][i]) res=(res+val[u][i]+val[v][i])%mod,u=fa[u][i],v=fa[v][i];\n\tres=mul(res+val[u][0]+val[v][0]);\n\treturn res;\n}\n\n### Concepts", "fingerprint": null, "seed": "int askdist(int u,int v)\n{\n\tint res=0;\n\tif(deep[u]<deep[v]) std::swap(u,v);\n\tfor(int i=19;~i;i--) if(deep[fa[u][i]]>=deep[v]) res=mul(res+val[u][i]),u=fa[u][i];\n\tif(u==v) return res;\n\tfor(int i=19;~i;i--)\n\t\tif(fa[u][i]!=fa[v][i]) res=(res+val[u][i]+val[v][i])%mod,u=fa[u][i],v=fa[v][i];\n\tres=mul(res+val[u][0]+val[v][0]);\n\treturn res;\n}", "id": 77, "concepts": ["sparse table", "lca", "binary lifting", "fast query"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 2\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 3\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 6\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 9\n### Snippet\nvoid full_to_csr_ref(\n    int m, int n,\n    double *A, int lda,\n    int **rowptr, int **colidx, double **values) {\n    *rowptr = new int[m + 1];\n\n    int zero = 0;\n    std::fill(*rowptr, *rowptr + m + 1, zero);\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            rowptr[0][j + 1] += (A[i * lda + j]) ?1 :0;\n        }\n    }\n\n    for (int i = 0; i < m; ++i) {\n        rowptr[0][i + 1] += rowptr[0][i];\n    }\n\n    *colidx = new int[rowptr[0][m]];\n    *values = new double[rowptr[0][m]];\n\n    int pos = 0;\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (A[i * lda + j]) {\n                colidx[0][pos] = j;\n                values[0][pos] = A[i * lda + j];\n                ++pos;\n            }\n        }\n    }\n}\n\n### Concepts", "fingerprint": null, "seed": "void full_to_csr_ref(\n    int m, int n,\n    double *A, int lda,\n    int **rowptr, int **colidx, double **values) {\n    *rowptr = new int[m + 1];\n\n    int zero = 0;\n    std::fill(*rowptr, *rowptr + m + 1, zero);\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            rowptr[0][j + 1] += (A[i * lda + j]) ?1 :0;\n        }\n    }\n\n    for (int i = 0; i < m; ++i) {\n        rowptr[0][i + 1] += rowptr[0][i];\n    }\n\n    *colidx = new int[rowptr[0][m]];\n    *values = new double[rowptr[0][m]];\n\n    int pos = 0;\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (A[i * lda + j]) {\n                colidx[0][pos] = j;\n                values[0][pos] = A[i * lda + j];\n                ++pos;\n            }\n        }\n    }\n}", "id": 78, "concepts": ["sparse matrix storage conversion", "memory management", "pointer arithmetic", "row-major matrix traversal"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 2\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 4\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 6\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 9\n### Snippet\nvoid PrintMs(const char* text = \"\") {\n\tstatic long long last = 0;\n\tlong long cur = getTickCount();\n\tif (last == 0) {\n\t\tlast = cur;\n\t\treturn;\n\t}\n\tlong long ms = 0;\n\tms = ((double)(cur - last) / getTickFrequency()) * 1000;\n\tif (*text != 0) {\n\t\tprintf(\"%s = %dms\\n\", text, ms);\n\t}\n\tlast = getTickCount();\n}\n\n### Concepts", "fingerprint": null, "seed": "void PrintMs(const char* text = \"\") {\n\tstatic long long last = 0;\n\tlong long cur = getTickCount();\n\tif (last == 0) {\n\t\tlast = cur;\n\t\treturn;\n\t}\n\tlong long ms = 0;\n\tms = ((double)(cur - last) / getTickFrequency()) * 1000;\n\tif (*text != 0) {\n\t\tprintf(\"%s = %dms\\n\", text, ms);\n\t}\n\tlast = getTickCount();\n}", "id": 79, "concepts": ["timing code execution", "benchmarking", "measuring performance", "printing to the console"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 3\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 5\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 9\n### Snippet\nvoid print_matrix(float *x, int N)\n{\n\tint i, j;\n   \tfor(i=0;i<N;i++)\n   \t{\n      \t\tfor (j=0;j<N;j++) printf(\" %f \", x[N*i+j]); \n      \t\tprintf(\"\\n\"); \n   \t}\n}\n\n### Concepts", "fingerprint": null, "seed": "void print_matrix(float *x, int N)\n{\n\tint i, j;\n   \tfor(i=0;i<N;i++)\n   \t{\n      \t\tfor (j=0;j<N;j++) printf(\" %f \", x[N*i+j]); \n      \t\tprintf(\"\\n\"); \n   \t}\n}", "id": 80, "concepts": ["matrix printing with row-major layout", "nested loops for row and column traversal"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 4\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 6\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 7\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 9\n### Snippet\nint main()\n{\n#ifndef ONLINE_JUDGE\n    freopen(\"input.txt\", \"rt\", stdin);\n    freopen(\"output.txt\", \"wt\", stdout);\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    ll n;\n    cin >> n;\n    string s, t;\n    cin >> s >> t;\n    set<ll> s0, s1;\n    f(0, n)\n    {\n        if (s[i] != t[i])\n        {\n            if (s[i] == '1')\n                s1.insert(i);\n            else\n                s0.insert(i);\n        }\n    }\n    if (s0.size() == 0 && s1.size() == 0)\n    {\n        cout << \"0\\n\";\n        return 0;\n    }\n    if (s0.size() != s1.size())\n    {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    ll i0 = *s0.begin();\n    ll i1 = *s1.begin();\n    ll f = 2;\n    int ans=0;\n    while (!(s0.empty() && s1.empty()))\n    {\n        if (f == 2)\n        {\n            ans++;\n            i0 = *s0.begin();\n            i1 = *s1.begin();\n            f=0;\n        }\n        if(i0<i1)\n        {\n            s0.erase(i0);\n            s1.erase(i1);\n            auto p =s0.upper_bound(i1); \n            if(p==s0.end()){\n                f=2;\n                continue;\n            }\n            i0 = *p;\n        }\n        else\n        {\n            s0.erase(i0);\n            s1.erase(i1);\n            auto p =s1.upper_bound(i0); \n            if(p==s1.end()){\n                f=2;\n                continue;\n            }\n            i1 = *p;\n        }\n    }\n    cout<<ans<<\"\\n\";\n}\n\n### Concepts", "fingerprint": null, "seed": "int main()\n{\n#ifndef ONLINE_JUDGE\n    freopen(\"input.txt\", \"rt\", stdin);\n    freopen(\"output.txt\", \"wt\", stdout);\n#endif\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    ll n;\n    cin >> n;\n    string s, t;\n    cin >> s >> t;\n    set<ll> s0, s1;\n    f(0, n)\n    {\n        if (s[i] != t[i])\n        {\n            if (s[i] == '1')\n                s1.insert(i);\n            else\n                s0.insert(i);\n        }\n    }\n    if (s0.size() == 0 && s1.size() == 0)\n    {\n        cout << \"0\\n\";\n        return 0;\n    }\n    if (s0.size() != s1.size())\n    {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    ll i0 = *s0.begin();\n    ll i1 = *s1.begin();\n    ll f = 2;\n    int ans=0;\n    while (!(s0.empty() && s1.empty()))\n    {\n        if (f == 2)\n        {\n            ans++;\n            i0 = *s0.begin();\n            i1 = *s1.begin();\n            f=0;\n        }\n        if(i0<i1)\n        {\n            s0.erase(i0);\n            s1.erase(i1);\n            auto p =s0.upper_bound(i1); \n            if(p==s0.end()){\n                f=2;\n                continue;\n            }\n            i0 = *p;\n        }\n        else\n        {\n            s0.erase(i0);\n            s1.erase(i1);\n            auto p =s1.upper_bound(i0); \n            if(p==s1.end()){\n                f=2;\n                continue;\n            }\n            i1 = *p;\n        }\n    }\n    cout<<ans<<\"\\n\";\n}", "id": 81, "concepts": ["greedy algorithm", "set data structure", "tracking of indices"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 2\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 4\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 5\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 8\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 9\n### Snippet\nvoid loop(void)\r\n{\r\n\r\n//////////STILL TRYING TO GET ZULU WITH A DIFFERENT LIBRARY\r\n    time_t utc = now();\r\n    time_t local = myTZ.toLocal(utc, &tcr);\r\n    Serial.println();\r\n    printDateTime(utc, \"UTC\");\r\n    printDateTime(local, tcr -> abbrev);\r\n    delay(10000);\r\n          //THIS WORKS -  Now integrate it into the matrix disp\r\n//////////END STILL TRYING TO GET ZULU WITH A DIFFERENT LIBRARY\r\n \r\n////////// TRYING TO FIX TEMP SENSOR\r\n\r\n  // Reading temperature or humidity takes about 250 milliseconds!\r\n  // Sensor readings may also be up to 2 seconds 'old' (its a very slow sensor)\r\n  float hum = dht.readHumidity();\r\n  // Read temperature as Celsius (the default)\r\n  float temp = dht.readTemperature();\r\n  // Read temperature as Fahrenheit (isFahrenheit = true)\r\n  // float fern = dht.readTemperature(true);\r\n\r\n  // Check if any reads failed and exit early (to try again).\r\n            if (isnan(hum) || isnan(temp)) {           //  if (isnan(hum) || isnan(temp)) {     \r\n    return;\r\n  }                ////////THIS MAKES THE SKETCH STOP FOR A MOMENT - WHY???\r\n\r\n//////// END TEMP SENSOR\r\n  \r\n  static uint32_t lastTime = 0; // millis() memory\r\n  static uint8_t  display = 0;  // current display mode\r\n  static bool flasher = false;  // seconds passing flasher\r\n\r\n//char phln = (RTC.h - 420);\r\nfloat frnt = (temp*1.8+32);           //Changed int to float to get decimals - WORKS\r\n\r\n  P.displayAnimate();\r\n\r\n  P.setIntensity(0);                  //Intensity - Change with time later\r\n  if (P.getZoneStatus(0))\r\n  {\r\n    switch (display)\r\n    {\r\n      case 0: //SET AS ZULU TIME \r\n        P.setTextEffect(0, PA_FADE, PA_FADE);\r\n        display++;  \r\n\r\n        /////////   Now I just need to stop the glitch\r\n        /////////   and add 420 to time (ZULU)\r\n        ///         getTime((szTime), phln ); \r\n        ///         strcpy(phln, szMesg);\r\n        /////////   I've tried to get this to flash like the other clock but it\r\n        /////////   isn't working \r\n          strcpy(szMesg, \"W6LU\");\r\n\r\n//       getTime((szMesg), \"z\"); \r\n//       const int offset = -8;  // Pacific Standard Time (USA) - This line breaks it.\r\n        break;\r\n/*                                            \r\n      case 1: // Temperature deg C\r\n        P.setTextEffect(0, PA_SCROLL_LEFT, PA_SCROLL_UP_LEFT);\r\n        display++;\r\n        \r\n          dtostrf(temp, 3, 1, szMesg);\r\n          strcat(szMesg, \"$\");\r\n     \r\n        break;\r\n \r\n      case 2: // Temperature deg F\r\n        P.setTextEffect(0, PA_SCROLL_UP_LEFT, PA_SCROLL_LEFT);\r\n        display++;\r\n        \r\n          dtostrf(frnt, 3, 1, szMesg);\r\n          strcat(szMesg, \"&\");\r\n\r\n        break;\r\n\r\n      case 3: // Relative Humidity\r\n        P.setTextEffect(0, PA_SCROLL_LEFT, PA_SCROLL_LEFT);\r\n        display++;\r\n\r\n          dtostrf(hum, 3, 0, szMesg);\r\n          strcat(szMesg, \"% H \");\r\n\r\n        break;\r\n \r\n      case 4: // Call Sign\r\n        P.setTextEffect(0, PA_GROW_UP, PA_GROW_DOWN);     //I like PA_WIPE too - \r\n        display++;\r\n        \r\n          strcpy(szMesg, \"W6LU\");\r\n\r\n        break;\r\n \r\n\r\n      case 5: // day of week\r\n        P.setTextEffect(0, PA_SCROLL_LEFT, PA_SCROLL_LEFT);\r\n        display++;\r\n\r\n\r\n          dow2str(szMesg, \"W6LU\", MAX_MESG);\r\n//        dow2str(RTC.dow, szMesg, MAX_MESG);\r\n\r\n        break;\r\n*/\r\n      default:  // Calendar\r\n        P.setTextEffect(0, PA_SCROLL_LEFT, PA_SCROLL_LEFT);\r\n        display = 0;\r\n\r\n          strcpy(szMesg, \"W6LU\");      \r\n//        getDate(szMesg);\r\n      break; \r\n    }\r\n\r\n    P.displayReset(0);\r\n  }\r\n  \r\n  \r\n    // Finally, adjust the time string if we have to\r\n    if (millis() - lastTime >= 1000)\r\n    {\r\n      lastTime = millis();\r\n     printDateTime(utc, szTime);\r\n      flasher = !flasher;\r\n      P.displayReset(1);\r\n    }\r\n}\n\n### Concepts", "fingerprint": null, "seed": "void loop(void)\r\n{\r\n\r\n//////////STILL TRYING TO GET ZULU WITH A DIFFERENT LIBRARY\r\n    time_t utc = now();\r\n    time_t local = myTZ.toLocal(utc, &tcr);\r\n    Serial.println();\r\n    printDateTime(utc, \"UTC\");\r\n    printDateTime(local, tcr -> abbrev);\r\n    delay(10000);\r\n          //THIS WORKS -  Now integrate it into the matrix disp\r\n//////////END STILL TRYING TO GET ZULU WITH A DIFFERENT LIBRARY\r\n \r\n////////// TRYING TO FIX TEMP SENSOR\r\n\r\n  // Reading temperature or humidity takes about 250 milliseconds!\r\n  // Sensor readings may also be up to 2 seconds 'old' (its a very slow sensor)\r\n  float hum = dht.readHumidity();\r\n  // Read temperature as Celsius (the default)\r\n  float temp = dht.readTemperature();\r\n  // Read temperature as Fahrenheit (isFahrenheit = true)\r\n  // float fern = dht.readTemperature(true);\r\n\r\n  // Check if any reads failed and exit early (to try again).\r\n            if (isnan(hum) || isnan(temp)) {           //  if (isnan(hum) || isnan(temp)) {     \r\n    return;\r\n  }                ////////THIS MAKES THE SKETCH STOP FOR A MOMENT - WHY???\r\n\r\n//////// END TEMP SENSOR\r\n  \r\n  static uint32_t lastTime = 0; // millis() memory\r\n  static uint8_t  display = 0;  // current display mode\r\n  static bool flasher = false;  // seconds passing flasher\r\n\r\n//char phln = (RTC.h - 420);\r\nfloat frnt = (temp*1.8+32);           //Changed int to float to get decimals - WORKS\r\n\r\n  P.displayAnimate();\r\n\r\n  P.setIntensity(0);                  //Intensity - Change with time later\r\n  if (P.getZoneStatus(0))\r\n  {\r\n    switch (display)\r\n    {\r\n      case 0: //SET AS ZULU TIME \r\n        P.setTextEffect(0, PA_FADE, PA_FADE);\r\n        display++;  \r\n\r\n        /////////   Now I just need to stop the glitch\r\n        /////////   and add 420 to time (ZULU)\r\n        ///         getTime((szTime), phln ); \r\n        ///         strcpy(phln, szMesg);\r\n        /////////   I've tried to get this to flash like the other clock but it\r\n        /////////   isn't working \r\n          strcpy(szMesg, \"W6LU\");\r\n\r\n//       getTime((szMesg), \"z\"); \r\n//       const int offset = -8;  // Pacific Standard Time (USA) - This line breaks it.\r\n        break;\r\n/*                                            \r\n      case 1: // Temperature deg C\r\n        P.setTextEffect(0, PA_SCROLL_LEFT, PA_SCROLL_UP_LEFT);\r\n        display++;\r\n        \r\n          dtostrf(temp, 3, 1, szMesg);\r\n          strcat(szMesg, \"$\");\r\n     \r\n        break;\r\n \r\n      case 2: // Temperature deg F\r\n        P.setTextEffect(0, PA_SCROLL_UP_LEFT, PA_SCROLL_LEFT);\r\n        display++;\r\n        \r\n          dtostrf(frnt, 3, 1, szMesg);\r\n          strcat(szMesg, \"&\");\r\n\r\n        break;\r\n\r\n      case 3: // Relative Humidity\r\n        P.setTextEffect(0, PA_SCROLL_LEFT, PA_SCROLL_LEFT);\r\n        display++;\r\n\r\n          dtostrf(hum, 3, 0, szMesg);\r\n          strcat(szMesg, \"% H \");\r\n\r\n        break;\r\n \r\n      case 4: // Call Sign\r\n        P.setTextEffect(0, PA_GROW_UP, PA_GROW_DOWN);     //I like PA_WIPE too - \r\n        display++;\r\n        \r\n          strcpy(szMesg, \"W6LU\");\r\n\r\n        break;\r\n \r\n\r\n      case 5: // day of week\r\n        P.setTextEffect(0, PA_SCROLL_LEFT, PA_SCROLL_LEFT);\r\n        display++;\r\n\r\n\r\n          dow2str(szMesg, \"W6LU\", MAX_MESG);\r\n//        dow2str(RTC.dow, szMesg, MAX_MESG);\r\n\r\n        break;\r\n*/\r\n      default:  // Calendar\r\n        P.setTextEffect(0, PA_SCROLL_LEFT, PA_SCROLL_LEFT);\r\n        display = 0;\r\n\r\n          strcpy(szMesg, \"W6LU\");      \r\n//        getDate(szMesg);\r\n      break; \r\n    }\r\n\r\n    P.displayReset(0);\r\n  }\r\n  \r\n  \r\n    // Finally, adjust the time string if we have to\r\n    if (millis() - lastTime >= 1000)\r\n    {\r\n      lastTime = millis();\r\n     printDateTime(utc, szTime);\r\n      flasher = !flasher;\r\n      P.displayReset(1);\r\n    }\r\n}", "id": 82, "concepts": ["time zone conversion", "temperature sensor reading", "humidity sensor reading", "date and time formatting"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 2\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 5\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 6\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 7\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 9\n### Snippet\nvoid setup()\n{\n  Serial.begin(9600);\n  pzemSerial.begin(9600);\n\n  /* start Modbus/RS-485 serial communication */\n\n  node1.begin(pzemSlave1Addr, pzemSerial);\n  node2.begin(pzemSlave2Addr, pzemSerial);\n  node3.begin(pzemSlave3Addr, pzemSerial);\n\n  /*********************************************************************************************\\\n      Change PZEM address\n  \\*********************************************************************************************/\n\n  /*\n      changeAddress(OldAddress, Newaddress)\n      By Uncomment the function in the below line you can change the slave address from one of the nodes (pzem device),\n      only need to be done ones. Preverable do this only with 1 slave in the network.\n      If you forgot or don't know the new address anymore, you can use the broadcast address 0XF8 as OldAddress to change the slave address.\n      Use this with one slave ONLY in the network.\n      This is the first step you have to do when connecting muliple pzem devices. If you haven't set the pzem address, then this program won't\n      works.\n     1. Connect only one PZEM device to nodemcu and powerup your PZEM\n     2. uncomment the changeAddress function call below i.e., changeAddress(OldAddress, Newaddress)\n     3. change the Newaddress value to some other value. Ex: 0x01, 0x02, 0xF7 etc.,\n     4. upload this program to nodemcu \n     5. if you see \"Changing Slave Address\" on serial monitor, then it successfully changed address \n     6. if you don't see that message, then click on RESET button on nodemcu\n     7. Once this done you have successfully assigned address to pzem device.\n     8. do the same steps for as many devices as you want. \n  */\n\n\n// changeAddress(0XF8, 0x02);                 // uncomment to set pzem address\n\n\n  /*********************************************************************************************\\\n      RESET PZEM Energy\n  \\*********************************************************************************************/\n\n  /*\n        By Uncomment the function in the below line you can reset the energy counter (Wh) back to zero from one of the slaves.\n        resetEnergy(pzemSlaveAddr);\n  */\n\n\n// resetEnergy(0x01);                        // uncomment to reset pzem energy\n\n#if defined(USE_LOCAL_SERVER)\n  WiFi.begin(WIFI_SSID, WIFI_PASS);         // Non-blocking if no WiFi available\n  Blynk.config(AUTH, SERVER, PORT);\n  Blynk.connect();\n#else\n  WiFi.begin(WIFI_SSID, WIFI_PASS);         // Non-blocking if no WiFi available\n  Blynk.config(AUTH);\n  Blynk.connect();\n#endif   \n\n\n  /*********************************************************************************************\\\n      RELAY code\n  \\*********************************************************************************************/\n\n  pinMode(RELAY_PIN_1, OUTPUT);  \n  pinMode(PUSH_BUTTON_1, INPUT_PULLUP);  \n  digitalWrite(RELAY_PIN_1, relay1State);\n    \n  pinMode(RELAY_PIN_2, OUTPUT);  \n  pinMode(PUSH_BUTTON_2, INPUT_PULLUP);  \n  digitalWrite(RELAY_PIN_2, relay2State);\n\n  pinMode(RELAY_PIN_3, OUTPUT);   \n  digitalWrite(RELAY_PIN_3, relay3State);\n\n  pinMode(RELAY_PIN_4, OUTPUT);   \n  digitalWrite(RELAY_PIN_4, relay4State);\n\n  timer.setInterval(GET_PZEM_DATA_TIME,       get_pzem_data);                   // How often you would like to call the function\n  timer.setInterval(AUTO_MODE_TIME,           auto_mode);    \n  timer.setInterval(PHYSICAL_BUTTON_TIME,     checkPhysicalButton);             // Setup a Relay function to be called every 100 ms\n  timer.setInterval(SEND_TO_BLYNK_TIME,       sendtoBlynk);                     // Send PZEM values blynk server every 10 sec\n }\n\n### Concepts", "fingerprint": null, "seed": "void setup()\n{\n  Serial.begin(9600);\n  pzemSerial.begin(9600);\n\n  /* start Modbus/RS-485 serial communication */\n\n  node1.begin(pzemSlave1Addr, pzemSerial);\n  node2.begin(pzemSlave2Addr, pzemSerial);\n  node3.begin(pzemSlave3Addr, pzemSerial);\n\n  /*********************************************************************************************\\\n      Change PZEM address\n  \\*********************************************************************************************/\n\n  /*\n      changeAddress(OldAddress, Newaddress)\n      By Uncomment the function in the below line you can change the slave address from one of the nodes (pzem device),\n      only need to be done ones. Preverable do this only with 1 slave in the network.\n      If you forgot or don't know the new address anymore, you can use the broadcast address 0XF8 as OldAddress to change the slave address.\n      Use this with one slave ONLY in the network.\n      This is the first step you have to do when connecting muliple pzem devices. If you haven't set the pzem address, then this program won't\n      works.\n     1. Connect only one PZEM device to nodemcu and powerup your PZEM\n     2. uncomment the changeAddress function call below i.e., changeAddress(OldAddress, Newaddress)\n     3. change the Newaddress value to some other value. Ex: 0x01, 0x02, 0xF7 etc.,\n     4. upload this program to nodemcu \n     5. if you see \"Changing Slave Address\" on serial monitor, then it successfully changed address \n     6. if you don't see that message, then click on RESET button on nodemcu\n     7. Once this done you have successfully assigned address to pzem device.\n     8. do the same steps for as many devices as you want. \n  */\n\n\n// changeAddress(0XF8, 0x02);                 // uncomment to set pzem address\n\n\n  /*********************************************************************************************\\\n      RESET PZEM Energy\n  \\*********************************************************************************************/\n\n  /*\n        By Uncomment the function in the below line you can reset the energy counter (Wh) back to zero from one of the slaves.\n        resetEnergy(pzemSlaveAddr);\n  */\n\n\n// resetEnergy(0x01);                        // uncomment to reset pzem energy\n\n#if defined(USE_LOCAL_SERVER)\n  WiFi.begin(WIFI_SSID, WIFI_PASS);         // Non-blocking if no WiFi available\n  Blynk.config(AUTH, SERVER, PORT);\n  Blynk.connect();\n#else\n  WiFi.begin(WIFI_SSID, WIFI_PASS);         // Non-blocking if no WiFi available\n  Blynk.config(AUTH);\n  Blynk.connect();\n#endif   \n\n\n  /*********************************************************************************************\\\n      RELAY code\n  \\*********************************************************************************************/\n\n  pinMode(RELAY_PIN_1, OUTPUT);  \n  pinMode(PUSH_BUTTON_1, INPUT_PULLUP);  \n  digitalWrite(RELAY_PIN_1, relay1State);\n    \n  pinMode(RELAY_PIN_2, OUTPUT);  \n  pinMode(PUSH_BUTTON_2, INPUT_PULLUP);  \n  digitalWrite(RELAY_PIN_2, relay2State);\n\n  pinMode(RELAY_PIN_3, OUTPUT);   \n  digitalWrite(RELAY_PIN_3, relay3State);\n\n  pinMode(RELAY_PIN_4, OUTPUT);   \n  digitalWrite(RELAY_PIN_4, relay4State);\n\n  timer.setInterval(GET_PZEM_DATA_TIME,       get_pzem_data);                   // How often you would like to call the function\n  timer.setInterval(AUTO_MODE_TIME,           auto_mode);    \n  timer.setInterval(PHYSICAL_BUTTON_TIME,     checkPhysicalButton);             // Setup a Relay function to be called every 100 ms\n  timer.setInterval(SEND_TO_BLYNK_TIME,       sendtoBlynk);                     // Send PZEM values blynk server every 10 sec\n }", "id": 83, "concepts": ["serial communication setup", "Modbus/RS-485 configuration", "address assignment", "energy counter reset", "WiFi connection", "Blynk configuration", "relay control", "physical button handling", "timer setup", "PZEM data acquisition", "automatic mode", "Blynk value update"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 4\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 7\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 8\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 9\n### Snippet\nvoid warn() {\n    T.oscillate (buzzer,50, HIGH, 4);  \n    // the end state is HIGH, i.e, buzzer is off *  \n}\n\n### Concepts", "fingerprint": null, "seed": "void warn() {\n    T.oscillate (buzzer,50, HIGH, 4);  \n    // the end state is HIGH, i.e, buzzer is off *  \n}", "id": 84, "concepts": ["buzzer oscillation", "sound generation", "oscillating device"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 3\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 7\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 8\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 9\n### Snippet\nvoid resetEnergy(uint8_t slaveAddr)                                                // Function to reset energy value on PZEM device.\n{\n  /* The command to reset the slave's energy is (total 4 bytes):\n     Slave address + 0x42 + CRC check high byte + CRC check low byte. */\n  uint16_t u16CRC = 0xFFFF;\n  static uint8_t resetCommand = 0x42;\n  u16CRC = crc16_update(u16CRC, slaveAddr);\n  u16CRC = crc16_update(u16CRC, resetCommand);\n  Serial.println(\"Resetting Energy\");\n  pzemSerial.write(slaveAddr);\n  pzemSerial.write(resetCommand);\n  pzemSerial.write(lowByte(u16CRC));\n  pzemSerial.write(highByte(u16CRC));\n  delay(1000);\n}\n\n### Concepts", "fingerprint": null, "seed": "void resetEnergy(uint8_t slaveAddr)                                                // Function to reset energy value on PZEM device.\n{\n  /* The command to reset the slave's energy is (total 4 bytes):\n     Slave address + 0x42 + CRC check high byte + CRC check low byte. */\n  uint16_t u16CRC = 0xFFFF;\n  static uint8_t resetCommand = 0x42;\n  u16CRC = crc16_update(u16CRC, slaveAddr);\n  u16CRC = crc16_update(u16CRC, resetCommand);\n  Serial.println(\"Resetting Energy\");\n  pzemSerial.write(slaveAddr);\n  pzemSerial.write(resetCommand);\n  pzemSerial.write(lowByte(u16CRC));\n  pzemSerial.write(highByte(u16CRC));\n  delay(1000);\n}", "id": 85, "concepts": ["serial communication protocol", "CRC-16 calculation", "data packet construction"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 4\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 5\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 6\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 9\n### Snippet\nvoid setup() {\n  analogReference(EXTERNAL);\n  pinMode(X_ACCEL, INPUT);\n  pinMode(Y_ACCEL, INPUT);\n  pinMode(Z_ACCEL, INPUT);\n  pinMode(ledPin, OUTPUT);\n\n  queue_position = 0;\n\n  Serial.begin(9600);\n  Serial1.begin(9600);\n\n  mean_x = 0;\n  mean_y = 0;\n  mean_z = 0;\n  mean_counter = 0;\n//  Serial.begin(9600);\n\n  filtered_value = new FilterBuHp2();\n\n  // Get mean value for threshold\n//  Serial.println(\"Starting callibration...\");\n  t0 = millis();\n  while (millis() - t0 < 4000)\n  {\n    mean_x += getSeparatedValues(X_ACCEL);\n    mean_y += getSeparatedValues(Y_ACCEL);\n    mean_z += getSeparatedValues(Z_ACCEL);\n    mean_counter++;\n  }\n  \n  mean_x /= mean_counter;\n  mean_y /= mean_counter;\n  mean_z /= mean_counter;\n\n//  Serial.print(\"Callibration done! With samples: \");\n//  Serial.println(mean_counter);\n  // Get mean value for threshold\n  /*Serial.println(\"Starting accel callibration. Please stand still for 5 seconds.\");\n  int t0 = millis();\n  while (millis() - t0 < 4000)\n  {\n    mean_value = getFilteredSignal(X_ACCEL, Y_ACCEL, Z_ACCEL);\n  }*/\n  \n//  Serial.print(\"Callibration done! With samples: \");\n//  Serial.println(mean_counter);\n\n  state = 0;\n  t0 = millis();\n}\n\n### Concepts", "fingerprint": null, "seed": "void setup() {\n  analogReference(EXTERNAL);\n  pinMode(X_ACCEL, INPUT);\n  pinMode(Y_ACCEL, INPUT);\n  pinMode(Z_ACCEL, INPUT);\n  pinMode(ledPin, OUTPUT);\n\n  queue_position = 0;\n\n  Serial.begin(9600);\n  Serial1.begin(9600);\n\n  mean_x = 0;\n  mean_y = 0;\n  mean_z = 0;\n  mean_counter = 0;\n//  Serial.begin(9600);\n\n  filtered_value = new FilterBuHp2();\n\n  // Get mean value for threshold\n//  Serial.println(\"Starting callibration...\");\n  t0 = millis();\n  while (millis() - t0 < 4000)\n  {\n    mean_x += getSeparatedValues(X_ACCEL);\n    mean_y += getSeparatedValues(Y_ACCEL);\n    mean_z += getSeparatedValues(Z_ACCEL);\n    mean_counter++;\n  }\n  \n  mean_x /= mean_counter;\n  mean_y /= mean_counter;\n  mean_z /= mean_counter;\n\n//  Serial.print(\"Callibration done! With samples: \");\n//  Serial.println(mean_counter);\n  // Get mean value for threshold\n  /*Serial.println(\"Starting accel callibration. Please stand still for 5 seconds.\");\n  int t0 = millis();\n  while (millis() - t0 < 4000)\n  {\n    mean_value = getFilteredSignal(X_ACCEL, Y_ACCEL, Z_ACCEL);\n  }*/\n  \n//  Serial.print(\"Callibration done! With samples: \");\n//  Serial.println(mean_counter);\n\n  state = 0;\n  t0 = millis();\n}", "id": 86, "concepts": ["pin setup", "sensor initialization", "data filtering and processing", "state machine design for activity recognition", "serial communication/README.md\n# Explain Code\nThe Explain Code project aims to develop a tool that can explain code snippets in natural language.\nGiven a code snippet", "the tool should produce a comprehensive explanation that covers the following aspects:\n\n1. **Code structure**: Break down the code into its constituent parts", "such as functions", "classes", "and modules.\n2. **Code functionality**: Explain the purpose of each function or module and how they work together to achieve the desired functionality.\n3. **Data flow**: Describe the flow of data through the code", "including the input and output of each function or module.\n4. **Design principles**: Highlight the design principles and best practices that have been followed in the code.\n5. **Code quality**: Point out any potential issues or areas for improvement in the code.\n\nTo develop such a tool", "we will employ various techniques from natural language processing and machine learning.\nWe will use techniques like named entity recognition", "dependency parsing", "and text generation to generate the explanation.\nWe will also leverage pre-trained language models like GPT-3 or BERT to enhance the quality of the generated explanation.\nAdditionally", "we will employ techniques like active learning and human feedback to ensure that the generated explanations are accurate and useful.\n\nBy implementing this tool", "we aim to make it easier for developers to understand and maintain complex codebases.\nBy providing a detailed explanation of the code", "it will help developers to quickly grasp the functionality and structure of the code", "making it easier to modify or extend it.\nThis will also help to prevent potential issues and improve code quality.\n\nWe will use the following approach to develop this tool:\n1. **Data collection**: We will collect a dataset of code snippets and their corresponding explanations.\n   This dataset will consist of code snippets and their corresponding explanations written by human experts.\n2. **Model training**: We will train a machine learning model on the dataset to generate explanations for new code snippets.\n   We will use techniques like named entity recognition", "dependency parsing", "and text generation to generate the explanation.\n   We will also leverage pre-trained language models like GPT-3 or BERT to enhance the quality of the generated explanation.\n3. **Active learning**: We will use active learning to iteratively improve the model's performance.\n   This will involve human experts providing feedback on the generated explanations", "allowing the model to learn from its mistakes and improve over time.\n4. **Model evaluation**: We will evaluate the model's performance by testing it on a held-out test set.\n   We will use metrics like precision", "recall", "and F1-score to measure the model's accuracy and effectiveness.\n5. **Deployment**: Once the model has been trained and evaluated", "we will deploy it as a web service or a command-line tool.\n   This will allow developers to easily understand and maintain complex codebases by providing a detailed explanation of the code.\n\nBy following this approach", "we aim to develop a tool that can explain code snippets in natural language", "making it easier for developers to understand and maintain complex codebases.\n/data/code_to_concepts.md\n## Code to Concepts\n\nIn this task", "we will be using a code snippet and its corresponding concepts to train a model that can extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming", "which are crucial for developers to master. The model should be able to identify these concepts and provide a list of them in a comma-separated format.\n\nBelow is an example of a code snippet and its corresponding concepts:\n\n```python\ndef verify_password(user_id", "password):\n    password_hash = get_password_hash(user_id)\n    if not check_password_hash(password_hash", "password):\n        raise ValueError(\"Incorrect password\")\n```\n\nThe corresponding concepts for this code snippet are:\n- Hashing\n- Password Storage\n- Salting\n\nTo train a model to identify these concepts", "we will be using a dataset consisting of code snippets and their corresponding concepts. We will use a machine learning algorithm like a neural network or a decision tree to build the model. We will train the model on the dataset and evaluate its performance using various evaluation metrics like accuracy", "precision", "recall", "and F1-score.\n\nBelow is the implementation of the model using a neural network:\n\n```python\nimport torch\nimport torch.nn as nn\n\nclass ConceptExtractor(nn.Module):\n    def __init__(self", "input_size", "hidden_size", "output_size):\n        super(ConceptExtractor", "self).__init__()\n        self.fc1 = nn.Linear(input_size", "hidden_size)\n        self.relu = nn.ReLU()\n        self.fc2 = nn.Linear(hidden_size", "output_size)\n\n    def forward(self", "x):\n        x = self.fc1(x)\n        x = self.relu(x)\n        x = self.fc2(x)\n        return x\n```"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 3\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 5\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 8\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 9\n### Snippet\nvoid defineConstantFunction(MincBlockExpr* scope, const char* name, PawsType* returnType, std::vector<PawsType*> argTypes, std::vector<std::string> argNames, FuncBlock body, void* funcArgs)\n{\n\tPawsFunc* pawsFunc = new PawsConstFunc(name, returnType, argTypes, argNames, body, funcArgs);\n\tscope->defineSymbol(name, PawsFunctionType::get(pawsSubroutineScope, returnType, argTypes), new PawsFunction(pawsFunc));\n}\n\n### Concepts", "fingerprint": null, "seed": "void defineConstantFunction(MincBlockExpr* scope, const char* name, PawsType* returnType, std::vector<PawsType*> argTypes, std::vector<std::string> argNames, FuncBlock body, void* funcArgs)\n{\n\tPawsFunc* pawsFunc = new PawsConstFunc(name, returnType, argTypes, argNames, body, funcArgs);\n\tscope->defineSymbol(name, PawsFunctionType::get(pawsSubroutineScope, returnType, argTypes), new PawsFunction(pawsFunc));\n}", "id": 87, "concepts": ["constant function definition", "function signature", "function body", "function arguments"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 3\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 4\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 5\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 6\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 8\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 9\n### Snippet\nvoid transpose(float *data_in, float *data_out, int Nx, int Ny) \n{ \n\tint i, j; \n\t#pragma acc parallel loop independent present(data_in[0:Nx*Ny],data_out[0:Ny*Nx]) \n\tfor(i=0;i<Ny;i++) \n\t{ \n\t\t#pragma acc loop independent \n\t\tfor(j=0;j<Nx;j++) \n\t\t{ \n\t\t\tdata_out[i+j*Ny] = data_in[i*Nx+j]; \n\t\t} \n\t} \n}\n\n### Concepts", "fingerprint": null, "seed": "void transpose(float *data_in, float *data_out, int Nx, int Ny) \n{ \n\tint i, j; \n\t#pragma acc parallel loop independent present(data_in[0:Nx*Ny],data_out[0:Ny*Nx]) \n\tfor(i=0;i<Ny;i++) \n\t{ \n\t\t#pragma acc loop independent \n\t\tfor(j=0;j<Nx;j++) \n\t\t{ \n\t\t\tdata_out[i+j*Ny] = data_in[i*Nx+j]; \n\t\t} \n\t} \n}", "id": 88, "concepts": ["OpenACC directives for data movement and parallelization", "memory layout"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 2\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 5\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 7\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 8\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 9\n### Snippet\nvoid fdst_gpu(float *data, float *data2, float *data3, int Nx, int Ny, int Lx) \n{ \n\tfloat s; \n\ts = sqrt(2.0/(Nx+1)); \n\t#pragma acc data present(data3[0:2*Lx*Ny],data[0:Nx*Ny],data2[0:Lx*Ny]) \n\t{ \n\t\texpand_data(data, data2, Nx, Ny, Lx); \n\t\texpand_idata(data2, data3, Nx, Ny, Lx); \n\t\t\n\t\t// Copy data to device at start of region and back to host and end of region \n\t\t// Inside this region the device data pointer will be used \n\t\t#pragma acc host_data use_device(data3) \n\t\t{ \n\t\t\tvoid *stream = acc_get_cuda_stream(acc_async_sync); \n\t\t\tcuda_fft(data3, Lx, Ny, stream); \n\t\t} \n\t\t\n\t\t#pragma acc parallel loop independent \n\t\tfor (int i=0;i<Ny;i++) \n\t\t{ \n\t\t\t#pragma acc loop independent \n\t\t\tfor (int j=0;j<Nx;j++)   data[Nx*i+j] = -1.0*s*data3[2*Lx*i+2*j+3]/2; \n\t\t} \n\t}// end data region\n}\n\n### Concepts", "fingerprint": null, "seed": "void fdst_gpu(float *data, float *data2, float *data3, int Nx, int Ny, int Lx) \n{ \n\tfloat s; \n\ts = sqrt(2.0/(Nx+1)); \n\t#pragma acc data present(data3[0:2*Lx*Ny],data[0:Nx*Ny],data2[0:Lx*Ny]) \n\t{ \n\t\texpand_data(data, data2, Nx, Ny, Lx); \n\t\texpand_idata(data2, data3, Nx, Ny, Lx); \n\t\t\n\t\t// Copy data to device at start of region and back to host and end of region \n\t\t// Inside this region the device data pointer will be used \n\t\t#pragma acc host_data use_device(data3) \n\t\t{ \n\t\t\tvoid *stream = acc_get_cuda_stream(acc_async_sync); \n\t\t\tcuda_fft(data3, Lx, Ny, stream); \n\t\t} \n\t\t\n\t\t#pragma acc parallel loop independent \n\t\tfor (int i=0;i<Ny;i++) \n\t\t{ \n\t\t\t#pragma acc loop independent \n\t\t\tfor (int j=0;j<Nx;j++)   data[Nx*i+j] = -1.0*s*data3[2*Lx*i+2*j+3]/2; \n\t\t} \n\t}// end data region\n}", "id": 89, "concepts": ["CUDA programming for GPU acceleration", "data transfer between host and device", "parallel loop execution"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 3\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 5\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 6\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 9\n### Snippet\nvoid myOnFrame(void *simulation) {\n    cout << \"FRAME!\" << endl;\n}\n\n### Concepts", "fingerprint": null, "seed": "void myOnFrame(void *simulation) {\n    cout << \"FRAME!\" << endl;\n}", "id": 90, "concepts": ["simulation of a frame in a game", "on-frame callback", "game loop"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 2\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 3\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 6\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 9\n### Snippet\ndouble toKilo(double x){\n\ndouble numKilo = x * kilograms;\n    return numKilo;\n    }\n\n### Concepts", "fingerprint": null, "seed": "double toKilo(double x){\n\ndouble numKilo = x * kilograms;\n    return numKilo;\n    }", "id": 91, "concepts": ["The toKilo() function takes a double value x and returns the equivalent value in kilograms."]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 3\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 4\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 7\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 9\n### Snippet\ninline bool inside(const Vector2d &pt) {\n    return pt(0, 0) >= boarder && pt(1, 0) >= boarder\n           && pt(0, 0) < width - boarder && pt(1, 0) <= height - boarder;\n}\n\n### Concepts", "fingerprint": null, "seed": "inline bool inside(const Vector2d &pt) {\n    return pt(0, 0) >= boarder && pt(1, 0) >= boarder\n           && pt(0, 0) < width - boarder && pt(1, 0) <= height - boarder;\n}", "id": 92, "concepts": ["point-in-polygon checks using bounding box", "edge cases handling with boarder size and size checks"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 3\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 6\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 7\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 8\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 9\n### Snippet\nint main()\n{\n\tlong int t,a[3],i;\n\tscanf(\"%li\", &t);\n\twhile(t--)\n\t{\n\t\tfor(i=0;i<3;++i)\n\t\t\tscanf(\"%li\", &a[i]);\n\t\tsort(a,a+3);\n\t\tprintf(\"%li\\n\", a[1]);\n\t}\n\treturn 0;\n}\n\n### Concepts", "fingerprint": null, "seed": "int main()\n{\n\tlong int t,a[3],i;\n\tscanf(\"%li\", &t);\n\twhile(t--)\n\t{\n\t\tfor(i=0;i<3;++i)\n\t\t\tscanf(\"%li\", &a[i]);\n\t\tsort(a,a+3);\n\t\tprintf(\"%li\\n\", a[1]);\n\t}\n\treturn 0;\n}", "id": 93, "concepts": ["problem solving", "sorting", "I/O handling"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 3\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 4\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 6\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 9\n### Snippet\nint main()\n{\n\tchar choice = 'N';\n\tint numSelected; // Entered by user\n\tint qtySelected; // Entered by user\n\tdouble subTotal; // Local variable for subTotal\n\tdouble tax; // Local variable for tax\n\tdouble total; // Local variable for total\n\n\tInventoryItem inventory[5] = { InventoryItem(\"Adjustable Wrench\", 3.49, 10),\n\t\t\t\t\t\t\t\t   InventoryItem(\"Screwdriver\", 5.99, 20),\n\t\t\t\t\t\t\t\t   InventoryItem(\"Pliers\", 2.69, 35),\n\t\t\t\t\t\t\t\t   InventoryItem(\"Ratchet\", 3.99, 10),\n\t\t\t\t\t\t\t\t   InventoryItem(\"Socket Wrench\", 2.49, 7) };\n\n\tdo\n\t{\n\t\tcout << left << setw(5) << \"#\" << setw(20) << \"Item\" << setw(20) << \"qty on Hand\" << endl;\n\t\tcout << \"-------------------------------------------------------\" << endl;\n\n\t\t// Display the inventory item\n\t\tDisplayItem(inventory);\n\n\t\t// Ask the user which item do they want to buy\n\t\tcout << endl << \"Which item above is beging purchased?\" << endl;\n\t\tcin >> numSelected;\n\n\t\t// Validate the user's input is on the list\n\t\twhile ((numSelected - 1) < 0 || (numSelected - 1) > 4)\n\t\t{\n\t\t\tcout << \"Invalid entry, please enter the valid number of goods: \";\n\t\t\tcin >> numSelected;\n\t\t}\n\n\n\t\t// Validate the item is not out of stock\n\t\twhile (inventory[numSelected - 1].getUnits() == 0)\n\t\t{\n\t\t\tcout << \"Sorry, this item is out of stock.\" << endl;\n\t\t\tcout << \"Please choose another item: \";\n\t\t\tcin >> numSelected;\n\t\t}\n\n\t\t// Ask the user how many items do they want\n\t\tcout << \"How many units?\" << endl;\n\t\tcin >> qtySelected;\n\n\t\t// Validate the qtySelected is not a negative value\n\t\twhile (qtySelected < 0)\n\t\t{\n\t\t\tcout << \"Error. Cannot enter negetive number\" << endl;\n\t\t\tcout << \"Please enter again: \";\n\t\t\tcin >> qtySelected;\n\t\t}\n\n\t\t// Validate the inventory of item is not being a negative value\n\t\twhile (inventory[numSelected - 1].getUnits() < qtySelected)\n\t\t{\n\t\t\tcout << \"Sorry. We do not have enough items.\" << endl;\n\t\t\tcout << \"Please enter again: \";\n\t\t\tcin >> qtySelected;\n\t\t}\n\n\t\t// Update InventoryItem\n\t\tinventory[numSelected - 1].setUnits(inventory[numSelected - 1].getUnits() - qtySelected);\n\n\t\t// Define an instance of the CashRegister class\n\t\tCashRegister Sale = CashRegister(inventory[numSelected - 1], qtySelected);\n\n\t\tcout << endl;\n\t\t// Get subtotal, tax, and total\n\t\tsubTotal = Sale.GetSubtotal();\n\t\ttax = Sale.GetTax();\n\t\ttotal = Sale.GetTotal();\n\n\t\t// Display subtotal, tax, and total\n\t\tcout << fixed << showpoint << setprecision(2);\n\t\tcout << \"Subtotal: $ \" << subTotal << endl;\n\t\tcout << \"Tax: $ \" << tax << endl;;\n\t\tcout << \"Total: $ \" << total << endl << endl;\t\t\n\n\t\t// Ask user to run again or not\n\t\tcout << \"Do you want to purchase another item? (Y/N)  \";\n\t\tcin >> choice;\n\t\tcout << endl;\n\t\t\n\t} while (choice == 'Y' || choice == 'y');\n\t\n\tcout << endl;\n\n\treturn 0;\n}\n\n### Concepts", "fingerprint": null, "seed": "int main()\n{\n\tchar choice = 'N';\n\tint numSelected; // Entered by user\n\tint qtySelected; // Entered by user\n\tdouble subTotal; // Local variable for subTotal\n\tdouble tax; // Local variable for tax\n\tdouble total; // Local variable for total\n\n\tInventoryItem inventory[5] = { InventoryItem(\"Adjustable Wrench\", 3.49, 10),\n\t\t\t\t\t\t\t\t   InventoryItem(\"Screwdriver\", 5.99, 20),\n\t\t\t\t\t\t\t\t   InventoryItem(\"Pliers\", 2.69, 35),\n\t\t\t\t\t\t\t\t   InventoryItem(\"Ratchet\", 3.99, 10),\n\t\t\t\t\t\t\t\t   InventoryItem(\"Socket Wrench\", 2.49, 7) };\n\n\tdo\n\t{\n\t\tcout << left << setw(5) << \"#\" << setw(20) << \"Item\" << setw(20) << \"qty on Hand\" << endl;\n\t\tcout << \"-------------------------------------------------------\" << endl;\n\n\t\t// Display the inventory item\n\t\tDisplayItem(inventory);\n\n\t\t// Ask the user which item do they want to buy\n\t\tcout << endl << \"Which item above is beging purchased?\" << endl;\n\t\tcin >> numSelected;\n\n\t\t// Validate the user's input is on the list\n\t\twhile ((numSelected - 1) < 0 || (numSelected - 1) > 4)\n\t\t{\n\t\t\tcout << \"Invalid entry, please enter the valid number of goods: \";\n\t\t\tcin >> numSelected;\n\t\t}\n\n\n\t\t// Validate the item is not out of stock\n\t\twhile (inventory[numSelected - 1].getUnits() == 0)\n\t\t{\n\t\t\tcout << \"Sorry, this item is out of stock.\" << endl;\n\t\t\tcout << \"Please choose another item: \";\n\t\t\tcin >> numSelected;\n\t\t}\n\n\t\t// Ask the user how many items do they want\n\t\tcout << \"How many units?\" << endl;\n\t\tcin >> qtySelected;\n\n\t\t// Validate the qtySelected is not a negative value\n\t\twhile (qtySelected < 0)\n\t\t{\n\t\t\tcout << \"Error. Cannot enter negetive number\" << endl;\n\t\t\tcout << \"Please enter again: \";\n\t\t\tcin >> qtySelected;\n\t\t}\n\n\t\t// Validate the inventory of item is not being a negative value\n\t\twhile (inventory[numSelected - 1].getUnits() < qtySelected)\n\t\t{\n\t\t\tcout << \"Sorry. We do not have enough items.\" << endl;\n\t\t\tcout << \"Please enter again: \";\n\t\t\tcin >> qtySelected;\n\t\t}\n\n\t\t// Update InventoryItem\n\t\tinventory[numSelected - 1].setUnits(inventory[numSelected - 1].getUnits() - qtySelected);\n\n\t\t// Define an instance of the CashRegister class\n\t\tCashRegister Sale = CashRegister(inventory[numSelected - 1], qtySelected);\n\n\t\tcout << endl;\n\t\t// Get subtotal, tax, and total\n\t\tsubTotal = Sale.GetSubtotal();\n\t\ttax = Sale.GetTax();\n\t\ttotal = Sale.GetTotal();\n\n\t\t// Display subtotal, tax, and total\n\t\tcout << fixed << showpoint << setprecision(2);\n\t\tcout << \"Subtotal: $ \" << subTotal << endl;\n\t\tcout << \"Tax: $ \" << tax << endl;;\n\t\tcout << \"Total: $ \" << total << endl << endl;\t\t\n\n\t\t// Ask user to run again or not\n\t\tcout << \"Do you want to purchase another item? (Y/N)  \";\n\t\tcin >> choice;\n\t\tcout << endl;\n\t\t\n\t} while (choice == 'Y' || choice == 'y');\n\t\n\tcout << endl;\n\n\treturn 0;\n}", "id": 94, "concepts": ["object-oriented programming", "error handling", "user input validation", "data structure for inventory management", "cash register simulation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 2\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 6\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 8\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 9\n### Snippet\nint main() {\n    \n    UnitTest test;\n\n    test.run();\n}\n\n### Concepts", "fingerprint": null, "seed": "int main() {\n    \n    UnitTest test;\n\n    test.run();\n}", "id": 95, "concepts": ["unit testing", "test-driven development", "code quality measurement"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 4\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 5\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 6\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 8\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 9\n### Snippet\nvoid dfs(int u,int fath)\n{\n\tfa[u][0]=fath;deep[u]=deep[fath]+1;\n\tfor(int i=head[u];i;i=e[i].next)\n\t{\n\t\tint v=e[i].v;\n\t\tif(v==fath) continue;\n\t\tval[v][0]=e[i].w;\n\t\tdfs(v,u);\n\t}\n}\n\n### Concepts", "fingerprint": null, "seed": "void dfs(int u,int fath)\n{\n\tfa[u][0]=fath;deep[u]=deep[fath]+1;\n\tfor(int i=head[u];i;i=e[i].next)\n\t{\n\t\tint v=e[i].v;\n\t\tif(v==fath) continue;\n\t\tval[v][0]=e[i].w;\n\t\tdfs(v,u);\n\t}\n}", "id": 96, "concepts": ["depth-first search (DFS) traversal", "tree construction", "parent-child relation storage"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 4\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 5\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 7\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 8\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 9\n### Snippet\nvoid TriggerDictionaryInitialization_BMHitClusterDict() {\n  TriggerDictionaryInitialization_BMHitClusterDict_Impl();\n}\n\n### Concepts", "fingerprint": null, "seed": "void TriggerDictionaryInitialization_BMHitClusterDict() {\n  TriggerDictionaryInitialization_BMHitClusterDict_Impl();\n}", "id": 98, "concepts": ["function definition", "function signature", "initialization", "library import"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 2\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 3\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 7\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 9\n### Snippet\nint main()\n{\n    int t;\n    cin>>t;\n    getchar();\n    while(t--)\n    {\n        char a[1001];\n        cin.getline(a,1001);\n        int n=strlen(a);\n        for(int i=0;i<n;i++)\n        {\n            int k=i;\n            while(a[k]!=' '&&a[k]!='\\0') k++;\n            for(int j=k-1;j>=i;j--)\n              cout<<a[j]; i=k;\n             if(a[i]==' ') cout<<' ';\n        }\n        cout<<endl;\n    }\n}\n\n### Concepts", "fingerprint": null, "seed": "int main()\n{\n    int t;\n    cin>>t;\n    getchar();\n    while(t--)\n    {\n        char a[1001];\n        cin.getline(a,1001);\n        int n=strlen(a);\n        for(int i=0;i<n;i++)\n        {\n            int k=i;\n            while(a[k]!=' '&&a[k]!='\\0') k++;\n            for(int j=k-1;j>=i;j--)\n              cout<<a[j]; i=k;\n             if(a[i]==' ') cout<<' ';\n        }\n        cout<<endl;\n    }\n}", "id": 99, "concepts": ["string reversal using two nested loops", "space handling"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 5\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 6\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 8\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 9\n### Snippet\nint main(int argc, char *argv[])\n{\n\tyyparse();\n\treturn 0;\n}\n\n### Concepts", "fingerprint": null, "seed": "int main(int argc, char *argv[])\n{\n\tyyparse();\n\treturn 0;\n}", "id": 100, "concepts": ["parser generation", "abstract syntax tree construction", "syntax error handling"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 3\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 7\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 8\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 9\n### Snippet\nfloat getSimpleValue(int pin_x, int pin_y, int pin_z)\n{\n  float instant_value_x = analogRead(pin_x);\n  float instant_value_y = analogRead(pin_y);\n  float instant_value_z = analogRead(pin_z);\n\n  float result = sqrt(pow(instant_value_x,2) + pow(instant_value_y,2) + pow(instant_value_z,2));\n\n  return result;\n}\n\n### Concepts", "fingerprint": null, "seed": "float getSimpleValue(int pin_x, int pin_y, int pin_z)\n{\n  float instant_value_x = analogRead(pin_x);\n  float instant_value_y = analogRead(pin_y);\n  float instant_value_z = analogRead(pin_z);\n\n  float result = sqrt(pow(instant_value_x,2) + pow(instant_value_y,2) + pow(instant_value_z,2));\n\n  return result;\n}", "id": 101, "concepts": ["sensor data processing", "mathematical operations for vector magnitude calculation", "function design for reusability"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 3\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 4\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 5\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 9\n### Snippet\nvoid avg_pool_backprop(const T* delta,\n                       T* out,\n                       const Shape& delta_shape,\n                       const Shape& out_shape,\n                       const Shape& window_shape,\n                       const Strides& window_movement_strides,\n                       const Shape& padding_below,\n                       const Shape& padding_above,\n                       bool include_padding_in_avg_computation) {\n    NGRAPH_SUPPRESS_DEPRECATED_START\n    CoordinateTransform out_transform(out_shape);\n\n    for (const Coordinate& out_coord : out_transform) {\n        out[out_transform.index(out_coord)] = 0;\n    }\n\n    CoordinateTransform delta_transform(delta_shape);\n\n    for (const Coordinate& delta_coord : delta_transform) {\n        size_t img_index = delta_coord[0];\n        size_t channel = delta_coord[1];\n\n        size_t n_image_dimensions = out_shape.size() - 2;\n        Coordinate source_window_transform_start(2 + n_image_dimensions);\n        Coordinate source_window_transform_end(2 + n_image_dimensions);\n        Strides source_window_transform_source_strides(2 + n_image_dimensions, 1);\n        AxisVector source_window_transform_source_axis_order(2 + n_image_dimensions);\n        CoordinateDiff source_window_transform_padding_below(2 + n_image_dimensions);\n        CoordinateDiff source_window_transform_padding_above(2 + n_image_dimensions);\n\n        source_window_transform_start[0] = img_index;\n        source_window_transform_end[0] = img_index + 1;\n        source_window_transform_start[1] = channel;\n        source_window_transform_end[1] = channel + 1;\n        source_window_transform_padding_below[0] = 0;\n        source_window_transform_padding_below[1] = 0;\n        source_window_transform_padding_above[0] = 0;\n        source_window_transform_padding_above[1] = 0;\n\n        for (size_t i = 2; i < n_image_dimensions + 2; i++) {\n            size_t window_shape_this_dim = window_shape[i - 2];\n            size_t movement_stride = window_movement_strides[i - 2];\n\n            source_window_transform_start[i] = movement_stride * delta_coord[i];\n            source_window_transform_end[i] = source_window_transform_start[i] + window_shape_this_dim;\n            source_window_transform_padding_below[i] = padding_below[i - 2];\n            source_window_transform_padding_above[i] = padding_above[i - 2];\n        }\n        std::iota(begin(source_window_transform_source_axis_order), end(source_window_transform_source_axis_order), 0);\n\n        CoordinateTransform source_window_transform(out_shape,\n                                                    source_window_transform_start,\n                                                    source_window_transform_end,\n                                                    source_window_transform_source_strides,\n                                                    source_window_transform_source_axis_order,\n                                                    source_window_transform_padding_below,\n                                                    source_window_transform_padding_above);\n\n        size_t num_elements_in_window = 0;\n\n        for (const Coordinate& source_window_coord : source_window_transform) {\n            if (source_window_transform.has_source_coordinate(source_window_coord) ||\n                include_padding_in_avg_computation) {\n                num_elements_in_window++;\n            }\n        }\n\n        for (const Coordinate& source_window_coord : source_window_transform) {\n            if (source_window_transform.has_source_coordinate(source_window_coord)) {\n                size_t out_index = source_window_transform.index(source_window_coord);\n                out[out_index] += delta[delta_transform.index(delta_coord)] / num_elements_in_window;\n            }\n        }\n    }\n    NGRAPH_SUPPRESS_DEPRECATED_END\n}\n\n### Concepts", "fingerprint": null, "seed": "void avg_pool_backprop(const T* delta,\n                       T* out,\n                       const Shape& delta_shape,\n                       const Shape& out_shape,\n                       const Shape& window_shape,\n                       const Strides& window_movement_strides,\n                       const Shape& padding_below,\n                       const Shape& padding_above,\n                       bool include_padding_in_avg_computation) {\n    NGRAPH_SUPPRESS_DEPRECATED_START\n    CoordinateTransform out_transform(out_shape);\n\n    for (const Coordinate& out_coord : out_transform) {\n        out[out_transform.index(out_coord)] = 0;\n    }\n\n    CoordinateTransform delta_transform(delta_shape);\n\n    for (const Coordinate& delta_coord : delta_transform) {\n        size_t img_index = delta_coord[0];\n        size_t channel = delta_coord[1];\n\n        size_t n_image_dimensions = out_shape.size() - 2;\n        Coordinate source_window_transform_start(2 + n_image_dimensions);\n        Coordinate source_window_transform_end(2 + n_image_dimensions);\n        Strides source_window_transform_source_strides(2 + n_image_dimensions, 1);\n        AxisVector source_window_transform_source_axis_order(2 + n_image_dimensions);\n        CoordinateDiff source_window_transform_padding_below(2 + n_image_dimensions);\n        CoordinateDiff source_window_transform_padding_above(2 + n_image_dimensions);\n\n        source_window_transform_start[0] = img_index;\n        source_window_transform_end[0] = img_index + 1;\n        source_window_transform_start[1] = channel;\n        source_window_transform_end[1] = channel + 1;\n        source_window_transform_padding_below[0] = 0;\n        source_window_transform_padding_below[1] = 0;\n        source_window_transform_padding_above[0] = 0;\n        source_window_transform_padding_above[1] = 0;\n\n        for (size_t i = 2; i < n_image_dimensions + 2; i++) {\n            size_t window_shape_this_dim = window_shape[i - 2];\n            size_t movement_stride = window_movement_strides[i - 2];\n\n            source_window_transform_start[i] = movement_stride * delta_coord[i];\n            source_window_transform_end[i] = source_window_transform_start[i] + window_shape_this_dim;\n            source_window_transform_padding_below[i] = padding_below[i - 2];\n            source_window_transform_padding_above[i] = padding_above[i - 2];\n        }\n        std::iota(begin(source_window_transform_source_axis_order), end(source_window_transform_source_axis_order), 0);\n\n        CoordinateTransform source_window_transform(out_shape,\n                                                    source_window_transform_start,\n                                                    source_window_transform_end,\n                                                    source_window_transform_source_strides,\n                                                    source_window_transform_source_axis_order,\n                                                    source_window_transform_padding_below,\n                                                    source_window_transform_padding_above);\n\n        size_t num_elements_in_window = 0;\n\n        for (const Coordinate& source_window_coord : source_window_transform) {\n            if (source_window_transform.has_source_coordinate(source_window_coord) ||\n                include_padding_in_avg_computation) {\n                num_elements_in_window++;\n            }\n        }\n\n        for (const Coordinate& source_window_coord : source_window_transform) {\n            if (source_window_transform.has_source_coordinate(source_window_coord)) {\n                size_t out_index = source_window_transform.index(source_window_coord);\n                out[out_index] += delta[delta_transform.index(delta_coord)] / num_elements_in_window;\n            }\n        }\n    }\n    NGRAPH_SUPPRESS_DEPRECATED_END\n}", "id": 102, "concepts": ["convolution backpropagation", "reverse computation", "padding handling", "coordinate transformation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 2\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 3\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 5\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 7\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 8\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 9\n### Snippet\nvoid setup() {\n  Serial.begin(9600);   \n}\n\n### Concepts", "fingerprint": null, "seed": "void setup() {\n  Serial.begin(9600);   \n}", "id": 103, "concepts": ["setup code for initializing the serial communication"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 2\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 5\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 7\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 8\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 9\n### Snippet\nstatic bool\ngetBoolBuffer(cstring buffer)\n{\n    return buffer[0] == 't' &&\n           buffer[1] == 'r' &&\n           buffer[2] == 'u' &&\n           buffer[3] == 'e';\n}\n\n### Concepts", "fingerprint": null, "seed": "static bool\ngetBoolBuffer(cstring buffer)\n{\n    return buffer[0] == 't' &&\n           buffer[1] == 'r' &&\n           buffer[2] == 'u' &&\n           buffer[3] == 'e';\n}", "id": 104, "concepts": ["string matching with a buffer", "constant time string comparison"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 4\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 5\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 6\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 9\n### Snippet\nvoid addPark (Park parks[], string parkname, string state, int area, int length)\n{\n  //adds the park struct type to the array\n  parks[length].parkname = parkname;\n  parks[length].state = state;\n  parks[length].area = area;\n}\n\n### Concepts", "fingerprint": null, "seed": "void addPark (Park parks[], string parkname, string state, int area, int length)\n{\n  //adds the park struct type to the array\n  parks[length].parkname = parkname;\n  parks[length].state = state;\n  parks[length].area = area;\n}", "id": 105, "concepts": ["array manipulation", "struct usage", "function definition and implementation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 2\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 4\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 6\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 9\n### Snippet\nint calc_get_var(const char *s, int *val)\n{\n\tvar_map::iterator it = calc_var_map.find(s);\n\n\tif (it != calc_var_map.end()) {\n\t\t*val = it->second;\n\t\treturn 0;\n\t} else {\n\t\tstd::cerr << \"variable \" << s << \" is not set\" <<std::endl;\n\t\treturn -1;\n\t}\n}\n\n### Concepts", "fingerprint": null, "seed": "int calc_get_var(const char *s, int *val)\n{\n\tvar_map::iterator it = calc_var_map.find(s);\n\n\tif (it != calc_var_map.end()) {\n\t\t*val = it->second;\n\t\treturn 0;\n\t} else {\n\t\tstd::cerr << \"variable \" << s << \" is not set\" <<std::endl;\n\t\treturn -1;\n\t}\n}", "id": 106, "concepts": ["dictionary lookup for variable mapping", "error handling with return values"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 2\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 3\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 4\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 9\n### Snippet\nvoid blinker() {\n    for (int i=0; i<5; i++) {  // 10\n        digitalWrite(led, LOW);    \n        delay(100);      \n        digitalWrite(led, HIGH);        \n        delay(100); \n    }\n}\n\n### Concepts", "fingerprint": null, "seed": "void blinker() {\n    for (int i=0; i<5; i++) {  // 10\n        digitalWrite(led, LOW);    \n        delay(100);      \n        digitalWrite(led, HIGH);        \n        delay(100); \n    }\n}", "id": 107, "concepts": ["led blinking", "loop iteration", "delay function for time control"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 3\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 6\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 8\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 9\n### Snippet\nint main()\r\n{\r\n    int no_of_test_cases;\r\n    cin >> no_of_test_cases;\r\n\r\n    while(no_of_test_cases--)\r\n        solve();\r\n\r\n    return 0;\r\n}\n\n### Concepts", "fingerprint": null, "seed": "int main()\r\n{\r\n    int no_of_test_cases;\r\n    cin >> no_of_test_cases;\r\n\r\n    while(no_of_test_cases--)\r\n        solve();\r\n\r\n    return 0;\r\n}", "id": 108, "concepts": ["program entry point", "test case handling", "function composition"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 2\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 4\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 5\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 6\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 7\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 9\n### Snippet\nvoid myOnDraw(Display* d) {\n    cout << \"Display\" << endl;\n}\n\n### Concepts", "fingerprint": null, "seed": "void myOnDraw(Display* d) {\n    cout << \"Display\" << endl;\n}", "id": 109, "concepts": ["event handling", "display update", "user interface"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 4\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 5\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 6\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 7\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 8\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 9\n### Snippet\nint main(int argc, char *argv[]){\n  m_error_t res;\n  size_t tests, errors;\n\n  tests = errors = 0;\n\n  try {\n    Forker Mother;\n\n    printf(\"Test %d: InetStreamSocket CTROR\\n\",++tests);\n    InetStreamSocket socket;\n    puts(\"+++ CTOR finished OK!\");\n    \n    printf(\"Test %d: InetStreamSocket::hostname()\\n\",++tests);\n    res = socket.hostname(\"localhost\");\n    if(ERR_NO_ERROR != res){\n      errors++;\n      printf(\"*** Error: hostname() failed 0x%.4x\\n\",(int)res);\n    } else {\n      puts(\"+++ hostname() finished OK!\");\n    }\n\n    const unsigned short pNum = 60179;\n    printf(\"Test %d: InetStreamSocket::port()\\n\",++tests);\n    res = socket.port(pNum);\n    if(ERR_NO_ERROR != res){\n      errors++;\n      printf(\"*** Error: port() failed 0x%.4x\\n\",(int)res);\n    } else {\n      puts(\"+++ port() finished OK!\");\n    }\n    \n    printf(\"Test %d: InetStreamSocket::ipv4()\\n\",++tests);\n    unsigned long ip = socket.ipv4();\n    // 127.0.0.1\n    const unsigned long loc_ip = (127 << (3*8)) + 1;\n    if((ip != loc_ip) || (pNum != socket.port())){\n      errors++;\n      printf(\"*** Error: Wrong address %d.%d.%d.%d:%d\\n\",\n\t     (int)((ip >> (3*8)) & 0xff),\n\t     (int)((ip >> (2*8)) & 0xff),\n\t     (int)((ip >> (1*8)) & 0xff),\n\t     (int)((ip >> (0*8)) & 0xff),\n\t     socket.port());\n    } else {\n      printf(\"??? Address %d.%d.%d.%d:%d\\n\",\n\t     (int)((ip >> (3*8)) & 0xff),\n\t     (int)((ip >> (2*8)) & 0xff),\n\t     (int)((ip >> (1*8)) & 0xff),\n\t     (int)((ip >> (0*8)) & 0xff),\n\t     socket.port());\n      puts(\"+++ ipv4() finished OK!\");\n    }\n      \n    // Setup pipe for syncronizing server and client\n    int pfd[2];\n    if(::pipe(pfd)){\n      printf(\"*** Error: pipe() failed %d\\n\",errno);\n      perror(\"*** System Error\");\n      mgrThrow(ERR_FILE_OPEN);      \n    }\n\n    pid_t child = -1;\n    res = Mother.fork( child );\n    if(res != ERR_NO_ERROR){\n      printf(\"*** Error: fork() failed 0x%.4x\\n\",(int)res);\n      perror(\"*** System Error\");\n    } else {\n      if(child == 0){\n\tres = do_client(socket,pfd[0],tests,errors);\n\tprintf(\"+++ Client exits 0x%.4x\\n\",(int)res);\n      } else {\n\tres = do_server(socket,pfd[1],tests,errors,child);\n\tprintf(\"+++ Server exits 0x%.4x\\n\",(int)res);\n\tres = Mother.wait(5000);\n\tif(ERR_CANCEL == res){\n\t  puts(\"*** Have Zombies - kill'em\");\n\t  if(ERR_NO_ERROR == Mother.killChildren()){\n\t    res = Mother.wait(1000);\n\t    if(res != ERR_NO_ERROR)\n\t      printf(\"*** Error killing Zombies 0x%.4x\\n\",(int)res);\n\t  }\n\t}\n\tprintf(\"+++ Mother exits 0x%.4x\\n\",(int)res);\n\tprintf(\"Used version: %s\\n\",socket.VersionTag());\n      }\t\n    }\n      \n  }\n  catch(Exception& e){\n    printf(\"*** Caught mgr::Exception: %s\\n\",e.what());\n  }\n\n  return 0;  \n}\n\n### Concepts", "fingerprint": null, "seed": "int main(int argc, char *argv[]){\n  m_error_t res;\n  size_t tests, errors;\n\n  tests = errors = 0;\n\n  try {\n    Forker Mother;\n\n    printf(\"Test %d: InetStreamSocket CTROR\\n\",++tests);\n    InetStreamSocket socket;\n    puts(\"+++ CTOR finished OK!\");\n    \n    printf(\"Test %d: InetStreamSocket::hostname()\\n\",++tests);\n    res = socket.hostname(\"localhost\");\n    if(ERR_NO_ERROR != res){\n      errors++;\n      printf(\"*** Error: hostname() failed 0x%.4x\\n\",(int)res);\n    } else {\n      puts(\"+++ hostname() finished OK!\");\n    }\n\n    const unsigned short pNum = 60179;\n    printf(\"Test %d: InetStreamSocket::port()\\n\",++tests);\n    res = socket.port(pNum);\n    if(ERR_NO_ERROR != res){\n      errors++;\n      printf(\"*** Error: port() failed 0x%.4x\\n\",(int)res);\n    } else {\n      puts(\"+++ port() finished OK!\");\n    }\n    \n    printf(\"Test %d: InetStreamSocket::ipv4()\\n\",++tests);\n    unsigned long ip = socket.ipv4();\n    // 127.0.0.1\n    const unsigned long loc_ip = (127 << (3*8)) + 1;\n    if((ip != loc_ip) || (pNum != socket.port())){\n      errors++;\n      printf(\"*** Error: Wrong address %d.%d.%d.%d:%d\\n\",\n\t     (int)((ip >> (3*8)) & 0xff),\n\t     (int)((ip >> (2*8)) & 0xff),\n\t     (int)((ip >> (1*8)) & 0xff),\n\t     (int)((ip >> (0*8)) & 0xff),\n\t     socket.port());\n    } else {\n      printf(\"??? Address %d.%d.%d.%d:%d\\n\",\n\t     (int)((ip >> (3*8)) & 0xff),\n\t     (int)((ip >> (2*8)) & 0xff),\n\t     (int)((ip >> (1*8)) & 0xff),\n\t     (int)((ip >> (0*8)) & 0xff),\n\t     socket.port());\n      puts(\"+++ ipv4() finished OK!\");\n    }\n      \n    // Setup pipe for syncronizing server and client\n    int pfd[2];\n    if(::pipe(pfd)){\n      printf(\"*** Error: pipe() failed %d\\n\",errno);\n      perror(\"*** System Error\");\n      mgrThrow(ERR_FILE_OPEN);      \n    }\n\n    pid_t child = -1;\n    res = Mother.fork( child );\n    if(res != ERR_NO_ERROR){\n      printf(\"*** Error: fork() failed 0x%.4x\\n\",(int)res);\n      perror(\"*** System Error\");\n    } else {\n      if(child == 0){\n\tres = do_client(socket,pfd[0],tests,errors);\n\tprintf(\"+++ Client exits 0x%.4x\\n\",(int)res);\n      } else {\n\tres = do_server(socket,pfd[1],tests,errors,child);\n\tprintf(\"+++ Server exits 0x%.4x\\n\",(int)res);\n\tres = Mother.wait(5000);\n\tif(ERR_CANCEL == res){\n\t  puts(\"*** Have Zombies - kill'em\");\n\t  if(ERR_NO_ERROR == Mother.killChildren()){\n\t    res = Mother.wait(1000);\n\t    if(res != ERR_NO_ERROR)\n\t      printf(\"*** Error killing Zombies 0x%.4x\\n\",(int)res);\n\t  }\n\t}\n\tprintf(\"+++ Mother exits 0x%.4x\\n\",(int)res);\n\tprintf(\"Used version: %s\\n\",socket.VersionTag());\n      }\t\n    }\n      \n  }\n  catch(Exception& e){\n    printf(\"*** Caught mgr::Exception: %s\\n\",e.what());\n  }\n\n  return 0;  \n}", "id": 110, "concepts": ["forking a child process", "socket programming", "synchronization between processes", "error handling", "exception handling", "pipe creation and use"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 2\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 3\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 5\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 8\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 9\n### Snippet\nint main()\n{\n    int start1, start2, n;\n    scanf(\"%d%d%d\", &start1,&start2, &n);\n    for(int i = 0; i < n; i++)\n    {\n        int add, nt;\n        char c;\n        scanf(\"%d %c %d\", &add, &c, &nt);\n        node n1 = {c, nt};\n        arr[add] = n1;\n    }\n\n    set<int> s1;\n\n    int i1 = start1;\n    while(i1 != -1)\n    {\n        s1.insert(i1);\n        i1 = arr[i1].next;\n    }\n\n    int i2 = start2;\n    while(i2 != -1)\n    {\n        if(s1.find(i2) != s1.end())\n        {\n            printf(\"%d\", i2);\n            return 0;\n        }\n        else\n        {\n            i2 = arr[i2].next;\n        }\n        \n    }\n    if(i2 == -1)\n        printf(\"-1\");\n\n    return 0;\n}\n\n### Concepts", "fingerprint": null, "seed": "int main()\n{\n    int start1, start2, n;\n    scanf(\"%d%d%d\", &start1,&start2, &n);\n    for(int i = 0; i < n; i++)\n    {\n        int add, nt;\n        char c;\n        scanf(\"%d %c %d\", &add, &c, &nt);\n        node n1 = {c, nt};\n        arr[add] = n1;\n    }\n\n    set<int> s1;\n\n    int i1 = start1;\n    while(i1 != -1)\n    {\n        s1.insert(i1);\n        i1 = arr[i1].next;\n    }\n\n    int i2 = start2;\n    while(i2 != -1)\n    {\n        if(s1.find(i2) != s1.end())\n        {\n            printf(\"%d\", i2);\n            return 0;\n        }\n        else\n        {\n            i2 = arr[i2].next;\n        }\n        \n    }\n    if(i2 == -1)\n        printf(\"-1\");\n\n    return 0;\n}", "id": 111, "concepts": ["linked list intersection", "loop detection", "hash set usage", "null node handling"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 5\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 6\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 9\n### Snippet\nvoid sumofpzem()\n{\n    Serial.println(\"Sum of all 3 PZEM devices\");\n    sum_of_voltage        =   (voltage_usage_1 + voltage_usage_2 + voltage_usage_3);\n    sum_of_current        =   (current_usage_1 + current_usage_2 + current_usage_3);\n    sum_of_power          =   (active_power_1 + active_power_2 + active_power_3);\n    sum_of_active_energy  =   (active_energy_1 + active_energy_2 + active_energy_3); \n    sum_of_frequency      =   (frequency_1 + frequency_2 + frequency_3);\n    sum_of_power_factor   =   (power_factor_1 + power_factor_2 + power_factor_3); \n    \n    Serial.print(\"SUM of VOLTAGE:           \");   Serial.println(sum_of_voltage);             // V\n    Serial.print(\"SUM of CURRENT_USAGE:     \");   Serial.println(sum_of_current, 3);          // A\n    Serial.print(\"SUM of ACTIVE_POWER:      \");   Serial.println(sum_of_power);               // W\n    Serial.print(\"SUM of ACTIVE_ENERGY:     \");   Serial.println(sum_of_active_energy, 3);    // kWh\n    Serial.print(\"SUM of FREQUENCY:         \");   Serial.println(sum_of_frequency);           // Hz\n    Serial.print(\"SUM of POWER_FACTOR:      \");   Serial.println(sum_of_power_factor);\n    Serial.println(\"====================================================\");\n      \n    low_voltage_check();\n    high_voltage_check();\n}\n\n### Concepts", "fingerprint": null, "seed": "void sumofpzem()\n{\n    Serial.println(\"Sum of all 3 PZEM devices\");\n    sum_of_voltage        =   (voltage_usage_1 + voltage_usage_2 + voltage_usage_3);\n    sum_of_current        =   (current_usage_1 + current_usage_2 + current_usage_3);\n    sum_of_power          =   (active_power_1 + active_power_2 + active_power_3);\n    sum_of_active_energy  =   (active_energy_1 + active_energy_2 + active_energy_3); \n    sum_of_frequency      =   (frequency_1 + frequency_2 + frequency_3);\n    sum_of_power_factor   =   (power_factor_1 + power_factor_2 + power_factor_3); \n    \n    Serial.print(\"SUM of VOLTAGE:           \");   Serial.println(sum_of_voltage);             // V\n    Serial.print(\"SUM of CURRENT_USAGE:     \");   Serial.println(sum_of_current, 3);          // A\n    Serial.print(\"SUM of ACTIVE_POWER:      \");   Serial.println(sum_of_power);               // W\n    Serial.print(\"SUM of ACTIVE_ENERGY:     \");   Serial.println(sum_of_active_energy, 3);    // kWh\n    Serial.print(\"SUM of FREQUENCY:         \");   Serial.println(sum_of_frequency);           // Hz\n    Serial.print(\"SUM of POWER_FACTOR:      \");   Serial.println(sum_of_power_factor);\n    Serial.println(\"====================================================\");\n      \n    low_voltage_check();\n    high_voltage_check();\n}", "id": 112, "concepts": ["sum of voltage", "current", "power", "energy", "frequency", "power factor", "error handling for invalid data"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 5\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 7\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 8\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 9\n### Snippet\nint main()\r\n{\r\n    int totcas;\r\n    scanf(\"%d\",&totcas);\r\n    while (totcas--)\r\n    {\r\n        gets(s);\r\n        gets(s);\r\n        scanf(\"%d%d%d\",&b,&p,&n);\r\n        res = 0;\r\n        if (b == 0)\r\n        {\r\n            for (int i = 0; s[i] != 0; i++)\r\n                if (s[i]%p == n)\r\n                    res += i+1;\r\n            printf(\"%d\\n\",res);\r\n        }\r\n        else\r\n        {\r\n            long long a = 0,bi = 1,tt,ta;\r\n            mp.clear();\r\n            mp[0] = 1;\r\n            for (int i = 0; s[i] != 0; i++)\r\n            {\r\n                long long inv=getInv(bi);\r\n                a = (a*b+s[i])%p;\r\n                tt = (n-a+p)*inv%p;\r\n                res += mp[tt];\r\n\r\n                //printf(\"%d %d\\n\",i,mp[tt]);\r\n                ta = a*inv%p;\r\n                mp[ta]++;\r\n                bi = bi*b%p;\r\n            }\r\n            printf(\"%d\\n\",res);\r\n        }\r\n    }\r\n    return 0;\r\n}\n\n### Concepts", "fingerprint": null, "seed": "int main()\r\n{\r\n    int totcas;\r\n    scanf(\"%d\",&totcas);\r\n    while (totcas--)\r\n    {\r\n        gets(s);\r\n        gets(s);\r\n        scanf(\"%d%d%d\",&b,&p,&n);\r\n        res = 0;\r\n        if (b == 0)\r\n        {\r\n            for (int i = 0; s[i] != 0; i++)\r\n                if (s[i]%p == n)\r\n                    res += i+1;\r\n            printf(\"%d\\n\",res);\r\n        }\r\n        else\r\n        {\r\n            long long a = 0,bi = 1,tt,ta;\r\n            mp.clear();\r\n            mp[0] = 1;\r\n            for (int i = 0; s[i] != 0; i++)\r\n            {\r\n                long long inv=getInv(bi);\r\n                a = (a*b+s[i])%p;\r\n                tt = (n-a+p)*inv%p;\r\n                res += mp[tt];\r\n\r\n                //printf(\"%d %d\\n\",i,mp[tt]);\r\n                ta = a*inv%p;\r\n                mp[ta]++;\r\n                bi = bi*b%p;\r\n            }\r\n            printf(\"%d\\n\",res);\r\n        }\r\n    }\r\n    return 0;\r\n}", "id": 113, "concepts": ["modulus operation", "hash map for counting", "string processing", "polynomial hash"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 4\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 5\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 6\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 7\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 8\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 9\n### Snippet\nvoid DiscreteMasterProperty__float___ObjInit_2(DiscreteMasterProperty__float* __this, ::app::Uno::UX::Property__float* property, ::app::Fuse::Animations::MixerBase* mixerBase)\n{\n    ::app::Fuse::Animations::MasterProperty__float___ObjInit_1(__this, property, mixerBase);\n}\n\n### Concepts", "fingerprint": null, "seed": "void DiscreteMasterProperty__float___ObjInit_2(DiscreteMasterProperty__float* __this, ::app::Uno::UX::Property__float* property, ::app::Fuse::Animations::MixerBase* mixerBase)\n{\n    ::app::Fuse::Animations::MasterProperty__float___ObjInit_1(__this, property, mixerBase);\n}", "id": 114, "concepts": ["C++ object initialization", "function argument passing", "passing references"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 2\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 3\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 8\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 9\n### Snippet\nvoid Exact_Solution(float *u, int Nx) \n{ \n\t// put the exact solution \n   \tint i, j; \n   \tfloat x, y, h; \n   \th = 1.0/(Nx+1); \n   \tfor(i=0;i<Nx;++i) \n   \t{ \n      \t\tx = (i + 1)*h; \n      \t\tfor(j=0;j<Nx;++j) \n      \t\t{ \n         \t\t//k = j + i*(N-1); \n         \t\ty = (j + 1)*h; \n         \t\tu[Nx*i+j] = sin(M_PI*x)*sin(2*M_PI*y); \n      \t\t} \n   \t} \n}\n\n### Concepts", "fingerprint": null, "seed": "void Exact_Solution(float *u, int Nx) \n{ \n\t// put the exact solution \n   \tint i, j; \n   \tfloat x, y, h; \n   \th = 1.0/(Nx+1); \n   \tfor(i=0;i<Nx;++i) \n   \t{ \n      \t\tx = (i + 1)*h; \n      \t\tfor(j=0;j<Nx;++j) \n      \t\t{ \n         \t\t//k = j + i*(N-1); \n         \t\ty = (j + 1)*h; \n         \t\tu[Nx*i+j] = sin(M_PI*x)*sin(2*M_PI*y); \n      \t\t} \n   \t} \n}", "id": 115, "concepts": ["2-dimensional array indexing", "exact solution calculation for partial differential equation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 3\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 4\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 6\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 7\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 9\n### Snippet\nvoid changeAddress(uint8_t OldslaveAddr, uint8_t NewslaveAddr)                    // Function to change/assign pzem address\n{\n  static uint8_t SlaveParameter = 0x06;\n  static uint16_t registerAddress = 0x0002;                                       // Register address to be changed\n  uint16_t u16CRC = 0xFFFF;\n  u16CRC = crc16_update(u16CRC, OldslaveAddr);\n  u16CRC = crc16_update(u16CRC, SlaveParameter);\n  u16CRC = crc16_update(u16CRC, highByte(registerAddress));\n  u16CRC = crc16_update(u16CRC, lowByte(registerAddress));\n  u16CRC = crc16_update(u16CRC, highByte(NewslaveAddr));\n  u16CRC = crc16_update(u16CRC, lowByte(NewslaveAddr));\n  Serial.println(\"Changing Slave Address\");\n  pzemSerial.write(OldslaveAddr);\n  pzemSerial.write(SlaveParameter);\n  pzemSerial.write(highByte(registerAddress));\n  pzemSerial.write(lowByte(registerAddress));\n  pzemSerial.write(highByte(NewslaveAddr));\n  pzemSerial.write(lowByte(NewslaveAddr));\n  pzemSerial.write(lowByte(u16CRC));\n  pzemSerial.write(highByte(u16CRC));\n  Serial.println(\"Changing Slave Address is done\"); \n  delay(1000);\n}\n\n### Concepts", "fingerprint": null, "seed": "void changeAddress(uint8_t OldslaveAddr, uint8_t NewslaveAddr)                    // Function to change/assign pzem address\n{\n  static uint8_t SlaveParameter = 0x06;\n  static uint16_t registerAddress = 0x0002;                                       // Register address to be changed\n  uint16_t u16CRC = 0xFFFF;\n  u16CRC = crc16_update(u16CRC, OldslaveAddr);\n  u16CRC = crc16_update(u16CRC, SlaveParameter);\n  u16CRC = crc16_update(u16CRC, highByte(registerAddress));\n  u16CRC = crc16_update(u16CRC, lowByte(registerAddress));\n  u16CRC = crc16_update(u16CRC, highByte(NewslaveAddr));\n  u16CRC = crc16_update(u16CRC, lowByte(NewslaveAddr));\n  Serial.println(\"Changing Slave Address\");\n  pzemSerial.write(OldslaveAddr);\n  pzemSerial.write(SlaveParameter);\n  pzemSerial.write(highByte(registerAddress));\n  pzemSerial.write(lowByte(registerAddress));\n  pzemSerial.write(highByte(NewslaveAddr));\n  pzemSerial.write(lowByte(NewslaveAddr));\n  pzemSerial.write(lowByte(u16CRC));\n  pzemSerial.write(highByte(u16CRC));\n  Serial.println(\"Changing Slave Address is done\"); \n  delay(1000);\n}", "id": 116, "concepts": ["modbus protocol", "crc calculation", "serial communication", "address change in modbus"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 2\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 5\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 6\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 9\n### Snippet\nvoid handleUI(ProductManager& manager) {\n    int cmd;\n    std::cout << \"Add Product(1) / View All Products(2) / Exit(3) ? \";\n    std::cin >> cmd;\n\n    switch (cmd) {\n    case ADD_PRODUCT:\n        std::cout << \"Book(1) / MusicCD(2) / ConversationBook(3) ? \";\n        std::cin >> cmd;\n\n        switch (cmd) {\n        case BOOK:\n            manager.addProduct(reinterpret_cast<Product*>(new Book));\n            break;\n\n        case MUSICCD:\n            manager.addProduct(reinterpret_cast<Product*>(new CompactDisc));\n            break;\n\n        case CONVERSATIONBOOK:\n            manager.addProduct(\n                reinterpret_cast<Product*>(new ConversationBook));\n            break;\n\n        default:\n            std::cout << \"Wrong Input..\\n\";\n            exit(0);\n        }\n\n        break;\n\n    case VIEW_ALL_PRODUCTS:\n        manager.show();\n        break;\n\n    case EXIT:\n        exit(0);\n        break;\n\n    default:\n        std::cout << \"Wrong Input..\\n\";\n        exit(0);\n    }\n}\n\n### Concepts", "fingerprint": null, "seed": "void handleUI(ProductManager& manager) {\n    int cmd;\n    std::cout << \"Add Product(1) / View All Products(2) / Exit(3) ? \";\n    std::cin >> cmd;\n\n    switch (cmd) {\n    case ADD_PRODUCT:\n        std::cout << \"Book(1) / MusicCD(2) / ConversationBook(3) ? \";\n        std::cin >> cmd;\n\n        switch (cmd) {\n        case BOOK:\n            manager.addProduct(reinterpret_cast<Product*>(new Book));\n            break;\n\n        case MUSICCD:\n            manager.addProduct(reinterpret_cast<Product*>(new CompactDisc));\n            break;\n\n        case CONVERSATIONBOOK:\n            manager.addProduct(\n                reinterpret_cast<Product*>(new ConversationBook));\n            break;\n\n        default:\n            std::cout << \"Wrong Input..\\n\";\n            exit(0);\n        }\n\n        break;\n\n    case VIEW_ALL_PRODUCTS:\n        manager.show();\n        break;\n\n    case EXIT:\n        exit(0);\n        break;\n\n    default:\n        std::cout << \"Wrong Input..\\n\";\n        exit(0);\n    }\n}", "id": 117, "concepts": ["nested switch statement for product management", "dynamic dispatch for polymorphic behavior", "early exit for error handling"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 3\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 5\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 8\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 9\n### Snippet\nvoid occupy_room() {\n  if (!NORELAY)\n        digitalWrite(relay, HIGH); // active high\n    occupied = true; \n    if (!mute_buzzer)\n        T.pulse (buzzer, 200, HIGH); // active low  // 100\n    // the end state is HIGH, i.e, buzzer is off *\n    send_status(); \n}\n\n### Concepts", "fingerprint": null, "seed": "void occupy_room() {\n  if (!NORELAY)\n        digitalWrite(relay, HIGH); // active high\n    occupied = true; \n    if (!mute_buzzer)\n        T.pulse (buzzer, 200, HIGH); // active low  // 100\n    // the end state is HIGH, i.e, buzzer is off *\n    send_status(); \n}", "id": 118, "concepts": ["conditional control of relay and buzzer", "mute option for buzzer", "sending status after occupancy"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 2\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 5\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 9\n### Snippet\nvoid avg_pool(const T* arg,\n              T* out,\n              const Shape& arg_shape,\n              const Shape& out_shape,\n              const Shape& window_shape,\n              const Strides& window_movement_strides,\n              const Shape& padding_below,\n              const Shape& padding_above,\n              bool include_padding_in_avg_computation) {\n    NGRAPH_SUPPRESS_DEPRECATED_START\n    auto old_mode = std::fegetround();\n    std::fesetround(FE_TONEAREST);\n    // At the outermost level we will walk over every output coordinate O.\n    CoordinateTransform output_transform(out_shape);\n\n    for (const Coordinate& out_coord : output_transform) {\n        // Our output coordinate O will have the form:\n        //\n        //   (N,chan,i_1,...,i_n)\n\n        size_t batch_index = out_coord[0];\n        size_t channel = out_coord[1];\n\n        // For the input data we need to iterate the coordinate:\n        //\n        //   I:\n        //\n        // over the range (noninclusive on the right):\n        //\n        //   (N,chan,s_1*i_1,s_2*i_2,...,s_n*i_n) ->\n        //\n        //     (N+1,chan+1,s_1*i_1 + window_shape_1,...,s_n*i_n + window_shape_n)\n        //\n        // with unit stride.\n        //\n        // We iterate this over the *padded* data, so below we will need to check for\n        // coordinates that fall in the padding area.\n\n        size_t n_spatial_dimensions = arg_shape.size() - 2;\n\n        Coordinate input_batch_transform_start(2 + n_spatial_dimensions);\n        Coordinate input_batch_transform_end(2 + n_spatial_dimensions);\n        Strides input_batch_transform_source_strides(2 + n_spatial_dimensions, 1);\n        AxisVector input_batch_transform_source_axis_order(2 + n_spatial_dimensions);\n        CoordinateDiff input_batch_transform_padding_below(2 + n_spatial_dimensions);\n        CoordinateDiff input_batch_transform_padding_above(2 + n_spatial_dimensions);\n\n        input_batch_transform_start[0] = batch_index;\n        input_batch_transform_end[0] = batch_index + 1;\n        input_batch_transform_start[1] = channel;\n        input_batch_transform_end[1] = channel + 1;\n        input_batch_transform_padding_below[0] = 0;\n        input_batch_transform_padding_below[1] = 0;\n        input_batch_transform_padding_above[0] = 0;\n        input_batch_transform_padding_above[1] = 0;\n\n        for (size_t i = 2; i < n_spatial_dimensions + 2; i++) {\n            size_t window_shape_this_dim = window_shape[i - 2];\n            size_t movement_stride = window_movement_strides[i - 2];\n\n            input_batch_transform_start[i] = movement_stride * out_coord[i];\n            input_batch_transform_end[i] = input_batch_transform_start[i] + window_shape_this_dim;\n            input_batch_transform_padding_below[i] = padding_below[i - 2];\n            input_batch_transform_padding_above[i] = padding_above[i - 2];\n            // If a window (kernel) is out of arg shape bounds, trim it to fit\n            auto padded_upper_bound = arg_shape[i] + padding_below[i - 2] + padding_above[i - 2];\n            if (input_batch_transform_end[i] > padded_upper_bound) {\n                input_batch_transform_end[i] = padded_upper_bound;\n            }\n        }\n\n        for (size_t i = 0; i < arg_shape.size(); i++) {\n            input_batch_transform_source_axis_order[i] = i;\n        }\n\n        CoordinateTransform input_batch_transform(arg_shape,\n                                                  input_batch_transform_start,\n                                                  input_batch_transform_end,\n                                                  input_batch_transform_source_strides,\n                                                  input_batch_transform_source_axis_order,\n                                                  input_batch_transform_padding_below,\n                                                  input_batch_transform_padding_above);\n\n        // As we go, we compute the sum value:\n        //\n        //   output[O] := output[O] + arg[I]\n        //\n        // and the number of elements:\n        //\n        //   n_elements := n_elements + 1\n\n        T result = 0;\n        size_t n_elements = 0;\n\n        // The below conditions are to provide conformance between the ref and plugins:\n        // If exclude_padding is disabled (include_padding... enabled), then:\n        // The size of window doesn't change even if the window was clipped to fit the\n        // input, number of elements will be equal to window_size.width *\n        // window_size.height. The exception from this rule is if padding is not\n        // present, then window size is calculated each time.\n\n        auto padding_present =\n            padding_below[0] != 0 || padding_below[1] != 0 || padding_above[0] != 0 || padding_above[1] != 0;\n\n        if (include_padding_in_avg_computation && padding_present) {\n            n_elements = shape_size(window_shape);\n        }\n        for (const Coordinate& input_batch_coord : input_batch_transform) {\n            bool in_bounds = input_batch_transform.has_source_coordinate(input_batch_coord);\n\n            if (in_bounds || include_padding_in_avg_computation) {\n                T v = in_bounds ? arg[input_batch_transform.index(input_batch_coord)] : static_cast<T>(0);\n                result += v;\n                if (!padding_present || (in_bounds && !include_padding_in_avg_computation)) {\n                    n_elements++;\n                }\n            }\n        }\n\n        if (n_elements != 0) {\n            if (std::is_same<T, int8_t>::value || std::is_same<T, uint8_t>::value) {\n                out[output_transform.index(out_coord)] =\n                    static_cast<T>(std::nearbyint(static_cast<float>(result) / n_elements));\n            } else {\n                out[output_transform.index(out_coord)] = result / static_cast<T>(n_elements);\n            }\n        } else {\n            out[output_transform.index(out_coord)] = T{0};\n        }\n\n        std::fesetround(old_mode);\n    }\n    NGRAPH_SUPPRESS_DEPRECATED_END\n}\n\n### Concepts", "fingerprint": null, "seed": "void avg_pool(const T* arg,\n              T* out,\n              const Shape& arg_shape,\n              const Shape& out_shape,\n              const Shape& window_shape,\n              const Strides& window_movement_strides,\n              const Shape& padding_below,\n              const Shape& padding_above,\n              bool include_padding_in_avg_computation) {\n    NGRAPH_SUPPRESS_DEPRECATED_START\n    auto old_mode = std::fegetround();\n    std::fesetround(FE_TONEAREST);\n    // At the outermost level we will walk over every output coordinate O.\n    CoordinateTransform output_transform(out_shape);\n\n    for (const Coordinate& out_coord : output_transform) {\n        // Our output coordinate O will have the form:\n        //\n        //   (N,chan,i_1,...,i_n)\n\n        size_t batch_index = out_coord[0];\n        size_t channel = out_coord[1];\n\n        // For the input data we need to iterate the coordinate:\n        //\n        //   I:\n        //\n        // over the range (noninclusive on the right):\n        //\n        //   (N,chan,s_1*i_1,s_2*i_2,...,s_n*i_n) ->\n        //\n        //     (N+1,chan+1,s_1*i_1 + window_shape_1,...,s_n*i_n + window_shape_n)\n        //\n        // with unit stride.\n        //\n        // We iterate this over the *padded* data, so below we will need to check for\n        // coordinates that fall in the padding area.\n\n        size_t n_spatial_dimensions = arg_shape.size() - 2;\n\n        Coordinate input_batch_transform_start(2 + n_spatial_dimensions);\n        Coordinate input_batch_transform_end(2 + n_spatial_dimensions);\n        Strides input_batch_transform_source_strides(2 + n_spatial_dimensions, 1);\n        AxisVector input_batch_transform_source_axis_order(2 + n_spatial_dimensions);\n        CoordinateDiff input_batch_transform_padding_below(2 + n_spatial_dimensions);\n        CoordinateDiff input_batch_transform_padding_above(2 + n_spatial_dimensions);\n\n        input_batch_transform_start[0] = batch_index;\n        input_batch_transform_end[0] = batch_index + 1;\n        input_batch_transform_start[1] = channel;\n        input_batch_transform_end[1] = channel + 1;\n        input_batch_transform_padding_below[0] = 0;\n        input_batch_transform_padding_below[1] = 0;\n        input_batch_transform_padding_above[0] = 0;\n        input_batch_transform_padding_above[1] = 0;\n\n        for (size_t i = 2; i < n_spatial_dimensions + 2; i++) {\n            size_t window_shape_this_dim = window_shape[i - 2];\n            size_t movement_stride = window_movement_strides[i - 2];\n\n            input_batch_transform_start[i] = movement_stride * out_coord[i];\n            input_batch_transform_end[i] = input_batch_transform_start[i] + window_shape_this_dim;\n            input_batch_transform_padding_below[i] = padding_below[i - 2];\n            input_batch_transform_padding_above[i] = padding_above[i - 2];\n            // If a window (kernel) is out of arg shape bounds, trim it to fit\n            auto padded_upper_bound = arg_shape[i] + padding_below[i - 2] + padding_above[i - 2];\n            if (input_batch_transform_end[i] > padded_upper_bound) {\n                input_batch_transform_end[i] = padded_upper_bound;\n            }\n        }\n\n        for (size_t i = 0; i < arg_shape.size(); i++) {\n            input_batch_transform_source_axis_order[i] = i;\n        }\n\n        CoordinateTransform input_batch_transform(arg_shape,\n                                                  input_batch_transform_start,\n                                                  input_batch_transform_end,\n                                                  input_batch_transform_source_strides,\n                                                  input_batch_transform_source_axis_order,\n                                                  input_batch_transform_padding_below,\n                                                  input_batch_transform_padding_above);\n\n        // As we go, we compute the sum value:\n        //\n        //   output[O] := output[O] + arg[I]\n        //\n        // and the number of elements:\n        //\n        //   n_elements := n_elements + 1\n\n        T result = 0;\n        size_t n_elements = 0;\n\n        // The below conditions are to provide conformance between the ref and plugins:\n        // If exclude_padding is disabled (include_padding... enabled), then:\n        // The size of window doesn't change even if the window was clipped to fit the\n        // input, number of elements will be equal to window_size.width *\n        // window_size.height. The exception from this rule is if padding is not\n        // present, then window size is calculated each time.\n\n        auto padding_present =\n            padding_below[0] != 0 || padding_below[1] != 0 || padding_above[0] != 0 || padding_above[1] != 0;\n\n        if (include_padding_in_avg_computation && padding_present) {\n            n_elements = shape_size(window_shape);\n        }\n        for (const Coordinate& input_batch_coord : input_batch_transform) {\n            bool in_bounds = input_batch_transform.has_source_coordinate(input_batch_coord);\n\n            if (in_bounds || include_padding_in_avg_computation) {\n                T v = in_bounds ? arg[input_batch_transform.index(input_batch_coord)] : static_cast<T>(0);\n                result += v;\n                if (!padding_present || (in_bounds && !include_padding_in_avg_computation)) {\n                    n_elements++;\n                }\n            }\n        }\n\n        if (n_elements != 0) {\n            if (std::is_same<T, int8_t>::value || std::is_same<T, uint8_t>::value) {\n                out[output_transform.index(out_coord)] =\n                    static_cast<T>(std::nearbyint(static_cast<float>(result) / n_elements));\n            } else {\n                out[output_transform.index(out_coord)] = result / static_cast<T>(n_elements);\n            }\n        } else {\n            out[output_transform.index(out_coord)] = T{0};\n        }\n\n        std::fesetround(old_mode);\n    }\n    NGRAPH_SUPPRESS_DEPRECATED_END\n}", "id": 119, "concepts": ["tensor indexing and slicing", "padding handling", "edge cases management", "rounding operations"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 4\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 5\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 6\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 7\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 8\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 9\n### Snippet\nint main() {\n    assert(test(1024) == 0);\n\n    std::vector<int> test_sizes = {{ 64, 128, 256, 512, 1024, 2048, 4096 }};\n\n    for (auto size: test_sizes) {\n        std::vector<double> A(size * size, 0.0);\n\n        A[0] =  2.0;\n        A[1] = -1.0;\n        for (size_t i = 1; i < size - 1; ++i) {\n            A[i * size + i - 1] = -1.0;\n            A[i * size + i    ] =  2.0;\n            A[i * size + i + 1] = -1.0;\n        }\n        A[size * size - 2] = -1.0;\n        A[size * size - 1] =  2.0;\n\n        double *d_A;\n        cudaError_t cudaErr;\n        cudaErr = cudaMalloc(&d_A, A.size() * sizeof(double));\n        assert(cudaErr == cudaSuccess);\n\n        cudaErr = cudaMemcpy(d_A, A.data(), A.size() * sizeof(double), cudaMemcpyHostToDevice);\n        assert(cudaErr == cudaSuccess);\n\n        int    *d_row, *d_col;\n        double *d_val;\n        full_to_csr(size, size, d_A, size, &d_row, &d_col, &d_val);\n\n        cudaFree(d_A);\n        cudaFree(d_row);\n        cudaFree(d_col);\n        cudaFree(d_val);\n    }\n\n    return 0;\n}\n\n### Concepts", "fingerprint": null, "seed": "int main() {\n    assert(test(1024) == 0);\n\n    std::vector<int> test_sizes = {{ 64, 128, 256, 512, 1024, 2048, 4096 }};\n\n    for (auto size: test_sizes) {\n        std::vector<double> A(size * size, 0.0);\n\n        A[0] =  2.0;\n        A[1] = -1.0;\n        for (size_t i = 1; i < size - 1; ++i) {\n            A[i * size + i - 1] = -1.0;\n            A[i * size + i    ] =  2.0;\n            A[i * size + i + 1] = -1.0;\n        }\n        A[size * size - 2] = -1.0;\n        A[size * size - 1] =  2.0;\n\n        double *d_A;\n        cudaError_t cudaErr;\n        cudaErr = cudaMalloc(&d_A, A.size() * sizeof(double));\n        assert(cudaErr == cudaSuccess);\n\n        cudaErr = cudaMemcpy(d_A, A.data(), A.size() * sizeof(double), cudaMemcpyHostToDevice);\n        assert(cudaErr == cudaSuccess);\n\n        int    *d_row, *d_col;\n        double *d_val;\n        full_to_csr(size, size, d_A, size, &d_row, &d_col, &d_val);\n\n        cudaFree(d_A);\n        cudaFree(d_row);\n        cudaFree(d_col);\n        cudaFree(d_val);\n    }\n\n    return 0;\n}", "id": 120, "concepts": ["unit testing", "matrix allocation and initialization", "CUDA error handling", "memory management"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 2\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 3\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 4\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 8\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 9\n### Snippet\nint editDistance(string s1,string s2,int m,int n)\n{\n         \n   int dp[m+1][n+1];\n   memset(dp,0,sizeof dp);\n   for(int i=0;i<=m;i++)\n   {\n       for(int j=0;j<=n;j++)\n       {\n           if(i==0)\n           dp[i][j]=j;\n           else if(j==0)\n           dp[i][j]=i;\n           else if(s1[i-1]==s2[j-1])\n           {\n                 dp[i][j]=dp[i-1][j-1];\n           }\n              \n           else{\n               dp[i][j]=1+min(min(dp[i][j-1],dp[i-1][j]),dp[i-1][j-1]);\n           }\n       }\n   }\n   \n   for(int i=0;i<=m;i++)\n   {\n       for(int j=0;j<=n;j++)\n       {  \n           cout<<dp[i][j]<<\" \";\n       }\n       cout<<endl;\n   }\n   \n   \n   return dp[m][n];\n    \n   \n}\n\n### Concepts", "fingerprint": null, "seed": "int editDistance(string s1,string s2,int m,int n)\n{\n         \n   int dp[m+1][n+1];\n   memset(dp,0,sizeof dp);\n   for(int i=0;i<=m;i++)\n   {\n       for(int j=0;j<=n;j++)\n       {\n           if(i==0)\n           dp[i][j]=j;\n           else if(j==0)\n           dp[i][j]=i;\n           else if(s1[i-1]==s2[j-1])\n           {\n                 dp[i][j]=dp[i-1][j-1];\n           }\n              \n           else{\n               dp[i][j]=1+min(min(dp[i][j-1],dp[i-1][j]),dp[i-1][j-1]);\n           }\n       }\n   }\n   \n   for(int i=0;i<=m;i++)\n   {\n       for(int j=0;j<=n;j++)\n       {  \n           cout<<dp[i][j]<<\" \";\n       }\n       cout<<endl;\n   }\n   \n   \n   return dp[m][n];\n    \n   \n}", "id": 121, "concepts": ["dynamic programming", "edit distance calculation", "minimum edit operations"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 4\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 7\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 8\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 9\n### Snippet\nvoid defineFunction(MincBlockExpr* scope, const char* name, PawsType* returnType, std::vector<PawsType*> argTypes, std::vector<std::string> argNames, MincBlockExpr* body)\n{\n\tPawsFunc* pawsFunc = new PawsRegularFunc(name, returnType, argTypes, argNames, body);\n\tscope->defineSymbol(name, PawsFunctionType::get(pawsSubroutineScope, returnType, argTypes), new PawsFunction(pawsFunc));\n}\n\n### Concepts", "fingerprint": null, "seed": "void defineFunction(MincBlockExpr* scope, const char* name, PawsType* returnType, std::vector<PawsType*> argTypes, std::vector<std::string> argNames, MincBlockExpr* body)\n{\n\tPawsFunc* pawsFunc = new PawsRegularFunc(name, returnType, argTypes, argNames, body);\n\tscope->defineSymbol(name, PawsFunctionType::get(pawsSubroutineScope, returnType, argTypes), new PawsFunction(pawsFunc));\n}", "id": 122, "concepts": ["function definition", "function signature", "variable declaration", "control flow"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 4\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 5\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 7\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 9\n### Snippet\nuint8_t CDC_Transmit_FS(uint8_t* Buf, uint16_t Len)\r\n{\r\n    uint8_t result = USBD_OK;\r\n    /* USER CODE BEGIN 7 */\r\n    USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef*) hUsbDeviceFS.pClassData;\r\n    if (hcdc->TxState != 0)\r\n    {\r\n        return USBD_BUSY;\r\n    }\r\n    USBD_CDC_SetTxBuffer(&hUsbDeviceFS, Buf, Len);\r\n    result = USBD_CDC_TransmitPacket(&hUsbDeviceFS);\r\n    /* USER CODE END 7 */\r\n    return result;\r\n}\n\n### Concepts", "fingerprint": null, "seed": "uint8_t CDC_Transmit_FS(uint8_t* Buf, uint16_t Len)\r\n{\r\n    uint8_t result = USBD_OK;\r\n    /* USER CODE BEGIN 7 */\r\n    USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef*) hUsbDeviceFS.pClassData;\r\n    if (hcdc->TxState != 0)\r\n    {\r\n        return USBD_BUSY;\r\n    }\r\n    USBD_CDC_SetTxBuffer(&hUsbDeviceFS, Buf, Len);\r\n    result = USBD_CDC_TransmitPacket(&hUsbDeviceFS);\r\n    /* USER CODE END 7 */\r\n    return result;\r\n}", "id": 123, "concepts": ["bit manipulation for USB device status checks", "type casting for struct field access", "function pointer calls"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 3\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 4\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 5\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 6\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 8\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 9\n### Snippet\nvoid\r\nOLD_ClientUnregister (\r\n\tHANDLE hDevice\r\n\t)\r\n{\r\n\tHDSTATE Activity;\r\n\r\n\tActivity.Activity = _AS_Unload;\r\n\tActivity.AppID = InstallerProtection;\r\n\r\n\tDWORD dwRet;\r\n\r\n\tDeviceIoControl (\r\n\t\thDevice,\r\n\t\tIOCTLHOOK_Activity,\r\n\t\t&Activity,\r\n\t\tsizeof(Activity),\r\n\t\t&Activity,\r\n\t\tsizeof(Activity),\r\n\t\t&dwRet,\r\n\t\tNULL\r\n\t\t);\r\n}\n\n### Concepts", "fingerprint": null, "seed": "void\r\nOLD_ClientUnregister (\r\n\tHANDLE hDevice\r\n\t)\r\n{\r\n\tHDSTATE Activity;\r\n\r\n\tActivity.Activity = _AS_Unload;\r\n\tActivity.AppID = InstallerProtection;\r\n\r\n\tDWORD dwRet;\r\n\r\n\tDeviceIoControl (\r\n\t\thDevice,\r\n\t\tIOCTLHOOK_Activity,\r\n\t\t&Activity,\r\n\t\tsizeof(Activity),\r\n\t\t&Activity,\r\n\t\tsizeof(Activity),\r\n\t\t&dwRet,\r\n\t\tNULL\r\n\t\t);\r\n}", "id": 124, "concepts": ["IOCTLHOOK_Activity IOCTL call", "_AS_Unload activity", "InstallerProtection AppID"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 2\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 3\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 5\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 6\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 7\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 9\n### Snippet\nint\ngetBufferInt(cstring charBuffer)\n{\n    return atoi(charBuffer);\n}\n\n### Concepts", "fingerprint": null, "seed": "int\ngetBufferInt(cstring charBuffer)\n{\n    return atoi(charBuffer);\n}", "id": 125, "concepts": ["string conversion to integer", "handling null characters", "potential buffer overflow"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 3\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 5\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 8\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 9\n### Snippet\nvoid _stdcall SubCureTrace(tag_TRACE_LEVEL dTraceLevel,char* chMask)\r\n{\r\n\t//INT3;\r\n\tPR_TRACE((g_root,dTraceLevel,chMask));\r\n\treturn;\r\n}\n\n### Concepts", "fingerprint": null, "seed": "void _stdcall SubCureTrace(tag_TRACE_LEVEL dTraceLevel,char* chMask)\r\n{\r\n\t//INT3;\r\n\tPR_TRACE((g_root,dTraceLevel,chMask));\r\n\treturn;\r\n}", "id": 126, "concepts": ["function call convention", "macro expansion", "string interpolation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 4\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 5\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 6\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 9\n### Snippet\nvoid measureAndCalculateRMS() {\n  double sum = 0, sum2 = 0;\n\n  int delayBetweenMeasures = 1;\n  int measureCount = 2000;\n  \n  for(int i = 0; i < measureCount; i++) {\n    //sensor 1\n    double rawValue = analogRead(SENSOR_INPUT_FRONT) - 500;      //sensor nr.: 515\n    sum += rawValue * rawValue;\n\n    //sensor 2\n    double rawValue2 = analogRead(SENSOR_INPUT_BACK) - 500;   //sensor nr.: 510.5\n    sum2 += rawValue2 * rawValue2;\n\n    delay(delayBetweenMeasures);\n  }\n  \n  rmsFrontSensor = rootMeanSquare(sum, measureCount);\n  rmsBackSensor = rootMeanSquare(sum2, measureCount);\n}\n\n### Concepts", "fingerprint": null, "seed": "void measureAndCalculateRMS() {\n  double sum = 0, sum2 = 0;\n\n  int delayBetweenMeasures = 1;\n  int measureCount = 2000;\n  \n  for(int i = 0; i < measureCount; i++) {\n    //sensor 1\n    double rawValue = analogRead(SENSOR_INPUT_FRONT) - 500;      //sensor nr.: 515\n    sum += rawValue * rawValue;\n\n    //sensor 2\n    double rawValue2 = analogRead(SENSOR_INPUT_BACK) - 500;   //sensor nr.: 510.5\n    sum2 += rawValue2 * rawValue2;\n\n    delay(delayBetweenMeasures);\n  }\n  \n  rmsFrontSensor = rootMeanSquare(sum, measureCount);\n  rmsBackSensor = rootMeanSquare(sum2, measureCount);\n}", "id": 127, "concepts": ["sensor data processing", "data averaging", "root mean square calculation", "error handling"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 3\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 4\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 7\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 9\n### Snippet\nvoid calc_set_var(const char *s, int val)\n{\n\tcalc_var_map[s] = val;\n\n\tstd::cout << val << std::endl;\n}\n\n### Concepts", "fingerprint": null, "seed": "void calc_set_var(const char *s, int val)\n{\n\tcalc_var_map[s] = val;\n\n\tstd::cout << val << std::endl;\n}", "id": 128, "concepts": ["C++ map data structure", "function parameter handling", "input parsing"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 3\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 5\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 8\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 9\n### Snippet\nint compare(char* string1, char* string2) \n{\n    int i = 0;\n    while(string1[i] != '\\0' && string2[i] != '\\0') {\n        if(string1[i] != string2[i]) {\n            if(string1[i] < string2[i]) {\n                return 1;\n            } else {\n                return -1;\n            }\n        }\n        i++;\n    }\n    return 0; //0 for equal\n}\n\n### Concepts", "fingerprint": null, "seed": "int compare(char* string1, char* string2) \n{\n    int i = 0;\n    while(string1[i] != '\\0' && string2[i] != '\\0') {\n        if(string1[i] != string2[i]) {\n            if(string1[i] < string2[i]) {\n                return 1;\n            } else {\n                return -1;\n            }\n        }\n        i++;\n    }\n    return 0; //0 for equal\n}", "id": 129, "concepts": ["string comparison", "character comparison", "loop termination condition"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 4\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 5\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 7\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 9\n### Snippet\nvoid get_pzem_data()                                          // Function to check time to see if it reached mentioned time to fetch PZEM data\n{\n    pzemdevice1(); \n    pzemdevice2();\n    pzemdevice3();\n    sumofpzem();\n}\n\n### Concepts", "fingerprint": null, "seed": "void get_pzem_data()                                          // Function to check time to see if it reached mentioned time to fetch PZEM data\n{\n    pzemdevice1(); \n    pzemdevice2();\n    pzemdevice3();\n    sumofpzem();\n}", "id": 130, "concepts": ["function declaration and definition", "modular code for maintainability"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 2\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 4\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 6\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 9\n### Snippet\nint findMaxFlow(adjmattype graph, int s, int t, adjmattype &fGraphvect, vector<int> parentorig)\r\n{\r\n    int u, v;\r\n\tif (-1 == s|| -1 == t)\r\n\t\treturn 0;\r\n    // Create a residual graph and fill the residual graph with\r\n    // given capacities in the original graph as residual capacities\r\n    // in residual graph\r\n   \tadjmattype  rGraph(graph.begin(),graph.end());\r\n\tint parent[V];  // This array is filled by BFS and to store path\r\n\tvector<int> path;\r\n    int max_flow = 0;  // There is no flow initially\r\n \r\n    // Augment the flow while tere is path from source to sink\r\n    while (bfs(rGraph, s, t, parent, path))\r\n    {\r\n        // Find minimum residual capacity of the edges along the\r\n        // path filled by BFS. Or we can say find the maximum flow\r\n        // through the path found.\r\n        int path_flow = INT_MAX;\r\n \r\n        for (v=t; v!=s; v=parent[v])\r\n        {\r\n            u = parent[v];\r\n            path_flow = min(path_flow, rGraph[u][v]);\r\n        }\r\n \r\n        // update residual capacities of the edges and reverse edges\r\n        // along the path\r\n        for (v=t; v != s; v=parent[v])\r\n        {\r\n            u = parent[v];\r\n            rGraph[u][v] -= path_flow;\r\n            rGraph[v][u] += path_flow;\r\n        }\r\n \r\n        // Add path flow to overall flow\r\n        max_flow += path_flow;\r\n    }\r\n \r\n\t\r\n\t//Calculate the flows on each edge - subtracting residual from capacity, aka. residual capacity current flow on each edge\r\n\tfor( int i = 0; i < V; ++i)\r\n\t{\r\n\t\tfor( int j = 0; j < V; ++j )\r\n\t\t{\r\n\t\t\tfGraphvect[i][j] =  graph[i][j] - rGraph[i][j];\r\n\r\n\t\t}\r\n\r\n\t}\r\n    // Return the overall flow (max_flow is equal to maximum\r\n    // number of edge-disjoint paths)\r\n    return max_flow;\r\n}\n\n### Concepts", "fingerprint": null, "seed": "int findMaxFlow(adjmattype graph, int s, int t, adjmattype &fGraphvect, vector<int> parentorig)\r\n{\r\n    int u, v;\r\n\tif (-1 == s|| -1 == t)\r\n\t\treturn 0;\r\n    // Create a residual graph and fill the residual graph with\r\n    // given capacities in the original graph as residual capacities\r\n    // in residual graph\r\n   \tadjmattype  rGraph(graph.begin(),graph.end());\r\n\tint parent[V];  // This array is filled by BFS and to store path\r\n\tvector<int> path;\r\n    int max_flow = 0;  // There is no flow initially\r\n \r\n    // Augment the flow while tere is path from source to sink\r\n    while (bfs(rGraph, s, t, parent, path))\r\n    {\r\n        // Find minimum residual capacity of the edges along the\r\n        // path filled by BFS. Or we can say find the maximum flow\r\n        // through the path found.\r\n        int path_flow = INT_MAX;\r\n \r\n        for (v=t; v!=s; v=parent[v])\r\n        {\r\n            u = parent[v];\r\n            path_flow = min(path_flow, rGraph[u][v]);\r\n        }\r\n \r\n        // update residual capacities of the edges and reverse edges\r\n        // along the path\r\n        for (v=t; v != s; v=parent[v])\r\n        {\r\n            u = parent[v];\r\n            rGraph[u][v] -= path_flow;\r\n            rGraph[v][u] += path_flow;\r\n        }\r\n \r\n        // Add path flow to overall flow\r\n        max_flow += path_flow;\r\n    }\r\n \r\n\t\r\n\t//Calculate the flows on each edge - subtracting residual from capacity, aka. residual capacity current flow on each edge\r\n\tfor( int i = 0; i < V; ++i)\r\n\t{\r\n\t\tfor( int j = 0; j < V; ++j )\r\n\t\t{\r\n\t\t\tfGraphvect[i][j] =  graph[i][j] - rGraph[i][j];\r\n\r\n\t\t}\r\n\r\n\t}\r\n    // Return the overall flow (max_flow is equal to maximum\r\n    // number of edge-disjoint paths)\r\n    return max_flow;\r\n}", "id": 131, "concepts": ["graph data structure", "breadth-first search", "residual graph"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 3\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 4\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 5\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 7\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 9\n### Snippet\nvoid read_json_config()\r\n{\r\n\r\n\tstd::string json = get_file_contents(config_file.c_str());\r\n\trapidjson::Document d;\r\n\td.Parse<0>(json.c_str());\r\n\r\n\toutput_file = d[\"output_file\"].GetString();\r\n\tcrop_width = d[\"height\"].GetInt();\r\n\tcrop_height = d[\"width\"].GetInt();\r\n\tscale = d[\"scale\"].GetInt();\r\n\tseed = d[\"seed\"].GetInt();\r\n\trandom_offset = d[\"offset\"].GetInt();\r\n\toffset_dr = d[\"rough\"].GetDouble();\r\n\tnormalise = (strcmp(d[\"normalise\"].GetString(), \"true\") == 0);\r\n\tnormalise_min = d[\"normalise_min\"].GetInt();\r\n\tnormalise_max = d[\"normalise_max\"].GetInt();\r\n\tsea_level = d[\"sea_level\"].GetInt();\r\n\tsand_level = d[\"sand_level\"].GetInt();\r\n\tsnow_level = d[\"snow_level\"].GetInt();\r\n\tcliff_difference = d[\"cliff_height_difference\"].GetInt();\r\n\tn_rivers = d[\"number_of_river_sources\"].GetInt();\r\n\tmax_branches = d[\"max_branches_per_source\"].GetInt();\r\n\tn_settlements = d[\"number_of_settlements\"].GetInt();\r\n\tmin_distance = d[\"min_distance_between_settlements\"].GetInt();\r\n\tn_vegetation = d[\"number_of_vegetation\"].GetInt();\r\n\troot_radius = d[\"vegetation_root_radius\"].GetInt();\r\n\tgenerations = d[\"vegetation_generations\"].GetInt();\r\n\r\n}\n\n### Concepts", "fingerprint": null, "seed": "void read_json_config()\r\n{\r\n\r\n\tstd::string json = get_file_contents(config_file.c_str());\r\n\trapidjson::Document d;\r\n\td.Parse<0>(json.c_str());\r\n\r\n\toutput_file = d[\"output_file\"].GetString();\r\n\tcrop_width = d[\"height\"].GetInt();\r\n\tcrop_height = d[\"width\"].GetInt();\r\n\tscale = d[\"scale\"].GetInt();\r\n\tseed = d[\"seed\"].GetInt();\r\n\trandom_offset = d[\"offset\"].GetInt();\r\n\toffset_dr = d[\"rough\"].GetDouble();\r\n\tnormalise = (strcmp(d[\"normalise\"].GetString(), \"true\") == 0);\r\n\tnormalise_min = d[\"normalise_min\"].GetInt();\r\n\tnormalise_max = d[\"normalise_max\"].GetInt();\r\n\tsea_level = d[\"sea_level\"].GetInt();\r\n\tsand_level = d[\"sand_level\"].GetInt();\r\n\tsnow_level = d[\"snow_level\"].GetInt();\r\n\tcliff_difference = d[\"cliff_height_difference\"].GetInt();\r\n\tn_rivers = d[\"number_of_river_sources\"].GetInt();\r\n\tmax_branches = d[\"max_branches_per_source\"].GetInt();\r\n\tn_settlements = d[\"number_of_settlements\"].GetInt();\r\n\tmin_distance = d[\"min_distance_between_settlements\"].GetInt();\r\n\tn_vegetation = d[\"number_of_vegetation\"].GetInt();\r\n\troot_radius = d[\"vegetation_root_radius\"].GetInt();\r\n\tgenerations = d[\"vegetation_generations\"].GetInt();\r\n\r\n}", "id": 132, "concepts": ["file parsing", "JSON parsing", "string comparison", "data type conversion"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 4\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 6\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 9\n### Snippet\nint main()\n{\n    ll t;\n    cin>>t;\n    while(t--)\n        solve();\n}\n\n### Concepts", "fingerprint": null, "seed": "int main()\n{\n    ll t;\n    cin>>t;\n    while(t--)\n        solve();\n}", "id": 133, "concepts": ["time complexity analysis", "algorithm optimization", "loop unrolling"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 2\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 6\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 7\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 8\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 9\n### Snippet\nint main(){ \n    c_p_c();\n    int t; t = 1;\n    while(t--){\n        solve();\n    }\n}\n\n### Concepts", "fingerprint": null, "seed": "int main(){ \n    c_p_c();\n    int t; t = 1;\n    while(t--){\n        solve();\n    }\n}", "id": 134, "concepts": ["C++ headers inclusion", "main function definition", "code execution"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 5\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 6\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 7\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 8\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 9\n### Snippet\nvoid loop_FunkCheck()\n{\n  //===== Receiving =====//\n  network.update();\n\n  while (network.available()) // Is there any incoming data?\n  {\n    RF24NetworkHeader header(FunkMasterSwitchcabinet);\n    network.read(header, &dataIncoming, sizeof(dataIncoming)); // Read the incoming data\n\n    if ((header.from_node == FunkMasterSwitchcabinet) and (dataIncoming.header == 1))\n    {\n      //Serial.println(\"Switchcabinet hat was gefunkt\");\n\n      if ((dataIncoming.val1 != TargetTemperatureZone_1) and (NewTargetTempAvalible_Zone1 == false))\n      {\n        TargetTemperatureZone_1 = dataIncoming.val1;\n      }\n      if ((dataIncoming.val2 != TargetTemperatureZone_2) and (NewTargetTempAvalible_Zone2 == false))\n      {\n        TargetTemperatureZone_2 = dataIncoming.val2;\n      }\n      if (dataIncoming.val3 != RealTemperatureZone_1)\n      {\n        RealTemperatureZone_1 = dataIncoming.val3;\n      }\n      if (dataIncoming.val4 != RealTemperatureZone_2)\n      {\n        RealTemperatureZone_2 = dataIncoming.val4;\n      }\n    }\n  }\n}\n\n### Concepts", "fingerprint": null, "seed": "void loop_FunkCheck()\n{\n  //===== Receiving =====//\n  network.update();\n\n  while (network.available()) // Is there any incoming data?\n  {\n    RF24NetworkHeader header(FunkMasterSwitchcabinet);\n    network.read(header, &dataIncoming, sizeof(dataIncoming)); // Read the incoming data\n\n    if ((header.from_node == FunkMasterSwitchcabinet) and (dataIncoming.header == 1))\n    {\n      //Serial.println(\"Switchcabinet hat was gefunkt\");\n\n      if ((dataIncoming.val1 != TargetTemperatureZone_1) and (NewTargetTempAvalible_Zone1 == false))\n      {\n        TargetTemperatureZone_1 = dataIncoming.val1;\n      }\n      if ((dataIncoming.val2 != TargetTemperatureZone_2) and (NewTargetTempAvalible_Zone2 == false))\n      {\n        TargetTemperatureZone_2 = dataIncoming.val2;\n      }\n      if (dataIncoming.val3 != RealTemperatureZone_1)\n      {\n        RealTemperatureZone_1 = dataIncoming.val3;\n      }\n      if (dataIncoming.val4 != RealTemperatureZone_2)\n      {\n        RealTemperatureZone_2 = dataIncoming.val4;\n      }\n    }\n  }\n}", "id": 135, "concepts": ["network communication", "data reception", "data processing", "data validation", "error handling"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 3\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 5\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 6\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 7\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 8\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 9\n### Snippet\nint main()\n{\n\t//// 1. \uc77c\ubc18 \ud568\uc218\uac00 \ud15c\ud50c\ub9bf \ud568\uc218\ubcf4\ub2e4 \uba3c\uc800 \ubd88\ub9ac\uae30 \ub54c\ubb38\uc5d0 void goo(double) = delete; \uac00 \uc788\uc73c\uba74 \uc774 \ubc11\uc5d0\uc11c \uc624\ub958\ub0a8\n\tgoo(3.4);\n\n\n\t//// 2. Mutex\ub294 \ubcf5\uc0ac \uc0dd\uc131\uc790\ub97c \uc0ac\uc6a9\ud560 \uc218 \uc5c6\uc74c. \n\tMutex m1;\n\tMutex m2 = m1; // \ubcf5\uc0ac \uc0dd\uc131\uc790.\n}\n\n### Concepts", "fingerprint": null, "seed": "int main()\n{\n\t//// 1. \uc77c\ubc18 \ud568\uc218\uac00 \ud15c\ud50c\ub9bf \ud568\uc218\ubcf4\ub2e4 \uba3c\uc800 \ubd88\ub9ac\uae30 \ub54c\ubb38\uc5d0 void goo(double) = delete; \uac00 \uc788\uc73c\uba74 \uc774 \ubc11\uc5d0\uc11c \uc624\ub958\ub0a8\n\tgoo(3.4);\n\n\n\t//// 2. Mutex\ub294 \ubcf5\uc0ac \uc0dd\uc131\uc790\ub97c \uc0ac\uc6a9\ud560 \uc218 \uc5c6\uc74c. \n\tMutex m1;\n\tMutex m2 = m1; // \ubcf5\uc0ac \uc0dd\uc131\uc790.\n}", "id": 136, "concepts": ["function overloading", "specialization", "deleted functions", "mutex class"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 2\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 6\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 7\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 8\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 9\n### Snippet\nint main(int argc, char *argv[])\n{\n  //Initialize variables\n    ifstream inFile(argv[1]);\n    Park prk[100];\n    string parkData;\n    string parkName;\n    string parkState;\n    int arrayLength = 0;\n    int parkArea;\n    int minArea;\n\n\n\n\n    if (inFile.is_open())\n    while (!inFile.eof())\n    {\n      getline (inFile, parkData, ',');\n      parkName = parkData;\n      getline (inFile, parkData, ',');\n      parkState = parkData;\n      getline (inFile, parkData, '\\n');\n      stringstream convert(parkData);\n      convert >> parkArea;\n\n      addPark (prk, parkName, parkState, parkArea, arrayLength++);\n    }\n    printList (prk, arrayLength);\n    inFile.close();\n    ofstream outFile(argv[2]);\n\n    stringstream convert2(argv[3]);\n    convert2 >> minArea;\n    for (int j = 0; j < arrayLength; j++)\n    {\n      if (prk[j].area >= minArea)\n      {\n        outFile << prk[j].parkname << \",\" << prk[j].state << \",\" << prk[j].area << endl;\n      }\n    }\n    outFile.close();\n}\n\n### Concepts", "fingerprint": null, "seed": "int main(int argc, char *argv[])\n{\n  //Initialize variables\n    ifstream inFile(argv[1]);\n    Park prk[100];\n    string parkData;\n    string parkName;\n    string parkState;\n    int arrayLength = 0;\n    int parkArea;\n    int minArea;\n\n\n\n\n    if (inFile.is_open())\n    while (!inFile.eof())\n    {\n      getline (inFile, parkData, ',');\n      parkName = parkData;\n      getline (inFile, parkData, ',');\n      parkState = parkData;\n      getline (inFile, parkData, '\\n');\n      stringstream convert(parkData);\n      convert >> parkArea;\n\n      addPark (prk, parkName, parkState, parkArea, arrayLength++);\n    }\n    printList (prk, arrayLength);\n    inFile.close();\n    ofstream outFile(argv[2]);\n\n    stringstream convert2(argv[3]);\n    convert2 >> minArea;\n    for (int j = 0; j < arrayLength; j++)\n    {\n      if (prk[j].area >= minArea)\n      {\n        outFile << prk[j].parkname << \",\" << prk[j].state << \",\" << prk[j].area << endl;\n      }\n    }\n    outFile.close();\n}", "id": 137, "concepts": ["file handling", "string processing", "data structures for storing and accessing data"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 2\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 7\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 9\n### Snippet\nint main ()\n{\n    int TT;\n    scanf(\"%d\", &TT);\n    for (int tt = 1; tt <= TT; tt++) {\n        int R, C, N;\n        scanf(\"%d %d %d\", &R, &C, &N);\n        ULL sol = get_min(R, C, N);\n        printf(\"Case #%d: %llu\\n\", tt, sol);\n    }\n    return 0;\n}\n\n### Concepts", "fingerprint": null, "seed": "int main ()\n{\n    int TT;\n    scanf(\"%d\", &TT);\n    for (int tt = 1; tt <= TT; tt++) {\n        int R, C, N;\n        scanf(\"%d %d %d\", &R, &C, &N);\n        ULL sol = get_min(R, C, N);\n        printf(\"Case #%d: %llu\\n\", tt, sol);\n    }\n    return 0;\n}", "id": 138, "concepts": ["problem solving with greedy algorithm", "dynamic programming", "constant space optimization"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 2\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 3\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 4\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 5\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 9\n### Snippet\nint RolFromXCoord(double xCoord){\n    double xLeft = -374495.83635;\n    double cellSize = 270.0;\n    double result;\n    int retVal;\n    \n    result = (xCoord - xLeft)/cellSize;\n    retVal = result;\n    return retVal;\n}\n\n### Concepts", "fingerprint": null, "seed": "int RolFromXCoord(double xCoord){\n    double xLeft = -374495.83635;\n    double cellSize = 270.0;\n    double result;\n    int retVal;\n    \n    result = (xCoord - xLeft)/cellSize;\n    retVal = result;\n    return retVal;\n}", "id": 139, "concepts": ["pixel coordinate conversion", "geospatial calculation", "data type conversion"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 2\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 4\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 6\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 7\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 9\n### Snippet\ndouble toPounds(int x){\ndouble numPounds = x * lbs;\nreturn numPounds;\n}\n\n### Concepts", "fingerprint": null, "seed": "double toPounds(int x){\ndouble numPounds = x * lbs;\nreturn numPounds;\n}", "id": 140, "concepts": ["unit conversion", "variable naming", "function naming"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 4\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 7\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 9\n### Snippet\nint main()\n{\n\tfreopen(\"path.in\",\"r\",stdin);\n\tfreopen(\"path.ans\",\"w\",stdout);\n\tfac[0]=1;\n\tfor(int i=1;i<N;i++) fac[i]=1ll*fac[i-1]*i%mod;\n\tscanf(\"%d\",&Case);\n\tscanf(\"%d\",&n);\n\tfor(int i=1,u,v,w;i<n;i++) scanf(\"%d%d%d\",&u,&v,&w),add(u,v,w),add(v,u,w);\n\tscanf(\"%d\",&k);\n\tfor(int i=1;i<=k;i++) scanf(\"%d\",&A[i]),mark[A[i]]=1;\n\tdfs(1,0);\n\tprocess();\n\tfor(int i=1;i<=k;i++) f[i]=i;\n\tdo\n\t{\n\t\tint res=0;\n\t\tfor(int i=1;i<k;i++) res=mul(res+askdist(A[f[i]],A[f[i+1]]));\n\t\t//for(int i=1;i<k;i++) printf(\"%d \",askdist(A[f[i]],A[f[i+1]]));\n\t\t//for(int i=1;i<=k;i++) printf(\"%d \",A[f[i]]);\n\t\t//printf(\"%d\\n\",res);\n\t\tans=mul(ans+res);\n\t}while(std::next_permutation(f+1,f+1+k));\n\tprintf(\"%d\\n\",1ll*ans*Pow(fac[k],mod-2)%mod);\n}\n\n### Concepts", "fingerprint": null, "seed": "int main()\n{\n\tfreopen(\"path.in\",\"r\",stdin);\n\tfreopen(\"path.ans\",\"w\",stdout);\n\tfac[0]=1;\n\tfor(int i=1;i<N;i++) fac[i]=1ll*fac[i-1]*i%mod;\n\tscanf(\"%d\",&Case);\n\tscanf(\"%d\",&n);\n\tfor(int i=1,u,v,w;i<n;i++) scanf(\"%d%d%d\",&u,&v,&w),add(u,v,w),add(v,u,w);\n\tscanf(\"%d\",&k);\n\tfor(int i=1;i<=k;i++) scanf(\"%d\",&A[i]),mark[A[i]]=1;\n\tdfs(1,0);\n\tprocess();\n\tfor(int i=1;i<=k;i++) f[i]=i;\n\tdo\n\t{\n\t\tint res=0;\n\t\tfor(int i=1;i<k;i++) res=mul(res+askdist(A[f[i]],A[f[i+1]]));\n\t\t//for(int i=1;i<k;i++) printf(\"%d \",askdist(A[f[i]],A[f[i+1]]));\n\t\t//for(int i=1;i<=k;i++) printf(\"%d \",A[f[i]]);\n\t\t//printf(\"%d\\n\",res);\n\t\tans=mul(ans+res);\n\t}while(std::next_permutation(f+1,f+1+k));\n\tprintf(\"%d\\n\",1ll*ans*Pow(fac[k],mod-2)%mod);\n}", "id": 141, "concepts": ["file I/O redirection", "factorial calculation", "graph traversal", "distance queries", "permutation generation", "dynamic programming"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 2\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 3\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 4\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 7\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 9\n### Snippet\nvoid pfMemFree(hOBJECT hObj,void* Obj)\r\n{\r\n\tif (!Obj) return;\r\n\tCALL_SYS_ObjHeapFree(hObj,Obj);\r\n\treturn;\r\n}\n\n### Concepts", "fingerprint": null, "seed": "void pfMemFree(hOBJECT hObj,void* Obj)\r\n{\r\n\tif (!Obj) return;\r\n\tCALL_SYS_ObjHeapFree(hObj,Obj);\r\n\treturn;\r\n}", "id": 142, "concepts": ["memory management", "object heap freeing", "return handling"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 2\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 5\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 6\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 9\n### Snippet\nvoid process()\n{\n\tfor(int j=1;j<20;j++)\n\t\tfor(int i=1;i<=n;i++) \n\t\tfa[i][j]=fa[fa[i][j-1]][j-1],val[i][j]=mul(val[i][j-1]+val[fa[i][j-1]][j-1]);\n}\n\n### Concepts", "fingerprint": null, "seed": "void process()\n{\n\tfor(int j=1;j<20;j++)\n\t\tfor(int i=1;i<=n;i++) \n\t\tfa[i][j]=fa[fa[i][j-1]][j-1],val[i][j]=mul(val[i][j-1]+val[fa[i][j-1]][j-1]);\n}", "id": 143, "concepts": ["dynamic programming for efficient calculation", "avoiding redundant calculations"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 3\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 5\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 8\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 9\n### Snippet\nvoid setCoin(int w)\r\n{\r\n\tint i, j;\r\n\tfor (i = 0; i < 2; i++)\r\n\t\tfor (j = 0; j < s[i].size(); j++)\r\n\t\t\tif (!ox[s[i][j] - 'A'])\r\n\t\t\t\tcoin[s[i][j] - 'A'] += w * ((i == 1) * 1 + (-1) * (i == 0));\r\n\treturn ;\r\n}\n\n### Concepts", "fingerprint": null, "seed": "void setCoin(int w)\r\n{\r\n\tint i, j;\r\n\tfor (i = 0; i < 2; i++)\r\n\t\tfor (j = 0; j < s[i].size(); j++)\r\n\t\t\tif (!ox[s[i][j] - 'A'])\r\n\t\t\t\tcoin[s[i][j] - 'A'] += w * ((i == 1) * 1 + (-1) * (i == 0));\r\n\treturn ;\r\n}", "id": 144, "concepts": ["bit manipulation for coin weight calculation", "coin array update", "value assignment based on condition"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 2\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 5\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 6\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 9\n### Snippet\nvoid p4(Node *h){\n\tNode *p = h;\n\twhile(p){\n\t\tNode *pn = p->next;\n\t\tif(pn == NULL || (\n\t\t\tpn->c != ',' &&\n\t\t\tpn->c != ';' &&\n\t\t\tpn->c != ':' &&\n\t\t\tpn->c != '@' &&\n\t\t\tpn->c != '#' &&\n\t\t\tpn->c != '$' &&\n\t\t\tpn->c != '%' &&\n\t\t\tpn->c != '&')){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n//\t\tcout<<\"p4\"<<endl;\n\t\tNode *node;\n\t\tnode = new Node(' ');\n\t\tp = insert(p,node);\n\t\tnode = new Node(' ');\n\t\tpn = insert(pn,node);\n\t\tp = pn;\n\t}\n}\n\n### Concepts", "fingerprint": null, "seed": "void p4(Node *h){\n\tNode *p = h;\n\twhile(p){\n\t\tNode *pn = p->next;\n\t\tif(pn == NULL || (\n\t\t\tpn->c != ',' &&\n\t\t\tpn->c != ';' &&\n\t\t\tpn->c != ':' &&\n\t\t\tpn->c != '@' &&\n\t\t\tpn->c != '#' &&\n\t\t\tpn->c != '$' &&\n\t\t\tpn->c != '%' &&\n\t\t\tpn->c != '&')){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n//\t\tcout<<\"p4\"<<endl;\n\t\tNode *node;\n\t\tnode = new Node(' ');\n\t\tp = insert(p,node);\n\t\tnode = new Node(' ');\n\t\tpn = insert(pn,node);\n\t\tp = pn;\n\t}\n}", "id": 145, "concepts": ["insertion of nodes into a linked list", "filtering specific characters", "string interpolation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 4\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 5\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 7\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 8\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 9\n### Snippet\nvoid loop() {\n  if (millis() - t0 > 1000)\n  {\n    state++;\n    t0 = millis();\n  }\n  accel = getSimpleValue(X_ACCEL, Y_ACCEL, Z_ACCEL);\n//  Serial.print(\"Simple value: \");\n//  Serial.print(accel);\n  float accel_rms = getFilteredSignal(X_ACCEL, Y_ACCEL, Z_ACCEL);\n  Serial.print(accel_rms);\n  Serial.print(\",\");\n  accel_rms = filtered_value->step(accel_rms);\n//  Serial.print(\" - RMS value: \");\n  Serial.print(accel_rms);\n  Serial1.println(accel_rms);\n  Serial.print(\",\");\n  Serial.println(state);\n  // Serial.print(\"X: \");\n  // Serial.print(getSeparatedValues(X_ACCEL) - mean_x);\n  // Serial.print(\" - Y: \");\n  // Serial.print(getSeparatedValues(Y_ACCEL) - mean_y);\n  // Serial.print(\" - Z: \");\n  // Serial.println(getSeparatedValues(Z_ACCEL) - mean_z);\n  delay(1);\n}\n\n### Concepts", "fingerprint": null, "seed": "void loop() {\n  if (millis() - t0 > 1000)\n  {\n    state++;\n    t0 = millis();\n  }\n  accel = getSimpleValue(X_ACCEL, Y_ACCEL, Z_ACCEL);\n//  Serial.print(\"Simple value: \");\n//  Serial.print(accel);\n  float accel_rms = getFilteredSignal(X_ACCEL, Y_ACCEL, Z_ACCEL);\n  Serial.print(accel_rms);\n  Serial.print(\",\");\n  accel_rms = filtered_value->step(accel_rms);\n//  Serial.print(\" - RMS value: \");\n  Serial.print(accel_rms);\n  Serial1.println(accel_rms);\n  Serial.print(\",\");\n  Serial.println(state);\n  // Serial.print(\"X: \");\n  // Serial.print(getSeparatedValues(X_ACCEL) - mean_x);\n  // Serial.print(\" - Y: \");\n  // Serial.print(getSeparatedValues(Y_ACCEL) - mean_y);\n  // Serial.print(\" - Z: \");\n  // Serial.println(getSeparatedValues(Z_ACCEL) - mean_z);\n  delay(1);\n}", "id": 146, "concepts": ["data processing with accelerometer", "filtering and smoothing", "serial communication", "RMS calculation", "state transitions"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 2\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 3\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 6\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 9\n### Snippet\nint ledToggle(String command) {\n     /* Particle.functions always take a string as an argument and return an integer.\n     Since we can pass a string, it means that we can give the program commands on how the function should be used.\n     In this case, telling the function \"on\" will turn the LED on and telling it \"off\" will turn the LED off.\n     Then, the function returns a value to us to let us know what happened.\n     In this case, it will return 1 for the LEDs turning on, 0 for the LEDs turning off,\n     and -1 if we received a totally bogus command that didn't do anything to the LEDs.\n     */\n     if (command==\"on\") {\n         digitalWrite(pinLed,HIGH);\n         return 1;\n     }\n     else if (command==\"off\") {\n         digitalWrite(pinLed,LOW);\n         return 0;\n     }\n     else {\n         return -1;\n     }\n}\n\n### Concepts", "fingerprint": null, "seed": "int ledToggle(String command) {\n     /* Particle.functions always take a string as an argument and return an integer.\n     Since we can pass a string, it means that we can give the program commands on how the function should be used.\n     In this case, telling the function \"on\" will turn the LED on and telling it \"off\" will turn the LED off.\n     Then, the function returns a value to us to let us know what happened.\n     In this case, it will return 1 for the LEDs turning on, 0 for the LEDs turning off,\n     and -1 if we received a totally bogus command that didn't do anything to the LEDs.\n     */\n     if (command==\"on\") {\n         digitalWrite(pinLed,HIGH);\n         return 1;\n     }\n     else if (command==\"off\") {\n         digitalWrite(pinLed,LOW);\n         return 0;\n     }\n     else {\n         return -1;\n     }\n}", "id": 147, "concepts": ["Particle.functions", "string to integer conversion", "string matching"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 3\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 6\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 7\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 9\n### Snippet\nvoid del(Node *p){\n\tif(p->next){\n\t\tNode *pnext = p->next;\n\t\tNode *pnextnext = pnext->next;\n\t\tp->next = pnextnext;\n\t\tdelete pnext;\n\t}\n}\n\n### Concepts", "fingerprint": null, "seed": "void del(Node *p){\n\tif(p->next){\n\t\tNode *pnext = p->next;\n\t\tNode *pnextnext = pnext->next;\n\t\tp->next = pnextnext;\n\t\tdelete pnext;\n\t}\n}", "id": 148, "concepts": ["deletion in linked lists", "handling of edge cases and boundary conditions"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 4\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 5\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 8\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 9\n### Snippet\nvoid p7(Node *h){\n\tNode *p = h;\n\twhile(p){\n\t\tNode *pn = p->next;\n\t\tif(pn == NULL || \n\t\t\t(pn->c != ']' &&\n\t\t\t pn->c != '[' &&\n\t\t\t pn->c != '(' &&\n\t\t\t pn->c != ')' &&\n\t\t\t pn->c != '{' &&\n\t\t\t pn->c != '}' &&\n\t\t\t pn->c != '<' &&\n\t\t\t pn->c != '>')){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n//\t\tcout<<\"p7\"<<endl;\n\t\tNode *node = new Node(' ');\n\t\tp = insert(p,node);\n\t\tnode = new Node(' ');\n\t\tpn = insert(pn,node);\n\t\tp = pn;\n\t}\n}\n\n### Concepts", "fingerprint": null, "seed": "void p7(Node *h){\n\tNode *p = h;\n\twhile(p){\n\t\tNode *pn = p->next;\n\t\tif(pn == NULL || \n\t\t\t(pn->c != ']' &&\n\t\t\t pn->c != '[' &&\n\t\t\t pn->c != '(' &&\n\t\t\t pn->c != ')' &&\n\t\t\t pn->c != '{' &&\n\t\t\t pn->c != '}' &&\n\t\t\t pn->c != '<' &&\n\t\t\t pn->c != '>')){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n//\t\tcout<<\"p7\"<<endl;\n\t\tNode *node = new Node(' ');\n\t\tp = insert(p,node);\n\t\tnode = new Node(' ');\n\t\tpn = insert(pn,node);\n\t\tp = pn;\n\t}\n}", "id": 149, "concepts": ["string parsing", "linked list manipulation", "parenthesis matching"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 3\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 5\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 7\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 9\n### Snippet\nint mul(int x){return x>=mod?x-mod:x;}\n\n### Concepts", "fingerprint": null, "seed": "int mul(int x){return x>=mod?x-mod:x;}", "id": 150, "concepts": ["modular arithmetic for integer multiplication"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 2\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 4\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 5\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 6\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 9\n### Snippet\nvoid setup_Funk()\n{\n  SPI.begin();\n  radio.begin();\n  network.begin(FunkChannel, FunkSlaveJoystick); //(channel, node address)\n  radio.setPALevel(RF24_PA_MAX);\n  radio.setDataRate(RF24_2MBPS);\n  radio.setAutoAck(1); // Ensure autoACK is enabled\n  radio.setRetries(15, 15);\n  // delay How long to wait between each retry, in multiples of 250us, max is 15. 0 means 250us, 15 means 4000us.\n  //count How many retries before giving up, max 15\n}\n\n### Concepts", "fingerprint": null, "seed": "void setup_Funk()\n{\n  SPI.begin();\n  radio.begin();\n  network.begin(FunkChannel, FunkSlaveJoystick); //(channel, node address)\n  radio.setPALevel(RF24_PA_MAX);\n  radio.setDataRate(RF24_2MBPS);\n  radio.setAutoAck(1); // Ensure autoACK is enabled\n  radio.setRetries(15, 15);\n  // delay How long to wait between each retry, in multiples of 250us, max is 15. 0 means 250us, 15 means 4000us.\n  //count How many retries before giving up, max 15\n}", "id": 151, "concepts": ["radio communication setup", "network configuration", "automatic acknowledgement", "retry configuration", "delay calculation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 4\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 6\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 7\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 9\n### Snippet\nvoid phasefailurenotification()\n{\n   if(phasefailurenotificationflag == true && phaseFailureAlertOnOffState == 0 && blynkConnectionStatusForNotification == true){\n     Serial.println(\"Sending Phase Failure Blynk notification\");\n     Blynk.notify(\"Phase Failure Detected!\");\n     phasefailurenotificationflag = false;\n   }\n}\n\n### Concepts", "fingerprint": null, "seed": "void phasefailurenotification()\n{\n   if(phasefailurenotificationflag == true && phaseFailureAlertOnOffState == 0 && blynkConnectionStatusForNotification == true){\n     Serial.println(\"Sending Phase Failure Blynk notification\");\n     Blynk.notify(\"Phase Failure Detected!\");\n     phasefailurenotificationflag = false;\n   }\n}", "id": 152, "concepts": ["notification handling for specific conditions", "error logging with serial output"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 3\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 6\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 8\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 9\n### Snippet\nvoid calc_expr(int val)\n{\n\tstd::cout << val << std::endl;\n}\n\n### Concepts", "fingerprint": null, "seed": "void calc_expr(int val)\n{\n\tstd::cout << val << std::endl;\n}", "id": 153, "concepts": ["function definition", "function signature", "input parameter"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 2\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 4\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 7\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 9\n### Snippet\nvoid DiscreteMasterProperty__bool__OnComplete(DiscreteMasterProperty__bool* __this)\n{\n    bool nv = __this->RestValue();\n    float str = 0.5f;\n\n    for (::app::Uno::Collections::List1_Enumerator__Fuse_Animations_MixerHandle_bool_ enum_123 = ::uPtr< ::app::Uno::Collections::List__Fuse_Animations_MixerHandle_bool_*>(__this->Handles)->GetEnumerator(); enum_123.MoveNext(); )\n    {\n        ::app::Fuse::Animations::MixerHandle__bool* v = enum_123.Current();\n\n        if (::uPtr< ::app::Fuse::Animations::MixerHandle__bool*>(v)->HasValue() && (::uPtr< ::app::Fuse::Animations::MixerHandle__bool*>(v)->Strength > str))\n        {\n            nv = ::uPtr< ::app::Fuse::Animations::MixerHandle__bool*>(v)->Value;\n            str = v->Strength;\n        }\n    }\n\n    ::uPtr< ::app::Uno::UX::Property__bool*>(__this->Property)->Set(nv, (::uObject*)__this);\n}\n\n### Concepts", "fingerprint": null, "seed": "void DiscreteMasterProperty__bool__OnComplete(DiscreteMasterProperty__bool* __this)\n{\n    bool nv = __this->RestValue();\n    float str = 0.5f;\n\n    for (::app::Uno::Collections::List1_Enumerator__Fuse_Animations_MixerHandle_bool_ enum_123 = ::uPtr< ::app::Uno::Collections::List__Fuse_Animations_MixerHandle_bool_*>(__this->Handles)->GetEnumerator(); enum_123.MoveNext(); )\n    {\n        ::app::Fuse::Animations::MixerHandle__bool* v = enum_123.Current();\n\n        if (::uPtr< ::app::Fuse::Animations::MixerHandle__bool*>(v)->HasValue() && (::uPtr< ::app::Fuse::Animations::MixerHandle__bool*>(v)->Strength > str))\n        {\n            nv = ::uPtr< ::app::Fuse::Animations::MixerHandle__bool*>(v)->Value;\n            str = v->Strength;\n        }\n    }\n\n    ::uPtr< ::app::Uno::UX::Property__bool*>(__this->Property)->Set(nv, (::uObject*)__this);\n}", "id": 154, "concepts": ["C++ code snippet with a function definition for the `DiscreteMasterProperty__bool__OnComplete` method. The function takes a pointer to a `DiscreteMasterProperty__bool` object as an argument. The function iterates through the object's `Handles` list", "which contains `MixerHandle__bool` objects", "and finds the one with the highest strength. If such a handle exists", "the function sets the value of the `Property` to the value of the handle."]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 2\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 4\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 5\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 6\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 9\n### Snippet\nint main(){\n    int n,v;\n    fin>>n;\n    int en=0;\n    for(int i=0;i<n;i++)\n    {\n        for(int j=0;j<n;j++)\n        {\n            fin>>v;\n            if(j<=i)\n                continue;\n            edg[en].v=v;\n            edg[en].x=i;\n            edg[en].y=j;\n            en++;\n        }\n    }\n    //\n    sort(edg,edg+en,cmp);\n    int eslc=0;\n    UnionFind<100> uf;\n    int cost=0;\n    for(int i=0;i<en&&eslc<en-1;i++)\n    {\n        if(uf.Union(edg[i].x,edg[i].y)){\n            cost+=edg[i].v;\n            eslc++;\n        }\n    }\n    fout<<cost<<endl;\n}\n\n### Concepts", "fingerprint": null, "seed": "int main(){\n    int n,v;\n    fin>>n;\n    int en=0;\n    for(int i=0;i<n;i++)\n    {\n        for(int j=0;j<n;j++)\n        {\n            fin>>v;\n            if(j<=i)\n                continue;\n            edg[en].v=v;\n            edg[en].x=i;\n            edg[en].y=j;\n            en++;\n        }\n    }\n    //\n    sort(edg,edg+en,cmp);\n    int eslc=0;\n    UnionFind<100> uf;\n    int cost=0;\n    for(int i=0;i<en&&eslc<en-1;i++)\n    {\n        if(uf.Union(edg[i].x,edg[i].y)){\n            cost+=edg[i].v;\n            eslc++;\n        }\n    }\n    fout<<cost<<endl;\n}", "id": 155, "concepts": ["graph traversal", "sorting", "union-find data structure"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 4\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 6\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 7\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 8\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 9\n### Snippet\nint main()\n{\n    Proxy c;\n\n    c.set_X(4);\n    c.set_Y(4.5);\n    c.set_Z(\"Hello\");\n\n    for(int i=0; i<5; i++){\n        c.g();\n        c.f(4);\n    }\n}\n\n### Concepts", "fingerprint": null, "seed": "int main()\n{\n    Proxy c;\n\n    c.set_X(4);\n    c.set_Y(4.5);\n    c.set_Z(\"Hello\");\n\n    for(int i=0; i<5; i++){\n        c.g();\n        c.f(4);\n    }\n}", "id": 156, "concepts": ["class definition", "function implementation", "function overloading", "function overriding", "inheritance", "polymorphism"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 2\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 5\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 7\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 8\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 9\n### Snippet\nvoid expand_idata(float *data2, float *data3, int Nx, int Ny, int Lx) \n{ \n\t#pragma acc parallel loop independent present(data2[0:Lx*Ny],data3[0:2*Lx*Ny]) \n\tfor (int i=0;i<Ny;i++) \n\t{ \n\t\t#pragma acc loop independent \n\t\tfor (int j=0;j<Lx;j++) \n\t\t{ \n\t\t\tdata3[2*Lx*i+2*j] = data2[Lx*i+j]; \n\t\t\tdata3[2*Lx*i+2*j+1] = 0.0; \n\t\t} \n\t} \n}\n\n### Concepts", "fingerprint": null, "seed": "void expand_idata(float *data2, float *data3, int Nx, int Ny, int Lx) \n{ \n\t#pragma acc parallel loop independent present(data2[0:Lx*Ny],data3[0:2*Lx*Ny]) \n\tfor (int i=0;i<Ny;i++) \n\t{ \n\t\t#pragma acc loop independent \n\t\tfor (int j=0;j<Lx;j++) \n\t\t{ \n\t\t\tdata3[2*Lx*i+2*j] = data2[Lx*i+j]; \n\t\t\tdata3[2*Lx*i+2*j+1] = 0.0; \n\t\t} \n\t} \n}", "id": 157, "concepts": ["data expansion", "2D array handling", "loop parallelization"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 3\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 5\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 6\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 8\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 9\n### Snippet\nvoid pzemdevice2()                                                                // Function to get PZEM device 2 data\n{\n  Serial.println(\"====================================================\");\n  Serial.println(\"Now checking PZEM Device 2\");\n  uint8_t result2;\n\n  ESP.wdtDisable();\n  result2 = node2.readInputRegisters(0x0000, 10);\n  ESP.wdtEnable(1);\n\n  if (result2 == node2.ku8MBSuccess)\n  {\n    voltage_usage_2      = (node2.getResponseBuffer(0x00) / 10.0f);\n    current_usage_2      = (node2.getResponseBuffer(0x01) / 1000.000f);\n    active_power_2       = (node2.getResponseBuffer(0x03) / 10.0f);\n    active_energy_2      = (node2.getResponseBuffer(0x05) / 1000.0f);\n    frequency_2          = (node2.getResponseBuffer(0x07) / 10.0f);\n    power_factor_2       = (node2.getResponseBuffer(0x08) / 100.0f);\n\n    Serial.print(\"VOLTAGE:           \");   Serial.println(voltage_usage_2);         // V\n    Serial.print(\"CURRENT_USAGE:     \");   Serial.println(current_usage_2, 3);      // A\n    Serial.print(\"ACTIVE_POWER:      \");   Serial.println(active_power_2);          // W\n    Serial.print(\"ACTIVE_ENERGY:     \");   Serial.println(active_energy_2, 3);      // kWh\n    Serial.print(\"FREQUENCY:         \");   Serial.println(frequency_2);             // Hz\n    Serial.print(\"POWER_FACTOR:      \");   Serial.println(power_factor_2);\n    Serial.println(\"====================================================\");\n  }\n    else {\n    Serial.println(\"Failed to read PZEM Device 2\");\n    Serial.println(\"PZEM Device 2 Data\");\n    voltage_usage_2      = 0;\n    current_usage_2      = 0;\n    active_power_2       = 0;\n    active_energy_2      = 0;\n    frequency_2          = 0;\n    power_factor_2       = 0;\n    Serial.print(\"VOLTAGE:           \");   Serial.println(voltage_usage_2);         // V\n    Serial.print(\"CURRENT_USAGE:     \");   Serial.println(current_usage_2, 3);      // A\n    Serial.print(\"ACTIVE_POWER:      \");   Serial.println(active_power_2);          // W\n    Serial.print(\"ACTIVE_ENERGY:     \");   Serial.println(active_energy_2, 3);      // kWh\n    Serial.print(\"FREQUENCY:         \");   Serial.println(frequency_2);             // Hz\n    Serial.print(\"POWER_FACTOR:      \");   Serial.println(power_factor_2);\n    Serial.println(\"====================================================\");\n    swith_off(); \n  }\n}\n\n### Concepts", "fingerprint": null, "seed": "void pzemdevice2()                                                                // Function to get PZEM device 2 data\n{\n  Serial.println(\"====================================================\");\n  Serial.println(\"Now checking PZEM Device 2\");\n  uint8_t result2;\n\n  ESP.wdtDisable();\n  result2 = node2.readInputRegisters(0x0000, 10);\n  ESP.wdtEnable(1);\n\n  if (result2 == node2.ku8MBSuccess)\n  {\n    voltage_usage_2      = (node2.getResponseBuffer(0x00) / 10.0f);\n    current_usage_2      = (node2.getResponseBuffer(0x01) / 1000.000f);\n    active_power_2       = (node2.getResponseBuffer(0x03) / 10.0f);\n    active_energy_2      = (node2.getResponseBuffer(0x05) / 1000.0f);\n    frequency_2          = (node2.getResponseBuffer(0x07) / 10.0f);\n    power_factor_2       = (node2.getResponseBuffer(0x08) / 100.0f);\n\n    Serial.print(\"VOLTAGE:           \");   Serial.println(voltage_usage_2);         // V\n    Serial.print(\"CURRENT_USAGE:     \");   Serial.println(current_usage_2, 3);      // A\n    Serial.print(\"ACTIVE_POWER:      \");   Serial.println(active_power_2);          // W\n    Serial.print(\"ACTIVE_ENERGY:     \");   Serial.println(active_energy_2, 3);      // kWh\n    Serial.print(\"FREQUENCY:         \");   Serial.println(frequency_2);             // Hz\n    Serial.print(\"POWER_FACTOR:      \");   Serial.println(power_factor_2);\n    Serial.println(\"====================================================\");\n  }\n    else {\n    Serial.println(\"Failed to read PZEM Device 2\");\n    Serial.println(\"PZEM Device 2 Data\");\n    voltage_usage_2      = 0;\n    current_usage_2      = 0;\n    active_power_2       = 0;\n    active_energy_2      = 0;\n    frequency_2          = 0;\n    power_factor_2       = 0;\n    Serial.print(\"VOLTAGE:           \");   Serial.println(voltage_usage_2);         // V\n    Serial.print(\"CURRENT_USAGE:     \");   Serial.println(current_usage_2, 3);      // A\n    Serial.print(\"ACTIVE_POWER:      \");   Serial.println(active_power_2);          // W\n    Serial.print(\"ACTIVE_ENERGY:     \");   Serial.println(active_energy_2, 3);      // kWh\n    Serial.print(\"FREQUENCY:         \");   Serial.println(frequency_2);             // Hz\n    Serial.print(\"POWER_FACTOR:      \");   Serial.println(power_factor_2);\n    Serial.println(\"====================================================\");\n    swith_off(); \n  }\n}", "id": 158, "concepts": ["serial communication with an external device", "data parsing and processing", "error handling"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 3\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 4\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 7\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 9\n### Snippet\nvoid print_usage(FILE* stream, int exit_code, char* program_name)\r\n{\r\n\tfprintf(stream,\r\n\t\t\t\"A program to generate terrain and features with variable formats.\\n\\n\");\r\n\tfprintf(stream, \"Usage:  %s [options]\\n\", program_name);\r\n\tfprintf(stream,\r\n\t\t\t\"  -h  --help                 Display this usage information.\\n\"\r\n\t\t\t\t\t\"  -c  --config <filename>    Use custom config file.\\n\"\r\n\t\t\t\t\t\"  -v  --verbose              Print verbose messages.\\n\"\r\n\t\t\t\t\t\"      --height <value>       Crop the map down to specified positive integer height.\\n\"\r\n\t\t\t\t\t\"      --width <value>        Crop the map down to specified positive integer width.\\n\"\r\n\t\t\t\t\t\"      --rough <value>        Define smoothness of the terrain as a float (0.0 < v < 1.0).\\n\"\r\n\t\t\t\t\t\"                             Lower values produce smoother terrain, smaller difference in adjacent tiles.\\n\"\r\n\t\t\t\t\t\"      --seed <value>         Set the initial positive integer height for the algorithm to be generate values from.\\n\"\r\n\t\t\t\t\t\"      --offset <value>       Set the initial offset positive integer height (seed+offset=max possible height).\\n\"\r\n\t\t\t\t\t\"      --plate <value>        Set the fraction of the tectonic plates appearance.\\n\"\r\n\t\t\t\t\t\"                             Higher values will give a more 'ripped apart' look, values too close to 1 are not\\n\"\r\n\t\t\t\t\t\"                             recommended for realistic terrain. (0.0 < v < 1.0)\\n\"\r\n\t\t\t\t\t\"      --erosion <value>      Number of erosion iterations over the terrain. Must be a positive integer.\\n\"\r\n\t\t\t\t\t\"  -n  --negative             Allow for negative height values.\\n\"\r\n\t\t\t\t\t\"  -s  --standard             Use standard output to be written to a file (used as default output).\\n\"\r\n\t\t\t\t\t\"                             width, height and a set of height values all separated by a space.\\n\"\r\n\t\t\t\t\t\"  -g  --graphical            Display the height map using a 3D OpenGL view.\\n\"\r\n\t\t\t\t\t\"  -x  --xml                  Use the following xml output to be written to a file:\\n\"\r\n\t\t\t\t\t\"                           <map width=int height=int>\\n\"\r\n\t\t\t\t\t\"                           [<tile x=int y=int>\\n\"\r\n\t\t\t\t\t\"                           <height>int</height>\\n\"\r\n\t\t\t\t\t\"\t\t\t\t\t\t\t<type>string</type>\\n\"\r\n\t\t\t\t\t\"                           </tile>\\n]+\"\r\n\t\t\t\t\t\"                           </map>\\n\");\r\n\texit(exit_code);\r\n}\n\n### Concepts", "fingerprint": null, "seed": "void print_usage(FILE* stream, int exit_code, char* program_name)\r\n{\r\n\tfprintf(stream,\r\n\t\t\t\"A program to generate terrain and features with variable formats.\\n\\n\");\r\n\tfprintf(stream, \"Usage:  %s [options]\\n\", program_name);\r\n\tfprintf(stream,\r\n\t\t\t\"  -h  --help                 Display this usage information.\\n\"\r\n\t\t\t\t\t\"  -c  --config <filename>    Use custom config file.\\n\"\r\n\t\t\t\t\t\"  -v  --verbose              Print verbose messages.\\n\"\r\n\t\t\t\t\t\"      --height <value>       Crop the map down to specified positive integer height.\\n\"\r\n\t\t\t\t\t\"      --width <value>        Crop the map down to specified positive integer width.\\n\"\r\n\t\t\t\t\t\"      --rough <value>        Define smoothness of the terrain as a float (0.0 < v < 1.0).\\n\"\r\n\t\t\t\t\t\"                             Lower values produce smoother terrain, smaller difference in adjacent tiles.\\n\"\r\n\t\t\t\t\t\"      --seed <value>         Set the initial positive integer height for the algorithm to be generate values from.\\n\"\r\n\t\t\t\t\t\"      --offset <value>       Set the initial offset positive integer height (seed+offset=max possible height).\\n\"\r\n\t\t\t\t\t\"      --plate <value>        Set the fraction of the tectonic plates appearance.\\n\"\r\n\t\t\t\t\t\"                             Higher values will give a more 'ripped apart' look, values too close to 1 are not\\n\"\r\n\t\t\t\t\t\"                             recommended for realistic terrain. (0.0 < v < 1.0)\\n\"\r\n\t\t\t\t\t\"      --erosion <value>      Number of erosion iterations over the terrain. Must be a positive integer.\\n\"\r\n\t\t\t\t\t\"  -n  --negative             Allow for negative height values.\\n\"\r\n\t\t\t\t\t\"  -s  --standard             Use standard output to be written to a file (used as default output).\\n\"\r\n\t\t\t\t\t\"                             width, height and a set of height values all separated by a space.\\n\"\r\n\t\t\t\t\t\"  -g  --graphical            Display the height map using a 3D OpenGL view.\\n\"\r\n\t\t\t\t\t\"  -x  --xml                  Use the following xml output to be written to a file:\\n\"\r\n\t\t\t\t\t\"                           <map width=int height=int>\\n\"\r\n\t\t\t\t\t\"                           [<tile x=int y=int>\\n\"\r\n\t\t\t\t\t\"                           <height>int</height>\\n\"\r\n\t\t\t\t\t\"\t\t\t\t\t\t\t<type>string</type>\\n\"\r\n\t\t\t\t\t\"                           </tile>\\n]+\"\r\n\t\t\t\t\t\"                           </map>\\n\");\r\n\texit(exit_code);\r\n}", "id": 159, "concepts": ["command-line argument parsing", "output formatting", "error handling"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 2\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 5\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 6\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 7\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 9\n### Snippet\nfloat\ngetBufferFloat(cstring charBuffer)\n{\n    return (float) atof(charBuffer);\n}\n\n### Concepts", "fingerprint": null, "seed": "float\ngetBufferFloat(cstring charBuffer)\n{\n    return (float) atof(charBuffer);\n}", "id": 160, "concepts": ["character array parsing", "type conversion", "string to float conversion"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 2\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 3\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 7\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 9\n### Snippet\nint main()\r\n{\r\n\tStudent s[3]={{1001,\"Sunny\",90},{1002,\"Tom\",80},{1003,\"Kitty\",85}};\r\n\tStudent *p,*head;\r\n\thead=s;\r\n\ts[0].next=&s[1];\r\n\ts[1].next=&s[2];\r\n\ts[2].next=NULL;\r\n\tp=head;\r\n\twhile(p!=NULL)\r\n\t{\r\n\t\tprintf(\"%6d %6s %6.2f\",p->num,p->name,p->score);\r\n\t\tp=p->next;\r\n\t\tprintf(\"\\n\");\r\n\t}\r\nreturn 0;\t\t\t\r\n}\n\n### Concepts", "fingerprint": null, "seed": "int main()\r\n{\r\n\tStudent s[3]={{1001,\"Sunny\",90},{1002,\"Tom\",80},{1003,\"Kitty\",85}};\r\n\tStudent *p,*head;\r\n\thead=s;\r\n\ts[0].next=&s[1];\r\n\ts[1].next=&s[2];\r\n\ts[2].next=NULL;\r\n\tp=head;\r\n\twhile(p!=NULL)\r\n\t{\r\n\t\tprintf(\"%6d %6s %6.2f\",p->num,p->name,p->score);\r\n\t\tp=p->next;\r\n\t\tprintf(\"\\n\");\r\n\t}\r\nreturn 0;\t\t\t\r\n}", "id": 161, "concepts": ["linked list traversal", "node struct definition", "pointer manipulation for list traversal"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 4\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 5\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 6\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 7\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 8\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 9\n### Snippet\nint main()\n{\n    string s1 = \"eebaacbcbcadaaedceaaacadccd\";\n    string s2 = \"eadcaacabaddaceacbceaabeccd\";\n    \n    bool result = isScramble(s1, s2);\n    cout << \"result = \" << result << endl;\n\n    return 0;\n}\n\n### Concepts", "fingerprint": null, "seed": "int main()\n{\n    string s1 = \"eebaacbcbcadaaedceaaacadccd\";\n    string s2 = \"eadcaacabaddaceacbceaabeccd\";\n    \n    bool result = isScramble(s1, s2);\n    cout << \"result = \" << result << endl;\n\n    return 0;\n}", "id": 162, "concepts": ["string scrambler", "string scrambling", "checking string scrambler"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 2\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 5\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 6\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 8\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 9\n### Snippet\nvoid accel_values_put(float value_in)\n{\n  if (queue_position == RMS_window)\n    queue_position = 0;\n  accel_values[queue_position] = value_in;\n  queue_position++;\n}\n\n### Concepts", "fingerprint": null, "seed": "void accel_values_put(float value_in)\n{\n  if (queue_position == RMS_window)\n    queue_position = 0;\n  accel_values[queue_position] = value_in;\n  queue_position++;\n}", "id": 163, "concepts": ["accelerometer values", "value queueing", "circular queue"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 4\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 5\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 6\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 9\n### Snippet\nint main() {\n    Foo s1, s2(1);\n    bar(s1);\n    bar(2);\n}\n\n### Concepts", "fingerprint": null, "seed": "int main() {\n    Foo s1, s2(1);\n    bar(s1);\n    bar(2);\n}", "id": 164, "concepts": ["function overloading", "object creation and initialization", "function call resolution"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 3\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 5\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 6\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 7\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 9\n### Snippet\nfloat getSeparatedValues(int pin)\n{  \n  float instant_value = analogRead(pin);\n  return instant_value;\n}\n\n### Concepts", "fingerprint": null, "seed": "float getSeparatedValues(int pin)\n{  \n  float instant_value = analogRead(pin);\n  return instant_value;\n}", "id": 165, "concepts": ["analog read from a pin", "instantaneous value acquisition", "floating-point number representation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 3\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 4\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 6\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 9\n### Snippet\nvoid p13(Node *h, char *c){\n\tNode *p = h;\n\twhile(p){\n\t\tNode *pn = p->next;\n\t\tif(pn == NULL || pn->c != c[0]){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tNode *pnn = pn->next;\n\t\tif(pnn == NULL || pnn->c != c[1]){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tNode *pnnn = pnn->next;\n\t\tif(pnnn == NULL || pnnn->c != c[2]){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tNode *pnnnn = pnnn->next;\n\t\tif(pnnnn == NULL || pnnnn->c != ' '){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n//\t\tcout<<\"p13\"<<endl;\n\t\tNode *node = new Node(' ');\n\t\tp = insert(p,node);\n\t\tp = pnnnn;\n\t}\n}\n\n### Concepts", "fingerprint": null, "seed": "void p13(Node *h, char *c){\n\tNode *p = h;\n\twhile(p){\n\t\tNode *pn = p->next;\n\t\tif(pn == NULL || pn->c != c[0]){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tNode *pnn = pn->next;\n\t\tif(pnn == NULL || pnn->c != c[1]){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tNode *pnnn = pnn->next;\n\t\tif(pnnn == NULL || pnnn->c != c[2]){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tNode *pnnnn = pnnn->next;\n\t\tif(pnnnn == NULL || pnnnn->c != ' '){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n//\t\tcout<<\"p13\"<<endl;\n\t\tNode *node = new Node(' ');\n\t\tp = insert(p,node);\n\t\tp = pnnnn;\n\t}\n}", "id": 166, "concepts": ["linked list traversal", "pattern matching", "node insertion", "string concatenation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 3\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 4\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 6\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 8\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 9\n### Snippet\nvoid solve(){\n    string s; cin>>s;\n    bool w = false;\n    bool com = false;\n    bool fwd = false;\n    int w_cnt = 0;\n    int fw_cnt = 0;\n    for(int i = 0; i < s.length(); i++){\n        if(w_cnt == 3 && !w){\n            cout<<\".\";\n            w = true;\n        }\n        if(s[i] == 'w'){\n            w_cnt++;\n        }else{\n            w_cnt = 0;\n        }\n        if(i+3 <= s.length()){\n            if(s[i] == 'c' && s[i+1] == 'o' && s[i+2] == 'm' && !com){\n                cout<<\".\";\n                com = true;\n                fw_cnt = i+3;\n            }\n        }\n        if(i == fw_cnt && !fwd && i != 0){\n            cout<<\"/\";\n            fwd = true;\n        }\n        cout<<s[i];\n\n    }\n}\n\n### Concepts", "fingerprint": null, "seed": "void solve(){\n    string s; cin>>s;\n    bool w = false;\n    bool com = false;\n    bool fwd = false;\n    int w_cnt = 0;\n    int fw_cnt = 0;\n    for(int i = 0; i < s.length(); i++){\n        if(w_cnt == 3 && !w){\n            cout<<\".\";\n            w = true;\n        }\n        if(s[i] == 'w'){\n            w_cnt++;\n        }else{\n            w_cnt = 0;\n        }\n        if(i+3 <= s.length()){\n            if(s[i] == 'c' && s[i+1] == 'o' && s[i+2] == 'm' && !com){\n                cout<<\".\";\n                com = true;\n                fw_cnt = i+3;\n            }\n        }\n        if(i == fw_cnt && !fwd && i != 0){\n            cout<<\"/\";\n            fwd = true;\n        }\n        cout<<s[i];\n\n    }\n}", "id": 167, "concepts": ["domain name parsing", "pattern matching and replacement", "string processing"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 2\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 6\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 8\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 9\n### Snippet\nint main(){\n    //use double otherwise it will overflow\n    double m,n;\n    vector<double>top;\n    vector<double>bottom;\n    while(cin>>m>>n){\n        if(m==0&&n==0)\n            break;\n        if(n==0){\n            cout<<1<<endl;\n            continue;\n        }\n        n=min(n,m-n);\n        for(double i=0;i<n;i++){\n            top.push_back(m-i);\n            bottom.push_back(i+1);\n\n        }\n        for(int i=n-1;i>=0;i--){\n            for(int j=0;j<n;j++){\n                if((top[j]/bottom[i])==int(top[j]/bottom[i])){\n                    top[j]/=bottom[i];\n                    bottom[i]=1;\n                    break;\n                }\n            }\n        }\n        double ans=1,ans2=1;\n        for(int i=0;i<n;i++){\n            ans*=top[i];\n            ans2*=bottom[i];\n        }\n        cout<<int(ans/ans2)<<endl;\n        top.clear();\n        bottom.clear();\n    }\n\n\n\n\n\n\n\n\n    return 0;\n}\n\n### Concepts", "fingerprint": null, "seed": "int main(){\n    //use double otherwise it will overflow\n    double m,n;\n    vector<double>top;\n    vector<double>bottom;\n    while(cin>>m>>n){\n        if(m==0&&n==0)\n            break;\n        if(n==0){\n            cout<<1<<endl;\n            continue;\n        }\n        n=min(n,m-n);\n        for(double i=0;i<n;i++){\n            top.push_back(m-i);\n            bottom.push_back(i+1);\n\n        }\n        for(int i=n-1;i>=0;i--){\n            for(int j=0;j<n;j++){\n                if((top[j]/bottom[i])==int(top[j]/bottom[i])){\n                    top[j]/=bottom[i];\n                    bottom[i]=1;\n                    break;\n                }\n            }\n        }\n        double ans=1,ans2=1;\n        for(int i=0;i<n;i++){\n            ans*=top[i];\n            ans2*=bottom[i];\n        }\n        cout<<int(ans/ans2)<<endl;\n        top.clear();\n        bottom.clear();\n    }\n\n\n\n\n\n\n\n\n    return 0;\n}", "id": 168, "concepts": ["pascal's triangle and binomial coefficient", "reducing unnecessary calculations", "handling corner cases"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 4\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 6\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 8\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 9\n### Snippet\nint main(int argc, char* argv[]) {\n\n    // g++ -I./include -o a.out  oddEvenLinkedList.cpp include/list_node.cpp -g\n    // createLink \u603b\u662f\u4e0ddelete\uff0c\u6240\u4ee5\uff0c\u5176\u5b9e\u8fd9\u4e2amain\u4f1a\u5185\u5b58\u6cc4\u9732\n    Solution *solu = new Solution();\n\n    cout << \"begin run:\" << endl;\n    ListNode *head = createLink(5);\n    echoList(head);\n    head = solu->oddEvenList(head);\n    echoList(head);\n\n    cout << \"---------------------------------\" << endl;\n    head = createLink(4);\n    echoList(head);\n    head = solu->oddEvenList(head);\n    echoList(head);\n\n    cout << \"---------------------------------\" << endl;\n    head = createLink(1);\n    echoList(head);\n    head = solu->oddEvenList(head);\n    echoList(head);\n\n}\n\n### Concepts", "fingerprint": null, "seed": "int main(int argc, char* argv[]) {\n\n    // g++ -I./include -o a.out  oddEvenLinkedList.cpp include/list_node.cpp -g\n    // createLink \u603b\u662f\u4e0ddelete\uff0c\u6240\u4ee5\uff0c\u5176\u5b9e\u8fd9\u4e2amain\u4f1a\u5185\u5b58\u6cc4\u9732\n    Solution *solu = new Solution();\n\n    cout << \"begin run:\" << endl;\n    ListNode *head = createLink(5);\n    echoList(head);\n    head = solu->oddEvenList(head);\n    echoList(head);\n\n    cout << \"---------------------------------\" << endl;\n    head = createLink(4);\n    echoList(head);\n    head = solu->oddEvenList(head);\n    echoList(head);\n\n    cout << \"---------------------------------\" << endl;\n    head = createLink(1);\n    echoList(head);\n    head = solu->oddEvenList(head);\n    echoList(head);\n\n}", "id": 169, "concepts": ["main function structure", "linked list creation and manipulation", "memory management"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 2\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 3\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 8\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 9\n### Snippet\nvoid bar(const Foo i) {\n    static Foo s3 = i + 1;\n    ++s3;\n}\n\n### Concepts", "fingerprint": null, "seed": "void bar(const Foo i) {\n    static Foo s3 = i + 1;\n    ++s3;\n}", "id": 170, "concepts": ["static variable initialization", "non-local variable modification", "function call order"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 2\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 4\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 7\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 9\n### Snippet\nvoid fast_poisson_solver_gpu(float *b, float *x, float *data2, float *data3, int Nx, int Ny, int Lx) \n{\n\tint i, j;\n\tfloat h, *lamda, *temp;\n\n\ttemp = (float *) malloc(Nx*Ny*sizeof(float));\n\tlamda = (float *) malloc(Nx*sizeof(float));\n\th = 1.0/(Nx+1);\n\n\t#pragma acc data create(lamda[0:Nx],temp[0:Nx*Ny]), present(b[0:Nx*Ny],x[0:Nx*Ny]) \n\t{\n\n\t\t#pragma acc parallel loop independent\n\t\tfor(i=0;i<Nx;i++)\n\t\t{\n\t\t\tlamda[i] = 2 - 2*cos((i+1)*M_PI*h);\n\t\t}\n\n\t\tfdst_gpu(b, data2, data3, Nx, Ny, Lx);\n\t\ttranspose(b, temp, Nx, Ny);\n\t\tfdst_gpu(temp, data2, data3, Nx, Ny, Lx);\n\t\ttranspose(temp, b, Ny, Nx);\n\n\t\t#pragma acc parallel loop independent\n\t\tfor(i=0;i<Ny;i++)\n\t\t{\n\t\t\t#pragma acc loop independent\n\t\t\tfor(j=0;j<Nx;j++)\n\t\t\t{\n\t\t\t\tx[Nx*i+j] = -b[Nx*i+j]/(lamda[i] + lamda[j]);\n\t\t\t}\n\t\t}\n\t\tfdst_gpu(x, data2, data3, Nx, Ny, Lx);\n\t\ttranspose(x, temp, Nx, Ny);\n\t\tfdst_gpu(temp, data2, data3, Nx, Ny, Lx);\n\t\ttranspose(temp, x, Ny, Nx);\n\t} // end data region\n}\n\n### Concepts", "fingerprint": null, "seed": "void fast_poisson_solver_gpu(float *b, float *x, float *data2, float *data3, int Nx, int Ny, int Lx) \n{\n\tint i, j;\n\tfloat h, *lamda, *temp;\n\n\ttemp = (float *) malloc(Nx*Ny*sizeof(float));\n\tlamda = (float *) malloc(Nx*sizeof(float));\n\th = 1.0/(Nx+1);\n\n\t#pragma acc data create(lamda[0:Nx],temp[0:Nx*Ny]), present(b[0:Nx*Ny],x[0:Nx*Ny]) \n\t{\n\n\t\t#pragma acc parallel loop independent\n\t\tfor(i=0;i<Nx;i++)\n\t\t{\n\t\t\tlamda[i] = 2 - 2*cos((i+1)*M_PI*h);\n\t\t}\n\n\t\tfdst_gpu(b, data2, data3, Nx, Ny, Lx);\n\t\ttranspose(b, temp, Nx, Ny);\n\t\tfdst_gpu(temp, data2, data3, Nx, Ny, Lx);\n\t\ttranspose(temp, b, Ny, Nx);\n\n\t\t#pragma acc parallel loop independent\n\t\tfor(i=0;i<Ny;i++)\n\t\t{\n\t\t\t#pragma acc loop independent\n\t\t\tfor(j=0;j<Nx;j++)\n\t\t\t{\n\t\t\t\tx[Nx*i+j] = -b[Nx*i+j]/(lamda[i] + lamda[j]);\n\t\t\t}\n\t\t}\n\t\tfdst_gpu(x, data2, data3, Nx, Ny, Lx);\n\t\ttranspose(x, temp, Nx, Ny);\n\t\tfdst_gpu(temp, data2, data3, Nx, Ny, Lx);\n\t\ttranspose(temp, x, Ny, Nx);\n\t} // end data region\n}", "id": 171, "concepts": ["fast Poisson solver implementation using the GPU", "parallel computing", "data transfer and management", "Fast Sine Transform"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 2\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 5\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 6\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 9\n### Snippet\nvoid read_command() {\n    network.read(in_header, &command_payload, sizeof(command_payload));\n    Serial.print(F(\"Received <- Header.From: 0\"));\n    Serial.print(in_header.from_node, OCT);\n    Serial.print(F(\" command: \"));\n    Serial.println(command_payload.command);\n    //Serial.print(F(\"  value: \"));\n    //Serial.println(command_payload.value);   \n    if (command_payload.command == 'R') {\n         Serial.println(F(\"\\r\\nGot reset command from Master!! \"));\n         Serial.println(F(\"\\nRestarting in 5 seconds.... \"));\n         delay(5000);\n         software_reset();\n    }\n}\n\n### Concepts", "fingerprint": null, "seed": "void read_command() {\n    network.read(in_header, &command_payload, sizeof(command_payload));\n    Serial.print(F(\"Received <- Header.From: 0\"));\n    Serial.print(in_header.from_node, OCT);\n    Serial.print(F(\" command: \"));\n    Serial.println(command_payload.command);\n    //Serial.print(F(\"  value: \"));\n    //Serial.println(command_payload.value);   \n    if (command_payload.command == 'R') {\n         Serial.println(F(\"\\r\\nGot reset command from Master!! \"));\n         Serial.println(F(\"\\nRestarting in 5 seconds.... \"));\n         delay(5000);\n         software_reset();\n    }\n}", "id": 172, "concepts": ["serial communication", "command parsing", "reset functionality"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 2\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 3\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 4\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 6\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 9\n### Snippet\nvoid p10(Node *h){\n\tNode *p = h;\n\twhile(p){\n\t\tNode *pn = p->next;\n\t\tif(pn == NULL || pn->c != '\\\"'){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n//\t\tcout<<\"p10\"<<endl;\n\t\tNode *node;\n\t\tnode = new Node(' ');\n\t\tp = insert(p,node);\n\t\tnode = new Node('\\'');\n\t\tp = insert(p,node);\n\t\tnode = new Node('\\'');\n\t\tp = insert(p,node);\n\t\tnode = new Node(' ');\n\t\tp = insert(p,node);\n\n\t\tdel(p);\n\t}\n}\n\n### Concepts", "fingerprint": null, "seed": "void p10(Node *h){\n\tNode *p = h;\n\twhile(p){\n\t\tNode *pn = p->next;\n\t\tif(pn == NULL || pn->c != '\\\"'){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n//\t\tcout<<\"p10\"<<endl;\n\t\tNode *node;\n\t\tnode = new Node(' ');\n\t\tp = insert(p,node);\n\t\tnode = new Node('\\'');\n\t\tp = insert(p,node);\n\t\tnode = new Node('\\'');\n\t\tp = insert(p,node);\n\t\tnode = new Node(' ');\n\t\tp = insert(p,node);\n\n\t\tdel(p);\n\t}\n}", "id": 173, "concepts": ["string manipulation", "pointer manipulation", "node insertion", "node deletion"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 6\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 7\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 8\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 9\n### Snippet\nint main() {\n    for (int i = 0; i < 100; ++i) {\n        pid_t pid = fork();\n        if (pid == -1) {\n            std::cout << \"Failed to fork (i = \" << i << \"): \" << strerror(errno) << std::endl;\n            break;\n        }\n        if (pid == 0) {\n            sleep(1);\n            return 0;\n        }\n    }\n    return 0;\n}\n\n### Concepts", "fingerprint": null, "seed": "int main() {\n    for (int i = 0; i < 100; ++i) {\n        pid_t pid = fork();\n        if (pid == -1) {\n            std::cout << \"Failed to fork (i = \" << i << \"): \" << strerror(errno) << std::endl;\n            break;\n        }\n        if (pid == 0) {\n            sleep(1);\n            return 0;\n        }\n    }\n    return 0;\n}", "id": 174, "concepts": ["fork system call", "process creation", "error handling", "optimization in system calls"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 2\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 5\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 6\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 7\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 9\n### Snippet\nvoid loop() {\n    //LECTURA DE ESTADOS\n    isDoorOpen = digitalRead(pinDoor);\n    hasDetection = !digitalRead(pinSensor);\n    isRinging = !digitalRead(pinDoorBell);\n\n\n    //MOSTRAR INFO EN LED\n    if (isRinging==true) {\n      ledToggle(\"on\");\n    } else {\n      ledToggle(\"off\");\n    }\n\n/*\n    //MOSTRAR INFO EN LED\n    if (isDoorOpen==true) {\n      ledToggle(\"on\");\n    } else {\n      ledToggle(\"off\");\n    }\n\n    //MOSTRAR INFO EN LED\n    if (hasDetection==true) {\n      ledToggle(\"on\");\n    } else {\n      ledToggle(\"off\");\n    }\n*/\n\n\n}\n\n### Concepts", "fingerprint": null, "seed": "void loop() {\n    //LECTURA DE ESTADOS\n    isDoorOpen = digitalRead(pinDoor);\n    hasDetection = !digitalRead(pinSensor);\n    isRinging = !digitalRead(pinDoorBell);\n\n\n    //MOSTRAR INFO EN LED\n    if (isRinging==true) {\n      ledToggle(\"on\");\n    } else {\n      ledToggle(\"off\");\n    }\n\n/*\n    //MOSTRAR INFO EN LED\n    if (isDoorOpen==true) {\n      ledToggle(\"on\");\n    } else {\n      ledToggle(\"off\");\n    }\n\n    //MOSTRAR INFO EN LED\n    if (hasDetection==true) {\n      ledToggle(\"on\");\n    } else {\n      ledToggle(\"off\");\n    }\n*/\n\n\n}", "id": 175, "concepts": ["state reading and processing", "if-else statements for conditional logic", "boolean logic", "function calling"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 2\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 4\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 5\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 8\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 9\n### Snippet\nint main(){\n\n\n\n    while(~scanf(\"%d\",&N)){\n\n        for(int i=1;i<=N;i++)\n                scanf(\"%d\",&a[i]);\n\n\n        sort(a+1,a+N+1);\n\n\n        dp[1]=a[1];\n        dp[2]=a[2];\n\n\n        for(int i=3;i<=N;i++)\n             dp[i]=min(dp[i-1] + a[1] + a[i],dp[i-2] + a[1] + a[i] + 2*a[2]);\n\n\n        printf(\"%d\\n\",dp[N]);\n\n\n    }\n\n\n    return 0;\n}\n\n### Concepts", "fingerprint": null, "seed": "int main(){\n\n\n\n    while(~scanf(\"%d\",&N)){\n\n        for(int i=1;i<=N;i++)\n                scanf(\"%d\",&a[i]);\n\n\n        sort(a+1,a+N+1);\n\n\n        dp[1]=a[1];\n        dp[2]=a[2];\n\n\n        for(int i=3;i<=N;i++)\n             dp[i]=min(dp[i-1] + a[1] + a[i],dp[i-2] + a[1] + a[i] + 2*a[2]);\n\n\n        printf(\"%d\\n\",dp[N]);\n\n\n    }\n\n\n    return 0;\n}", "id": 176, "concepts": ["dynamic programming", "greedy algorithm", "minimum cost calculation", "sorting"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 2\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 5\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 7\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 8\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 9\n### Snippet\nvoid send_status() {\n    if (SIMULATION) {\n        status_payload.occupied = random(0,2);  // [min, max)\n        status_payload.temperature = random(0, 40);\n        status_payload.humidity = random(0,100);    \n    }\n    else {\n        status_payload.occupied = occupied;\n        status_payload.temperature = temperature;\n        status_payload.humidity = humidity;  \n    }\n    // TODO: disable this for production\n    Serial.print(status_payload.occupied ? \"Occupied, \" : \"Free, \"); \n    Serial.print(status_payload.temperature); \n    Serial.print(F(\", \"));\n    Serial.print(status_payload.humidity);  \n       \n    result = mesh.write(&status_payload, 'S', sizeof(status_payload));\n    if (result)  \n        Serial.println();\n    else \n        Serial.println(F(\"  (Send failed)*\"));\n}\n\n### Concepts", "fingerprint": null, "seed": "void send_status() {\n    if (SIMULATION) {\n        status_payload.occupied = random(0,2);  // [min, max)\n        status_payload.temperature = random(0, 40);\n        status_payload.humidity = random(0,100);    \n    }\n    else {\n        status_payload.occupied = occupied;\n        status_payload.temperature = temperature;\n        status_payload.humidity = humidity;  \n    }\n    // TODO: disable this for production\n    Serial.print(status_payload.occupied ? \"Occupied, \" : \"Free, \"); \n    Serial.print(status_payload.temperature); \n    Serial.print(F(\", \"));\n    Serial.print(status_payload.humidity);  \n       \n    result = mesh.write(&status_payload, 'S', sizeof(status_payload));\n    if (result)  \n        Serial.println();\n    else \n        Serial.println(F(\"  (Send failed)*\"));\n}", "id": 177, "concepts": ["conditional logic for simulation and production", "random number generation for simulation", "status payload population", "transmission of status payload", "error handling for transmission failure", "debugging output"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 5\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 7\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 8\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 9\n### Snippet\nvoid fpcM_Draw(void* pProc) {\n    fpcDw_Execute((base_process_class*)pProc);\n}\n\n### Concepts", "fingerprint": null, "seed": "void fpcM_Draw(void* pProc) {\n    fpcDw_Execute((base_process_class*)pProc);\n}", "id": 178, "concepts": ["function pointer call", "type casting", "process execution"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 3\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 4\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 5\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 8\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 9\n### Snippet\nvoid Myswap(Priority &ob1,Priority &ob2)\n{\n\tPriority temp;\n\ttemp =ob1;\n\tob1=ob2;\n\tob2=temp;\n}\n\n### Concepts", "fingerprint": null, "seed": "void Myswap(Priority &ob1,Priority &ob2)\n{\n\tPriority temp;\n\ttemp =ob1;\n\tob1=ob2;\n\tob2=temp;\n}", "id": 179, "concepts": ["swapping of two objects", "temporary variable creation", "assignment operator overloading"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 5\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 7\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 8\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 9\n### Snippet\nint main()\n{\n    int n;\n    cin>>n;\n\n    int arr[n];\n    for(int i=0;i<n;i++)\n    {\n        cin>>arr[i];\n    }\n    int q;\n    cin>>q;\n    while(q--)\n    {\n    int l,r;\n    cin>>l>>r;\n    int result=arr[l];\n    for(int i=l+1;i<=r;i++)\n    {\n        result = gcd(arr[i],result);\n    }\n    cout<<result<<endl;\n    }\n    return(0);\n}\n\n### Concepts", "fingerprint": null, "seed": "int main()\n{\n    int n;\n    cin>>n;\n\n    int arr[n];\n    for(int i=0;i<n;i++)\n    {\n        cin>>arr[i];\n    }\n    int q;\n    cin>>q;\n    while(q--)\n    {\n    int l,r;\n    cin>>l>>r;\n    int result=arr[l];\n    for(int i=l+1;i<=r;i++)\n    {\n        result = gcd(arr[i],result);\n    }\n    cout<<result<<endl;\n    }\n    return(0);\n}", "id": 180, "concepts": ["gcd computation using euclid's algorithm", "iterative approach for range query", "prefix array for faster gcd computation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 4\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 5\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 6\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 9\n### Snippet\nint main(int argc, char const *argv[]){\n    int a, b, c, d;\n    scanf(\"%d %d %d %d\",&a, &b, &c, &d);\n\n    if(a*b >= c*d){\n        printf(\"%d\\n\", a*b);\n    }\n    else{\n        printf(\"%d\\n\", c*d);\n    }\n    return 0;\n}\n\n### Concepts", "fingerprint": null, "seed": "int main(int argc, char const *argv[]){\n    int a, b, c, d;\n    scanf(\"%d %d %d %d\",&a, &b, &c, &d);\n\n    if(a*b >= c*d){\n        printf(\"%d\\n\", a*b);\n    }\n    else{\n        printf(\"%d\\n\", c*d);\n    }\n    return 0;\n}", "id": 181, "concepts": ["conditional check for the maximum product", "input parsing with scanf"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 3\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 5\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 6\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 7\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 9\n### Snippet\nint main (int argc, char** argv)\n{\n\tchar * hostName;\n\tif (argc > 1)\n\t\thostName = argv[1];\n\telse return -1;\n\t/*\n\thostent* node = gethostbyname(hostName);\n\tservent* service = getservbyname(hostName, NULL);\n*/\n\tstruct addrinfo* res;\n\tstruct addrinfo hints;\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = AF_UNSPEC;\n\n\tint success = getaddrinfo(argv[1], 0, &hints, &res);\n\tif (success != 0) return success;\n\n\tfor (struct addrinfo* p = res; p != NULL; p = p->ai_next)\n\t{\n\t\tchar host[NI_MAXHOST];\n\n\t\tgetnameinfo(p->ai_addr, p->ai_addrlen, host, NI_MAXHOST, 0, 0, NI_NUMERICHOST);\n\n\t\tstd::cout<< host << \" \" << p->ai_family << \" \"<< p->ai_socktype << std::endl;\n\t}\n\n\tfreeaddrinfo(res);\n\n\treturn 0;\n}\n\n### Concepts", "fingerprint": null, "seed": "int main (int argc, char** argv)\n{\n\tchar * hostName;\n\tif (argc > 1)\n\t\thostName = argv[1];\n\telse return -1;\n\t/*\n\thostent* node = gethostbyname(hostName);\n\tservent* service = getservbyname(hostName, NULL);\n*/\n\tstruct addrinfo* res;\n\tstruct addrinfo hints;\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = AF_UNSPEC;\n\n\tint success = getaddrinfo(argv[1], 0, &hints, &res);\n\tif (success != 0) return success;\n\n\tfor (struct addrinfo* p = res; p != NULL; p = p->ai_next)\n\t{\n\t\tchar host[NI_MAXHOST];\n\n\t\tgetnameinfo(p->ai_addr, p->ai_addrlen, host, NI_MAXHOST, 0, 0, NI_NUMERICHOST);\n\n\t\tstd::cout<< host << \" \" << p->ai_family << \" \"<< p->ai_socktype << std::endl;\n\t}\n\n\tfreeaddrinfo(res);\n\n\treturn 0;\n}", "id": 182, "concepts": ["command-line arguments parsing", "host name resolution", "address information retrieval", "error handling with return codes", "socket programming"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 3\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 6\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 9\n### Snippet\nvoid p9(Node *h){\n\tNode *p = h;\n\tNode *node = new Node(' ');\n\tp = insert(p,node);\n\twhile(p->next){\n\t\tp = p->next;\n\t}\n\tnode = new Node(' ');\n\tp = insert(p, node);\n}\n\n### Concepts", "fingerprint": null, "seed": "void p9(Node *h){\n\tNode *p = h;\n\tNode *node = new Node(' ');\n\tp = insert(p,node);\n\twhile(p->next){\n\t\tp = p->next;\n\t}\n\tnode = new Node(' ');\n\tp = insert(p, node);\n}", "id": 183, "concepts": ["linked list insertion", "memory management", "pointer manipulation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 2\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 5\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 6\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 9\n### Snippet\nint main()\n{\n    int n;\n    cin >>n;\n    int a[n];\n    int mx=INT_MIN;\n    int mn=INT_MAX;\n    for(int i=0;i<n;i++){\n        cin >>a[i];\n        mx=max(mx,a[i]);\n        mn=min(mn,a[i]);\n    }\n    int mnI,mxI;\n    for(int i=0;i<n;i++){\n        if(mx==a[i]){mxI=i;}\n        if(mn==a[i]){mnI=i;}\n    }\n    int ans;\n    if(mnI>mxI){\n       ans=max(mnI,n-1-mxI);\n    }\n    else{\n        ans=max(mxI,n-1-mnI);\n    }\n    cout <<ans<<endl;\n    return 0;\n\n}\n\n### Concepts", "fingerprint": null, "seed": "int main()\n{\n    int n;\n    cin >>n;\n    int a[n];\n    int mx=INT_MIN;\n    int mn=INT_MAX;\n    for(int i=0;i<n;i++){\n        cin >>a[i];\n        mx=max(mx,a[i]);\n        mn=min(mn,a[i]);\n    }\n    int mnI,mxI;\n    for(int i=0;i<n;i++){\n        if(mx==a[i]){mxI=i;}\n        if(mn==a[i]){mnI=i;}\n    }\n    int ans;\n    if(mnI>mxI){\n       ans=max(mnI,n-1-mxI);\n    }\n    else{\n        ans=max(mxI,n-1-mnI);\n    }\n    cout <<ans<<endl;\n    return 0;\n\n}", "id": 184, "concepts": ["array traversal and indexing", "minimum and maximum value tracking", "edge case handling"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 2\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 4\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 6\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 8\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 9\n### Snippet\nvoid swith_off()                                              // Function to switch off relays\n{\n    Serial.println(\"Switching off Relay 1 now..\");\n    digitalWrite(RELAY_PIN_1, HIGH);                // Turnoff Relay 1\n    Serial.println(\"Relay 1 OFF..\");       \n    Blynk.virtualWrite(VPIN_BUTTON_1, HIGH);        // Update Relay Off status on Blynk app   \n\n    Serial.println(\"Switching off Relay 2 now..\");\n    digitalWrite(RELAY_PIN_2, HIGH);                // Turnoff Relay 2\n    Serial.println(\"Relay 2 OFF..\");       \n    Blynk.virtualWrite(VPIN_BUTTON_2, HIGH);        // Update Relay Off status on Blynk app   \n}\n\n### Concepts", "fingerprint": null, "seed": "void swith_off()                                              // Function to switch off relays\n{\n    Serial.println(\"Switching off Relay 1 now..\");\n    digitalWrite(RELAY_PIN_1, HIGH);                // Turnoff Relay 1\n    Serial.println(\"Relay 1 OFF..\");       \n    Blynk.virtualWrite(VPIN_BUTTON_1, HIGH);        // Update Relay Off status on Blynk app   \n\n    Serial.println(\"Switching off Relay 2 now..\");\n    digitalWrite(RELAY_PIN_2, HIGH);                // Turnoff Relay 2\n    Serial.println(\"Relay 2 OFF..\");       \n    Blynk.virtualWrite(VPIN_BUTTON_2, HIGH);        // Update Relay Off status on Blynk app   \n}", "id": 185, "concepts": ["I/O pin control", "serial communication", "Blynk library usage"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 4\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 5\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 7\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 9\n### Snippet\nvoid solve()\n{\n    cin>>n;\n    ll arr[n];\n    for(ll i=0;i<n;i++)\n        cin>>arr[i];\n    dfs(0,0,arr);\n   // cout<<41243431;\n    map<ll,ll>::iterator itr;\n    for(itr=st.begin();itr!=st.end();itr++)\n    {\n        while(itr->second!=0)\n        {\n            cout<<itr->first<<\" \";\n            itr->second--;\n        }\n    }\n    cout<<endl;\n}\n\n### Concepts", "fingerprint": null, "seed": "void solve()\n{\n    cin>>n;\n    ll arr[n];\n    for(ll i=0;i<n;i++)\n        cin>>arr[i];\n    dfs(0,0,arr);\n   // cout<<41243431;\n    map<ll,ll>::iterator itr;\n    for(itr=st.begin();itr!=st.end();itr++)\n    {\n        while(itr->second!=0)\n        {\n            cout<<itr->first<<\" \";\n            itr->second--;\n        }\n    }\n    cout<<endl;\n}", "id": 186, "concepts": ["recursive backtracking", "depth-first search", "state space traversal", "solution space exploration"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 3\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 4\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 7\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 8\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 9\n### Snippet\nvoid printList (const Park parks[], int length)\n{\n  for (int i = 0; i < length; i++)\n  {\n    cout << parks[i].parkname << \" [\" << parks[i].state << \"] area: \" << parks[i].area << endl;\n  }\n}\n\n### Concepts", "fingerprint": null, "seed": "void printList (const Park parks[], int length)\n{\n  for (int i = 0; i < length; i++)\n  {\n    cout << parks[i].parkname << \" [\" << parks[i].state << \"] area: \" << parks[i].area << endl;\n  }\n}", "id": 187, "concepts": ["looping through an array of structures", "accessing individual fields", "printing formatted output"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 5\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 7\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 8\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 9\n### Snippet\nfloat Error(float *x, float *u, int Nx) \n{ \n\t// return max_i |x[i] - u[i]| \n\tint i, j; \n\tfloat v, e; \n\tv = 0.0; \n\t\n\tfor(i=0;i<Nx;++i) \n\t{ \n\t\tfor(j=0;j<Nx;j++) \n\t\t{ \n\t\t\te = fabs(x[Nx*i+j] - u[Nx*i+j]); \n\t\t\tif(e > v) v = e;\n\t\t\t//v = max(v, e); \n\t\t} \n\t} \n\treturn v; \n}\n\n### Concepts", "fingerprint": null, "seed": "float Error(float *x, float *u, int Nx) \n{ \n\t// return max_i |x[i] - u[i]| \n\tint i, j; \n\tfloat v, e; \n\tv = 0.0; \n\t\n\tfor(i=0;i<Nx;++i) \n\t{ \n\t\tfor(j=0;j<Nx;j++) \n\t\t{ \n\t\t\te = fabs(x[Nx*i+j] - u[Nx*i+j]); \n\t\t\tif(e > v) v = e;\n\t\t\t//v = max(v, e); \n\t\t} \n\t} \n\treturn v; \n}", "id": 188, "concepts": ["matrix difference calculation", "maximum absolute difference", "vectorization"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 4\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 6\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 7\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 8\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 9\n### Snippet\nint main(int argc, char* argv) {\n\tMat src = imread(\"lena.jpg\");\n\tMat gsrc;\n\tMat lsrc;\n\n\tpyrDown(src, gsrc);//\u9ad8\u65af\u91d1\u5b57\u5854  \u6210\u500d\u5411\u4e0b\u91c7\u6837\n\tpyrUp(src, lsrc);//\u62c9\u666e\u62c9\u65af\u91d1\u5b57\u5854 \u5411\u4e0a\u91c7\u6837\n\n\tnamedWindow(\"src\");\n\tmoveWindow(\"src\", 0, 0);\n\tnamedWindow(\"gsrc\");\n\tmoveWindow(\"gsrc\", 512, 0);\n\tnamedWindow(\"lsrc\");\n\tmoveWindow(\"lsrc\", 0, 512);\n\n\timshow(\"src\", src);\n\timshow(\"gsrc\", gsrc);\n\timshow(\"lsrc\", lsrc);\n\n\twaitKey(0);\n\n\treturn 0;\n}\n\n### Concepts", "fingerprint": null, "seed": "int main(int argc, char* argv) {\n\tMat src = imread(\"lena.jpg\");\n\tMat gsrc;\n\tMat lsrc;\n\n\tpyrDown(src, gsrc);//\u9ad8\u65af\u91d1\u5b57\u5854  \u6210\u500d\u5411\u4e0b\u91c7\u6837\n\tpyrUp(src, lsrc);//\u62c9\u666e\u62c9\u65af\u91d1\u5b57\u5854 \u5411\u4e0a\u91c7\u6837\n\n\tnamedWindow(\"src\");\n\tmoveWindow(\"src\", 0, 0);\n\tnamedWindow(\"gsrc\");\n\tmoveWindow(\"gsrc\", 512, 0);\n\tnamedWindow(\"lsrc\");\n\tmoveWindow(\"lsrc\", 0, 512);\n\n\timshow(\"src\", src);\n\timshow(\"gsrc\", gsrc);\n\timshow(\"lsrc\", lsrc);\n\n\twaitKey(0);\n\n\treturn 0;\n}", "id": 189, "concepts": ["image processing", "downsampling", "upsampling", "Gaussian pyramid", "Laplacian pyramid"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 6\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 7\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 9\n### Snippet\nvoid pzemdevice1()                                                            // Function to get PZEM device 1 data\n{\n  Serial.println(\"====================================================\");     // PZEM Device 1 data fetching code starts here\n  Serial.println(\"Now checking PZEM Device 1\");\n  uint8_t result1;\n\n  ESP.wdtDisable();                                                           // Disable watchdog during modbus read or else ESP crashes when no slave connected\n  result1 = node1.readInputRegisters(0x0000, 10);\n  ESP.wdtEnable(1);                                                           // Enable watchdog during modbus read\n\n  if (result1 == node1.ku8MBSuccess)\n  {\n    voltage_usage_1      = (node1.getResponseBuffer(0x00) / 10.0f);\n    current_usage_1      = (node1.getResponseBuffer(0x01) / 1000.000f);\n    active_power_1       = (node1.getResponseBuffer(0x03) / 10.0f);\n    active_energy_1      = (node1.getResponseBuffer(0x05) / 1000.0f);\n    frequency_1          = (node1.getResponseBuffer(0x07) / 10.0f);\n    power_factor_1       = (node1.getResponseBuffer(0x08) / 100.0f);\n\n    Serial.print(\"VOLTAGE:           \");   Serial.println(voltage_usage_1);       // V\n    Serial.print(\"CURRENT_USAGE:     \");   Serial.println(current_usage_1, 3);    // A\n    Serial.print(\"ACTIVE_POWER:      \");   Serial.println(active_power_1);        // W\n    Serial.print(\"ACTIVE_ENERGY:     \");   Serial.println(active_energy_1, 3);    // kWh\n    Serial.print(\"FREQUENCY:         \");   Serial.println(frequency_1);           // Hz\n    Serial.print(\"POWER_FACTOR:      \");   Serial.println(power_factor_1);\n    Serial.println(\"====================================================\");\n  }\n  else {\n    Serial.println(\"Failed to read PZEM Device 1\");\n    Serial.println(\"PZEM Device 1 Data\");\n    voltage_usage_1      = 0;\n    current_usage_1      = 0;\n    active_power_1       = 0;\n    active_energy_1      = 0;\n    frequency_1          = 0;\n    power_factor_1       = 0;\n\n    Serial.print(\"VOLTAGE:           \");   Serial.println(voltage_usage_1);       // V\n    Serial.print(\"CURRENT_USAGE:     \");   Serial.println(current_usage_1, 3);    // A\n    Serial.print(\"ACTIVE_POWER:      \");   Serial.println(active_power_1);        // W\n    Serial.print(\"ACTIVE_ENERGY:     \");   Serial.println(active_energy_1, 3);    // kWh\n    Serial.print(\"FREQUENCY:         \");   Serial.println(frequency_1);           // Hz\n    Serial.print(\"POWER_FACTOR:      \");   Serial.println(power_factor_1);\n    Serial.println(\"====================================================\");\n    swith_off();                                                                  // Calling swith_off() to turn off relays\n  }\n}\n\n### Concepts", "fingerprint": null, "seed": "void pzemdevice1()                                                            // Function to get PZEM device 1 data\n{\n  Serial.println(\"====================================================\");     // PZEM Device 1 data fetching code starts here\n  Serial.println(\"Now checking PZEM Device 1\");\n  uint8_t result1;\n\n  ESP.wdtDisable();                                                           // Disable watchdog during modbus read or else ESP crashes when no slave connected\n  result1 = node1.readInputRegisters(0x0000, 10);\n  ESP.wdtEnable(1);                                                           // Enable watchdog during modbus read\n\n  if (result1 == node1.ku8MBSuccess)\n  {\n    voltage_usage_1      = (node1.getResponseBuffer(0x00) / 10.0f);\n    current_usage_1      = (node1.getResponseBuffer(0x01) / 1000.000f);\n    active_power_1       = (node1.getResponseBuffer(0x03) / 10.0f);\n    active_energy_1      = (node1.getResponseBuffer(0x05) / 1000.0f);\n    frequency_1          = (node1.getResponseBuffer(0x07) / 10.0f);\n    power_factor_1       = (node1.getResponseBuffer(0x08) / 100.0f);\n\n    Serial.print(\"VOLTAGE:           \");   Serial.println(voltage_usage_1);       // V\n    Serial.print(\"CURRENT_USAGE:     \");   Serial.println(current_usage_1, 3);    // A\n    Serial.print(\"ACTIVE_POWER:      \");   Serial.println(active_power_1);        // W\n    Serial.print(\"ACTIVE_ENERGY:     \");   Serial.println(active_energy_1, 3);    // kWh\n    Serial.print(\"FREQUENCY:         \");   Serial.println(frequency_1);           // Hz\n    Serial.print(\"POWER_FACTOR:      \");   Serial.println(power_factor_1);\n    Serial.println(\"====================================================\");\n  }\n  else {\n    Serial.println(\"Failed to read PZEM Device 1\");\n    Serial.println(\"PZEM Device 1 Data\");\n    voltage_usage_1      = 0;\n    current_usage_1      = 0;\n    active_power_1       = 0;\n    active_energy_1      = 0;\n    frequency_1          = 0;\n    power_factor_1       = 0;\n\n    Serial.print(\"VOLTAGE:           \");   Serial.println(voltage_usage_1);       // V\n    Serial.print(\"CURRENT_USAGE:     \");   Serial.println(current_usage_1, 3);    // A\n    Serial.print(\"ACTIVE_POWER:      \");   Serial.println(active_power_1);        // W\n    Serial.print(\"ACTIVE_ENERGY:     \");   Serial.println(active_energy_1, 3);    // kWh\n    Serial.print(\"FREQUENCY:         \");   Serial.println(frequency_1);           // Hz\n    Serial.print(\"POWER_FACTOR:      \");   Serial.println(power_factor_1);\n    Serial.println(\"====================================================\");\n    swith_off();                                                                  // Calling swith_off() to turn off relays\n  }\n}", "id": 190, "concepts": ["modbus communication", "serial communication", "error handling with result codes", "real-time monitoring and control"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 3\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 5\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 6\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 8\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 9\n### Snippet\nint main()\n{\n#pragma region \"Bubble Sort\"\n\tchar word[] = { \"TOLEARNSORTALGORITHMK\" };\n\n\tprintf( \"%s\\n\", word );\n\n\tBubbleSort( word, strlen( word ) );\n\t\n\tprintf( \"%s\\n\", word );\n#pragma endregion\n\treturn 0;\n}\n\n### Concepts", "fingerprint": null, "seed": "int main()\n{\n#pragma region \"Bubble Sort\"\n\tchar word[] = { \"TOLEARNSORTALGORITHMK\" };\n\n\tprintf( \"%s\\n\", word );\n\n\tBubbleSort( word, strlen( word ) );\n\t\n\tprintf( \"%s\\n\", word );\n#pragma endregion\n\treturn 0;\n}", "id": 191, "concepts": ["code snippet", "sorting", "bubble sort", "string", "algorithm", "sorting algorithm"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 5\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 6\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 7\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 9\n### Snippet\nvoid chatterCallback(const std_msgs::String::ConstPtr& msg){\n     ROS_INFO(\"I got:[%s]\",msg->data.c_str());\n\n}\n\n### Concepts", "fingerprint": null, "seed": "void chatterCallback(const std_msgs::String::ConstPtr& msg){\n     ROS_INFO(\"I got:[%s]\",msg->data.c_str());\n\n}", "id": 192, "concepts": ["chatter callback function definition", "message reception", "message logging"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 5\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 6\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 8\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 9\n### Snippet\nint main()\n{\n    const int size = 30005;\n    int n, m, max = 0;\n    scanf(\"%d\",&n);\n    int p[size];\n    for (int i = 0; i < size; i++)\n    {\n        p[i] = 0;\n    }\n    while (n--)\n    {\n        scanf(\"%d\",&m);\n        p[m] ++;\n    }\n    for (int i = 0; i < size; i++)\n    {\n        max = p[i] > max ? p[i] : max;\n    }\n    for (int i = 0; i < size; i++)\n    {\n        if(p[i] == max)\n        {\n            printf(\"%d %d\\n\",i,p[i]);\n        }\n    }\n    return 0;\n}\n\n### Concepts", "fingerprint": null, "seed": "int main()\n{\n    const int size = 30005;\n    int n, m, max = 0;\n    scanf(\"%d\",&n);\n    int p[size];\n    for (int i = 0; i < size; i++)\n    {\n        p[i] = 0;\n    }\n    while (n--)\n    {\n        scanf(\"%d\",&m);\n        p[m] ++;\n    }\n    for (int i = 0; i < size; i++)\n    {\n        max = p[i] > max ? p[i] : max;\n    }\n    for (int i = 0; i < size; i++)\n    {\n        if(p[i] == max)\n        {\n            printf(\"%d %d\\n\",i,p[i]);\n        }\n    }\n    return 0;\n}", "id": 193, "concepts": ["fast input/output using scanf/printf", "array size optimization", "frequency calculation and max frequency tracking"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 4\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 6\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 7\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 9\n### Snippet\nvoid p15(Node *h){\n\tNode *p = h;\n\twhile(p->next){\n\t\tif((p->next)->c == ' ') del(p);\n\t\telse break;\n\t}\n//\tcout<<\"p15\"<<endl;\n\twhile(p){\n\t\tif(p->c == ' '){\n\t\t\twhile(p->next){\n\t\t\t\tif((p->next)->c == ' ') del(p);\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t\tp = p->next;\n\t}\n}\n\n### Concepts", "fingerprint": null, "seed": "void p15(Node *h){\n\tNode *p = h;\n\twhile(p->next){\n\t\tif((p->next)->c == ' ') del(p);\n\t\telse break;\n\t}\n//\tcout<<\"p15\"<<endl;\n\twhile(p){\n\t\tif(p->c == ' '){\n\t\t\twhile(p->next){\n\t\t\t\tif((p->next)->c == ' ') del(p);\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n\t\tp = p->next;\n\t}\n}", "id": 194, "concepts": ["deletion in a linked list", "skipping over spaces", "edge case handling"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 3\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 6\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 9\n### Snippet\nvoid low_voltage_check()\n{\n  if(voltage_usage_1 == 0 || voltage_usage_2 == 0 || voltage_usage_3 == 0){\n    Serial.println(\"Phase failure detected...\");\n    phasefailureflag = true;\n    phasefailurenotification();\n  } else if(voltage_usage_1 < LOW_VOLTAGE_1_CUTOFF || voltage_usage_2 < LOW_VOLTAGE_2_CUTOFF || voltage_usage_3 < LOW_VOLTAGE_3_CUTOFF){\n    Serial.println(\"Low voltage detected...\");\n    lowvoltageflag = true;\n    swith_off();\n    low_volt_alert();\n  } else {\n      Serial.println(\"Voltage back to normal\");\n      lowvoltagenotificationflag = true;\n      phasefailurenotificationflag = true;\n      lowvoltageflag = false;\n      phasefailureflag = false;      \n  }\n}\n\n### Concepts", "fingerprint": null, "seed": "void low_voltage_check()\n{\n  if(voltage_usage_1 == 0 || voltage_usage_2 == 0 || voltage_usage_3 == 0){\n    Serial.println(\"Phase failure detected...\");\n    phasefailureflag = true;\n    phasefailurenotification();\n  } else if(voltage_usage_1 < LOW_VOLTAGE_1_CUTOFF || voltage_usage_2 < LOW_VOLTAGE_2_CUTOFF || voltage_usage_3 < LOW_VOLTAGE_3_CUTOFF){\n    Serial.println(\"Low voltage detected...\");\n    lowvoltageflag = true;\n    swith_off();\n    low_volt_alert();\n  } else {\n      Serial.println(\"Voltage back to normal\");\n      lowvoltagenotificationflag = true;\n      phasefailurenotificationflag = true;\n      lowvoltageflag = false;\n      phasefailureflag = false;      \n  }\n}", "id": 195, "concepts": ["voltage measurement", "failure detection", "notification and response"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 3\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 4\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 7\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 8\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 9\n### Snippet\nvoid BubbleSort( char* target, size_t count )\n{\n\tfor ( size_t i = 0; i < count - 1; ++i )\n\t{\n\t\tfor ( size_t j = 1; j < count - i; ++j )\n\t\t{\n\t\t\tif ( target[ j - 1 ] > target[ j ] )\n\t\t\t{\n\t\t\t\tchar temp = target[ j ];\n\t\t\t\ttarget[ j ] = target[ j - 1 ];\n\t\t\t\ttarget[ j - 1 ] = temp;\n\t\t\t}\n\t\t}\n\t}\n}\n\n### Concepts", "fingerprint": null, "seed": "void BubbleSort( char* target, size_t count )\n{\n\tfor ( size_t i = 0; i < count - 1; ++i )\n\t{\n\t\tfor ( size_t j = 1; j < count - i; ++j )\n\t\t{\n\t\t\tif ( target[ j - 1 ] > target[ j ] )\n\t\t\t{\n\t\t\t\tchar temp = target[ j ];\n\t\t\t\ttarget[ j ] = target[ j - 1 ];\n\t\t\t\ttarget[ j - 1 ] = temp;\n\t\t\t}\n\t\t}\n\t}\n}", "id": 196, "concepts": ["bubble sort algorithm", "in-place sorting", "comparison-based sorting", "worst-case time complexity of O(n^2)"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 3\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 5\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 7\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 9\n### Snippet\nint main()\r\n{\r\n\tList<int> l1;\r\n\tl1.PushBack(1);\r\n\tl1.PushBack(2);\r\n\tl1.PushBack(3);\r\n\tl1.PushBack(4);\r\n\tl1.PrintList();\r\n    return 0;\r\n}\n\n### Concepts", "fingerprint": null, "seed": "int main()\r\n{\r\n\tList<int> l1;\r\n\tl1.PushBack(1);\r\n\tl1.PushBack(2);\r\n\tl1.PushBack(3);\r\n\tl1.PushBack(4);\r\n\tl1.PrintList();\r\n    return 0;\r\n}", "id": 197, "concepts": ["linked list implementation", "push and pop operations", "print method"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 2\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 3\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 6\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 9\n### Snippet\nvoid p5(Node *h){\n\tNode *p = h;\n\twhile(p){\n\t\tNode *pn = p->next;\n\t\tif(pn == NULL || pn->c == '.'){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tNode *pnn = pn->next;\n\t\tif(pnn == NULL || pnn->c != '.'){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tNode *pnnn = pnn->next;\n\t\tif(pnnn == NULL){\n//\t\t\tcout<<\"p5_1 \"<<p->c<<endl;\n\t\t\tNode *node;\n\t\t\tnode = new Node(' ');\n\t\t\tpn = insert(pn,node);\n\t\t\tnode = new Node(' ');\n\t\t\tpnn = insert(pnn,node);\n\t\t\tbreak;\n\t\t}\n\t\tNode *p1 = pnnn;\n\t\twhile(p1){\n\t\t\tif(p1->c != ']' &&\n\t\t\t   p1->c != ')' &&\n\t\t\t   p1->c != '}' &&\n\t\t\t   p1->c != '>' &&\n\t\t\t   p1->c != '\\\"'&&\n\t\t\t   p1->c != '\\'')\n\t\t\t\tbreak;\n\t\t\tp1 = p1->next;\n\t\t}\n\t\tNode *p2 = p1;\n\t\twhile(p2){\n\t\t\tif(p2->c != ' ' && p2->c != '\\t')\n\t\t\t\tbreak;\n\t\t\tp2 = p2->next;\n\t\t}\n\t\tif(p2){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n//\t\tcout<<\"p5_3\"<<endl;\n\t\tNode* node;\n\t\tnode = new Node(' ');\n\t\tpn = insert(pn, node);\n\t\tnode = new Node(' ');\n\t\tp1->c = ' ';\n\t\tclean_List(p1->next);\n\t\tp1->next = NULL;\n\t\tbreak;\n\t}\n}\n\n### Concepts", "fingerprint": null, "seed": "void p5(Node *h){\n\tNode *p = h;\n\twhile(p){\n\t\tNode *pn = p->next;\n\t\tif(pn == NULL || pn->c == '.'){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tNode *pnn = pn->next;\n\t\tif(pnn == NULL || pnn->c != '.'){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n\t\tNode *pnnn = pnn->next;\n\t\tif(pnnn == NULL){\n//\t\t\tcout<<\"p5_1 \"<<p->c<<endl;\n\t\t\tNode *node;\n\t\t\tnode = new Node(' ');\n\t\t\tpn = insert(pn,node);\n\t\t\tnode = new Node(' ');\n\t\t\tpnn = insert(pnn,node);\n\t\t\tbreak;\n\t\t}\n\t\tNode *p1 = pnnn;\n\t\twhile(p1){\n\t\t\tif(p1->c != ']' &&\n\t\t\t   p1->c != ')' &&\n\t\t\t   p1->c != '}' &&\n\t\t\t   p1->c != '>' &&\n\t\t\t   p1->c != '\\\"'&&\n\t\t\t   p1->c != '\\'')\n\t\t\t\tbreak;\n\t\t\tp1 = p1->next;\n\t\t}\n\t\tNode *p2 = p1;\n\t\twhile(p2){\n\t\t\tif(p2->c != ' ' && p2->c != '\\t')\n\t\t\t\tbreak;\n\t\t\tp2 = p2->next;\n\t\t}\n\t\tif(p2){\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n//\t\tcout<<\"p5_3\"<<endl;\n\t\tNode* node;\n\t\tnode = new Node(' ');\n\t\tpn = insert(pn, node);\n\t\tnode = new Node(' ');\n\t\tp1->c = ' ';\n\t\tclean_List(p1->next);\n\t\tp1->next = NULL;\n\t\tbreak;\n\t}\n}", "id": 198, "concepts": ["linked list traversal", "pattern matching", "conditional logic", "string formatting"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 3\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 4\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 6\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 7\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 8\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 9\n### Snippet\nint RowFromYCoord(double yCoord){\n    double yBot = -616153.33419;\n    double cellSize = 270.0;\n    double result;\n    int retVal;\n    \n    result = (yCoord - yBot)/cellSize;\n    retVal = result;\n    return retVal;\n}\n\n### Concepts", "fingerprint": null, "seed": "int RowFromYCoord(double yCoord){\n    double yBot = -616153.33419;\n    double cellSize = 270.0;\n    double result;\n    int retVal;\n    \n    result = (yCoord - yBot)/cellSize;\n    retVal = result;\n    return retVal;\n}", "id": 199, "concepts": ["coordinate system conversion", "cell size calculation", "integer rounding"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 3\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 4\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 5\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 9\n### Snippet\nvoid setup(void)\r\n{\r\n\r\n//////////STILL TRYING TO GET ZULU WITH A DIFFERENT LIBRARY\r\n    setSyncProvider(RTC.get);   // the function to get the time from the RTC\r\n\r\n//////////END STILL TRYING TO GET ZULU WITH A DIFFERENT LIBRARY\r\n\r\n\r\n    Serial.begin(115200);\r\n\r\n  dht.begin();\r\n\r\n  \r\n  P.begin(2);\r\n  P.setInvert(false);\r\n//  P.setIntensity(6);\r\n\r\n  P.setZone(0, 0, MAX_DEVICES-5);\r\n  P.setZone(1, MAX_DEVICES-4, MAX_DEVICES-1);\r\n  P.setFont(1, numeric7Seg);\r\n\r\n  P.displayZoneText(1, szTime, PA_CENTER, SPEED_TIME, PAUSE_TIME, PA_PRINT, PA_NO_EFFECT);\r\n //  COMMENT ABOVE and UNCOMMENT HERE LATER   P.displayZoneText(0, szMesg, PA_CENTER, SPEED_TIME, 0, PA_SCROLL_LEFT, PA_SCROLL_LEFT);\r\nP.displayZoneText(0, szMesg, PA_CENTER, SPEED_TIME, ZULU_PAUSE_TIME, PA_SCROLL_LEFT, PA_SCROLL_LEFT);\r\n\r\n  P.addChar('$', degC);       //NOT NEEDED?\r\n  P.addChar('&', degF);\r\n\r\n                    //  RTC.control(DS1307_CLOCK_HALT, DS1307_OFF);\r\n                    //  RTC.control(DS1307_12H, DS1307_OFF);\r\n\r\n//  getTime(szTime);\r\n}\n\n### Concepts", "fingerprint": null, "seed": "void setup(void)\r\n{\r\n\r\n//////////STILL TRYING TO GET ZULU WITH A DIFFERENT LIBRARY\r\n    setSyncProvider(RTC.get);   // the function to get the time from the RTC\r\n\r\n//////////END STILL TRYING TO GET ZULU WITH A DIFFERENT LIBRARY\r\n\r\n\r\n    Serial.begin(115200);\r\n\r\n  dht.begin();\r\n\r\n  \r\n  P.begin(2);\r\n  P.setInvert(false);\r\n//  P.setIntensity(6);\r\n\r\n  P.setZone(0, 0, MAX_DEVICES-5);\r\n  P.setZone(1, MAX_DEVICES-4, MAX_DEVICES-1);\r\n  P.setFont(1, numeric7Seg);\r\n\r\n  P.displayZoneText(1, szTime, PA_CENTER, SPEED_TIME, PAUSE_TIME, PA_PRINT, PA_NO_EFFECT);\r\n //  COMMENT ABOVE and UNCOMMENT HERE LATER   P.displayZoneText(0, szMesg, PA_CENTER, SPEED_TIME, 0, PA_SCROLL_LEFT, PA_SCROLL_LEFT);\r\nP.displayZoneText(0, szMesg, PA_CENTER, SPEED_TIME, ZULU_PAUSE_TIME, PA_SCROLL_LEFT, PA_SCROLL_LEFT);\r\n\r\n  P.addChar('$', degC);       //NOT NEEDED?\r\n  P.addChar('&', degF);\r\n\r\n                    //  RTC.control(DS1307_CLOCK_HALT, DS1307_OFF);\r\n                    //  RTC.control(DS1307_12H, DS1307_OFF);\r\n\r\n//  getTime(szTime);\r\n}", "id": 200, "concepts": ["setup functionality", "asynchronous time synchronization", "data formatting", "font customization", "display layout", "text animation", "custom character definition"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 2\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 3\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 6\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 9\n### Snippet\nint main() {\n\n    std::cout << \"starting\" << std::endl;\n    hfu::find_nth_index_test();\n    std::cout << \"find_nth_index_test passed\" << std::endl;\n    hfu::extract_airline_test();\n    std::cout << \"find_airline_test passed\" << std::endl;\n    hfu::create_frequencies_test();\n    std::cout << \"create_frequencies_test passed\" << std::endl;\n    std::cout << \"terminating\" << std::endl;\n    return 0;\n}\n\n### Concepts", "fingerprint": null, "seed": "int main() {\n\n    std::cout << \"starting\" << std::endl;\n    hfu::find_nth_index_test();\n    std::cout << \"find_nth_index_test passed\" << std::endl;\n    hfu::extract_airline_test();\n    std::cout << \"find_airline_test passed\" << std::endl;\n    hfu::create_frequencies_test();\n    std::cout << \"create_frequencies_test passed\" << std::endl;\n    std::cout << \"terminating\" << std::endl;\n    return 0;\n}", "id": 201, "concepts": ["unit testing with assertions", "code readability", "code reusability"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 2\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 4\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 5\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 9\n### Snippet\nvoid c_p_c()\n{\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#ifndef ONLINE_JUDGE\n    freopen(\"/Users/ishan/Desktop/fuzzy-chainsaw-algo/input.txt\", \"r\", stdin);\n    freopen(\"/Users/ishan/Desktop/fuzzy-chainsaw-algo/output.txt\", \"w\", stdout);\n#endif\n}\n\n### Concepts", "fingerprint": null, "seed": "void c_p_c()\n{\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#ifndef ONLINE_JUDGE\n    freopen(\"/Users/ishan/Desktop/fuzzy-chainsaw-algo/input.txt\", \"r\", stdin);\n    freopen(\"/Users/ishan/Desktop/fuzzy-chainsaw-algo/output.txt\", \"w\", stdout);\n#endif\n}", "id": 202, "concepts": ["I/O optimization", "file redirection", "preprocessor directive for local testing"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 3\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 5\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 6\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 9\n### Snippet\nvoid loop()\n{\n  timer.run();\n  if (Blynk.connected()) {                                                    // If connected run as normal\n    Blynk.run();\n  } \n  else if (ReCnctFlag == 0) {                                                 // If NOT connected and not already trying to reconnect, set timer to try to reconnect in 30 seconds\n      blynkConnectionStatusForNotification = false;\n      ReCnctFlag = 1;                                                         // Set reconnection Flag\n      Serial.println(\"Starting reconnection timer in 30 seconds...\");\n      timer.setTimeout(30000L, []() {                                         // Lambda Reconnection Timer Function\n      ReCnctFlag = 0;                                                         // Reset reconnection Flag\n      ReCnctCount++;                                                          // Increment reconnection Counter\n      Serial.print(\"Attempting reconnection #\");\n      Serial.println(ReCnctCount);\n      Blynk.connect();                                                        // Try to reconnect to the server\n    });                                                                       // END Timer Function\n    }\n}\n\n### Concepts", "fingerprint": null, "seed": "void loop()\n{\n  timer.run();\n  if (Blynk.connected()) {                                                    // If connected run as normal\n    Blynk.run();\n  } \n  else if (ReCnctFlag == 0) {                                                 // If NOT connected and not already trying to reconnect, set timer to try to reconnect in 30 seconds\n      blynkConnectionStatusForNotification = false;\n      ReCnctFlag = 1;                                                         // Set reconnection Flag\n      Serial.println(\"Starting reconnection timer in 30 seconds...\");\n      timer.setTimeout(30000L, []() {                                         // Lambda Reconnection Timer Function\n      ReCnctFlag = 0;                                                         // Reset reconnection Flag\n      ReCnctCount++;                                                          // Increment reconnection Counter\n      Serial.print(\"Attempting reconnection #\");\n      Serial.println(ReCnctCount);\n      Blynk.connect();                                                        // Try to reconnect to the server\n    });                                                                       // END Timer Function\n    }\n}", "id": 203, "concepts": ["timer function for automatic reconnection", "flag for reconnection status", "counter for reconnection attempts"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 4\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 6\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 7\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 9\n### Snippet\nvoid fpcM_Init(void) {\n    fpcLy_Create(&rootlayer, NULL, queue, 10);\n    fpcLn_Create();\n}\n\n### Concepts", "fingerprint": null, "seed": "void fpcM_Init(void) {\n    fpcLy_Create(&rootlayer, NULL, queue, 10);\n    fpcLn_Create();\n}", "id": 204, "concepts": ["function call sequence", "linked list creation and management", "layer creation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 2\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 5\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 6\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 9\n### Snippet\ninline bool e_game_state_Parse(\n    const ::std::string& name, e_game_state* value) {\n  return ::google::protobuf::internal::ParseNamedEnum<e_game_state>(\n    e_game_state_descriptor(), name, value);\n}\n\n### Concepts", "fingerprint": null, "seed": "inline bool e_game_state_Parse(\n    const ::std::string& name, e_game_state* value) {\n  return ::google::protobuf::internal::ParseNamedEnum<e_game_state>(\n    e_game_state_descriptor(), name, value);\n}", "id": 205, "concepts": ["enum parsing for protocol buffer", "type safety", "inline function definition"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 2\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 4\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 7\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 8\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 9\n### Snippet\nvoid checkforupdate()\n{ \n  Serial.println( \"OTA Update Request Received\" );\n  Serial.print( \"Firmware URL: \" );\n  Serial.println( FIRMWARE_URL );\n\n  HTTPClient httpClient;\n  httpClient.begin( FIRMWARE_URL );\n  int httpCode = httpClient.GET();\n  if( httpCode == 200 ) {\n  Serial.println( \"Update file found, starting update\" );\n  Blynk.virtualWrite(VPIN_UPDATE_LED, 1023);\n  \n  t_httpUpdate_return ret = ESPhttpUpdate.update( FIRMWARE_URL );\n   \n  switch(ret) {\n    case HTTP_UPDATE_FAILED:\n        Serial.println(\"[update] Update failed.\");\n        break;\n    case HTTP_UPDATE_NO_UPDATES:\n        Serial.println(\"[update] Update no Update.\");\n        break;\n    case HTTP_UPDATE_OK:\n        Serial.println(\"[update] Update ok.\"); // may not called we reboot the ESP\n        break;\n              }\n           }  else {\n    Serial.print( \"Firmware check failed, got HTTP response code \" );\n    Serial.println( httpCode );\n           }\n  httpClient.end();\n  \n  Blynk.virtualWrite(VPIN_UPDATE_LED, 0);\n  Blynk.virtualWrite(VPIN_FIRMWARE_UPDATE, HIGH);  \n}\n\n### Concepts", "fingerprint": null, "seed": "void checkforupdate()\n{ \n  Serial.println( \"OTA Update Request Received\" );\n  Serial.print( \"Firmware URL: \" );\n  Serial.println( FIRMWARE_URL );\n\n  HTTPClient httpClient;\n  httpClient.begin( FIRMWARE_URL );\n  int httpCode = httpClient.GET();\n  if( httpCode == 200 ) {\n  Serial.println( \"Update file found, starting update\" );\n  Blynk.virtualWrite(VPIN_UPDATE_LED, 1023);\n  \n  t_httpUpdate_return ret = ESPhttpUpdate.update( FIRMWARE_URL );\n   \n  switch(ret) {\n    case HTTP_UPDATE_FAILED:\n        Serial.println(\"[update] Update failed.\");\n        break;\n    case HTTP_UPDATE_NO_UPDATES:\n        Serial.println(\"[update] Update no Update.\");\n        break;\n    case HTTP_UPDATE_OK:\n        Serial.println(\"[update] Update ok.\"); // may not called we reboot the ESP\n        break;\n              }\n           }  else {\n    Serial.print( \"Firmware check failed, got HTTP response code \" );\n    Serial.println( httpCode );\n           }\n  httpClient.end();\n  \n  Blynk.virtualWrite(VPIN_UPDATE_LED, 0);\n  Blynk.virtualWrite(VPIN_FIRMWARE_UPDATE, HIGH);  \n}", "id": 206, "concepts": ["http request handling", "http status code handling", "firmware update process"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 2\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 5\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 8\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 9\n### Snippet\nint main()\r\n{\r\n\tint i, j, n, fake;\r\n\tfor (cin >> n; n; n--)\r\n\t{\r\n\t\tfor (i = 0; i < COIN; i++)\r\n\t\t\tox[i] = coin[i] = 0;\r\n\t\tfor (i = 0; i < TIME; i++)\r\n\t\t{\r\n\t\t\tfor (j = 0; j < 3; j++)\r\n\t\t\t\tcin >> s[j];\r\n\t\t\tif (s[2] == \"even\")\r\n\t\t\t\tsetStatus(0, 1);\r\n\t\t\telse if (s[2] == \"up\")\r\n\t\t\t\tsetCoin(1);\r\n\t\t\telse setCoin(-1);\r\n\t\t}\r\n\t\tfor (i = fake = 0; i < COIN; i++)\r\n\t\t{\r\n\t\t\tif (abs(coin[i]) > abs(coin[fake])) fake = i;\r\n\t\t\telse ox[i] = 1;\r\n\t\t}\r\n\t\tprintf(\"%c is the counterfeit coin and it is %s.\\n\", fake + 'A', ((coin[fake] > 0) ? \"light\" : \"heavy\"));\r\n\t}\r\n}\n\n### Concepts", "fingerprint": null, "seed": "int main()\r\n{\r\n\tint i, j, n, fake;\r\n\tfor (cin >> n; n; n--)\r\n\t{\r\n\t\tfor (i = 0; i < COIN; i++)\r\n\t\t\tox[i] = coin[i] = 0;\r\n\t\tfor (i = 0; i < TIME; i++)\r\n\t\t{\r\n\t\t\tfor (j = 0; j < 3; j++)\r\n\t\t\t\tcin >> s[j];\r\n\t\t\tif (s[2] == \"even\")\r\n\t\t\t\tsetStatus(0, 1);\r\n\t\t\telse if (s[2] == \"up\")\r\n\t\t\t\tsetCoin(1);\r\n\t\t\telse setCoin(-1);\r\n\t\t}\r\n\t\tfor (i = fake = 0; i < COIN; i++)\r\n\t\t{\r\n\t\t\tif (abs(coin[i]) > abs(coin[fake])) fake = i;\r\n\t\t\telse ox[i] = 1;\r\n\t\t}\r\n\t\tprintf(\"%c is the counterfeit coin and it is %s.\\n\", fake + 'A', ((coin[fake] > 0) ? \"light\" : \"heavy\"));\r\n\t}\r\n}", "id": 207, "concepts": ["coin identification using counterbalance", "integer array representation of coin status", "loop and function decomposition"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 2\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 3\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 4\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 7\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 9\n### Snippet\nvoid auto_mode()                                      // Function to check if auto mode is ON and all voltage value is greater than voltage cutoff value, then turn on 2 relays\n{    \n  if(auto_mode_state_1 == LOW && lowvoltageflag == false && highvoltageflag == false && phasefailureflag == false){  //checks if auto mode is ON and voltage values is greater than min value  - Motor 1\n    Serial.println(\"All condition is TRUE...swtiching on relay 1 now.\");    \n    digitalWrite(RELAY_PIN_1, LOW);                  // Turn on Relay 1         \n    Blynk.virtualWrite(VPIN_BUTTON_1, LOW);          // Update Blynk button status to ON    \n    Serial.println(\"RELAY 1 Turned ON\"); \n  }\n\n    if(auto_mode_state_2 == LOW && lowvoltageflag == false && highvoltageflag == false && phasefailureflag == false){  //checks if auto mode is ON and voltage values is greater than min value - Motor 2 \n    Serial.println(\"All condition is TRUE...swtiching on relay 2 now.\");    \n    digitalWrite(RELAY_PIN_2, LOW);                  // Turn on Relay 2         \n    Blynk.virtualWrite(VPIN_BUTTON_2, LOW);          // Update Blynk button status to ON    \n    Serial.println(\"RELAY 2 Turned ON\"); \n  }\n  \n}\n\n### Concepts", "fingerprint": null, "seed": "void auto_mode()                                      // Function to check if auto mode is ON and all voltage value is greater than voltage cutoff value, then turn on 2 relays\n{    \n  if(auto_mode_state_1 == LOW && lowvoltageflag == false && highvoltageflag == false && phasefailureflag == false){  //checks if auto mode is ON and voltage values is greater than min value  - Motor 1\n    Serial.println(\"All condition is TRUE...swtiching on relay 1 now.\");    \n    digitalWrite(RELAY_PIN_1, LOW);                  // Turn on Relay 1         \n    Blynk.virtualWrite(VPIN_BUTTON_1, LOW);          // Update Blynk button status to ON    \n    Serial.println(\"RELAY 1 Turned ON\"); \n  }\n\n    if(auto_mode_state_2 == LOW && lowvoltageflag == false && highvoltageflag == false && phasefailureflag == false){  //checks if auto mode is ON and voltage values is greater than min value - Motor 2 \n    Serial.println(\"All condition is TRUE...swtiching on relay 2 now.\");    \n    digitalWrite(RELAY_PIN_2, LOW);                  // Turn on Relay 2         \n    Blynk.virtualWrite(VPIN_BUTTON_2, LOW);          // Update Blynk button status to ON    \n    Serial.println(\"RELAY 2 Turned ON\"); \n  }\n  \n}", "id": 208, "concepts": ["conditional logic for relay switching", "flag checks for voltage values", "serial output for debugging"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 4\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 5\n### Snippet\nint findInsertionIndex(const std::vector<int>& array, int target) {\n    int left = 0;\n    int right = array.size(); // `right` is set to `array.size()` for a possible insertion at the end.\n\n    while (left < right) {\n        int mid = left + (right - left) / 2; // To prevent overflow\n\n        if (array[mid] < target) {\n            left = mid + 1; // Move the left pointer up\n        } else {\n            right = mid; // Move the right pointer down\n        }\n    }\n\n    return left; // The insertion index\n}\n\n### Concepts\ninsertion point for a sorted array, optimized time complexity\n\n## Example 6\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 7\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 9\n### Snippet\nvoid setStatus(int Scoin, int Sox)\r\n{\r\n\tint i, j;\r\n\tfor (i = 0; i < 2; i++)\r\n\t\tfor (j = 0; j < s[i].size(); j++)\r\n\t\t{\r\n\t\t\tcoin[s[i][j] - 'A'] = Scoin;\r\n\t\t\tox[s[i][j] - 'A'] = Sox;\r\n\t\t}\r\n\treturn ;\r\n}\n\n### Concepts", "fingerprint": null, "seed": "void setStatus(int Scoin, int Sox)\r\n{\r\n\tint i, j;\r\n\tfor (i = 0; i < 2; i++)\r\n\t\tfor (j = 0; j < s[i].size(); j++)\r\n\t\t{\r\n\t\t\tcoin[s[i][j] - 'A'] = Scoin;\r\n\t\t\tox[s[i][j] - 'A'] = Sox;\r\n\t\t}\r\n\treturn ;\r\n}", "id": 209, "concepts": ["status updating based on given conditions", "2D array traversal", "bit manipulation"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 5\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 7\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 8\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 9\n### Snippet\nvoid expand_data(float *data, float *data2, int Nx, int Ny, int Lx) \n{ \n\t// expand data to 2N + 2 length \n\t#pragma acc parallel loop independent present(data[0:Nx*Ny],data2[0:Lx*Ny]) \n\tfor(int i=0;i<Ny;i++) \n\t{ \n\t\tdata2[Lx*i] = data2[Lx*i+Nx+1] = 0.0; \n\t\t#pragma acc loop independent \n\t\tfor(int j=0;j<Nx;j++) \n\t\t{ \n\t\t\tdata2[Lx*i+j+1] = data[Nx*i+j]; \n\t\t\tdata2[Lx*i+Nx+j+2] = -1.0*data[Nx*i+Nx-1-j]; \n\t\t} \n\t} \n}\n\n### Concepts", "fingerprint": null, "seed": "void expand_data(float *data, float *data2, int Nx, int Ny, int Lx) \n{ \n\t// expand data to 2N + 2 length \n\t#pragma acc parallel loop independent present(data[0:Nx*Ny],data2[0:Lx*Ny]) \n\tfor(int i=0;i<Ny;i++) \n\t{ \n\t\tdata2[Lx*i] = data2[Lx*i+Nx+1] = 0.0; \n\t\t#pragma acc loop independent \n\t\tfor(int j=0;j<Nx;j++) \n\t\t{ \n\t\t\tdata2[Lx*i+j+1] = data[Nx*i+j]; \n\t\t\tdata2[Lx*i+Nx+j+2] = -1.0*data[Nx*i+Nx-1-j]; \n\t\t} \n\t} \n}", "id": 210, "concepts": ["OpenACC programming", "data expansion", "array manipulation", "loop reordering"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 2\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 3\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 4\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 7\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 8\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 9\n### Snippet\nvoid loop(){\n  //update VCC\n  VCC.update(); \n\n}\n\n### Concepts", "fingerprint": null, "seed": "void loop(){\n  //update VCC\n  VCC.update(); \n\n}", "id": 211, "concepts": ["VCC is an object that is used to update the value of the VCC. It is likely that the VCC is a voltage that is used to power the system. The update() method is likely used to update the value of the VCC to ensure that it is accurate and up-to-date."]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\nclass SpecialFormulas {\npublic:\n    // Function f1(a, b)\n    static int f1(int a, int b) {\n        return (a + 1) * (b + 1) - 1;\n    }\n\n    // Function f2(k)\n    static int f2(int k) {\n        if (k % 2 == 1) { // k is odd\n            return ((k + 1) * (k + 1)) / 2 + k + 1;\n        } else { // k is even\n            return (k * k) / 2 + 2 * k + 1;\n        }\n    }\n\n    // Function to compute f2(f1(a, b))\n    static int compute(int a, int b) {\n        int f1Result = f1(a, b);\n        return f2(f1Result);\n    }\n};\n\n### Concepts\nspecial formula implementation, odd and even number handling, function composition\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 4\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 6\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 7\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 8\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 9\n### Snippet\nvoid DiscreteMasterProperty__float4__OnComplete(DiscreteMasterProperty__float4* __this)\n{\n    ::app::Uno::Float4 nv = __this->RestValue();\n    float str = 0.5f;\n\n    for (::app::Uno::Collections::List1_Enumerator__Fuse_Animations_MixerHandle_float4_ enum_123 = ::uPtr< ::app::Uno::Collections::List__Fuse_Animations_MixerHandle_float4_*>(__this->Handles)->GetEnumerator(); enum_123.MoveNext(); )\n    {\n        ::app::Fuse::Animations::MixerHandle__float4* v = enum_123.Current();\n\n        if (::uPtr< ::app::Fuse::Animations::MixerHandle__float4*>(v)->HasValue() && (::uPtr< ::app::Fuse::Animations::MixerHandle__float4*>(v)->Strength > str))\n        {\n            nv = ::uPtr< ::app::Fuse::Animations::MixerHandle__float4*>(v)->Value;\n            str = v->Strength;\n        }\n    }\n\n    ::uPtr< ::app::Uno::UX::Property__float4*>(__this->Property)->Set(nv, (::uObject*)__this);\n}\n\n### Concepts", "fingerprint": null, "seed": "void DiscreteMasterProperty__float4__OnComplete(DiscreteMasterProperty__float4* __this)\n{\n    ::app::Uno::Float4 nv = __this->RestValue();\n    float str = 0.5f;\n\n    for (::app::Uno::Collections::List1_Enumerator__Fuse_Animations_MixerHandle_float4_ enum_123 = ::uPtr< ::app::Uno::Collections::List__Fuse_Animations_MixerHandle_float4_*>(__this->Handles)->GetEnumerator(); enum_123.MoveNext(); )\n    {\n        ::app::Fuse::Animations::MixerHandle__float4* v = enum_123.Current();\n\n        if (::uPtr< ::app::Fuse::Animations::MixerHandle__float4*>(v)->HasValue() && (::uPtr< ::app::Fuse::Animations::MixerHandle__float4*>(v)->Strength > str))\n        {\n            nv = ::uPtr< ::app::Fuse::Animations::MixerHandle__float4*>(v)->Value;\n            str = v->Strength;\n        }\n    }\n\n    ::uPtr< ::app::Uno::UX::Property__float4*>(__this->Property)->Set(nv, (::uObject*)__this);\n}", "id": 212, "concepts": ["discrete master property update logic", "mixer handle value and strength evaluation", "float4 value assignment"]}
{"prompt": "Extract key programming concepts from the provided code snippet. Programming concepts refer to the foundational principles and techniques used in programming, which are crucial for developers to master. List these concepts in a comma-separated format.\n\n## Example 1\n### Snippet\n#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n\nstd::vector<std::vector<int>> create_folds(const std::vector<int>& data, int count) {\n    if (count <= 0 || data.empty()) {\n        return {}; // Return empty if count is non-positive or data is empty\n    }\n\n    std::vector<std::vector<int>> folds;\n    size_t fold_size = data.size() / count;\n    size_t remainder = data.size() % count;\n    size_t start = 0;\n\n    for (int i = 0; i < count; ++i) {\n        size_t current_fold_size = fold_size + (i < remainder ? 1 : 0);\n        folds.emplace_back(data.begin() + start, data.begin() + start + current_fold_size);\n        start += current_fold_size;\n    }\n\n    return folds;\n}\n\n### Concepts\ndata partitioning and slicing, learning from input-output examples\n\n## Example 2\n### Snippet\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <iomanip>\n\nstd::string format_size(std::size_t bytes) {\n    const char* units[] = {\"bytes\", \"KB\", \"MB\", \"GB\", \"TB\"};\n    const std::size_t unit_count = sizeof(units) / sizeof(units[0]);\n\n    double size = static_cast<double>(bytes);\n    std::size_t unit_index = 0;\n\n    while (size >= 1024.0 && unit_index < unit_count - 1) {\n        size /= 1024.0;\n        ++unit_index;\n    }\n\n    std::ostringstream formatted_size;\n    formatted_size << std::fixed << std::setprecision(1) << size << units[unit_index];\n    return formatted_size.str();\n}\n\n### Concepts\narithmetic operations for size conversion, rounding numbers, dynamic unit selection, string interpolation\n\n## Example 3\n### Snippet\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <cassert>\n\nstd::vector<std::string> encode_strings(const std::vector<std::string>& input) {\n    assert(std::all_of(input.begin(), input.end(), [](const std::string& s) { return !s.empty(); })); // Precondition check\n\n    std::unordered_map<std::string, int> counts;\n    std::vector<std::string> result(input.size());\n\n    for (size_t i = 0; i < input.size(); ++i) {\n        const std::string& str = input[i];\n        result[i] = str + std::string(counts[str]++, '*');\n    }\n\n    return result;\n}\n\n### Concepts\nlist comprehension, unique string creation, precondition checking for type validation\n\n## Example 4\n### Snippet\n#include <vector>\n#include <cmath>\n\nclass PrimeFinder {\nprivate:\n    std::vector<int> prime_list; // List to store calculated primes\n\n    // Helper method to check if a number is prime\n    bool is_prime(int n) {\n        if (n < 2) return false;\n        for (int prime : prime_list) {\n            if (prime * prime > n) break; // Stop if prime exceeds sqrt(n)\n            if (n % prime == 0) return false; // Divisible means not prime\n        }\n        return true;\n    }\n\npublic:\n    // Constructor initializes with the first prime\n    PrimeFinder() {\n        prime_list.push_back(2); // Start with the first prime\n    }\n\n    // Method to find the nth prime using memoization\n    int find_nth_prime_memoized(int n) {\n        if (n <= 0) throw std::invalid_argument(\"n must be a positive integer\");\n\n        // Continue generating primes until the nth prime is found\n        int current = prime_list.back() + 1; // Start checking from the next number\n        while (prime_list.size() < static_cast<size_t>(n)) {\n            if (is_prime(current)) {\n                prime_list.push_back(current); // Add to the list if prime\n            }\n            current++;\n        }\n\n        return prime_list[n - 1]; // Return the nth prime (0-indexed)\n    }\n};\n\n### Concepts\nprime number memoization, n-th prime calculation, efficiency in prime checks\n\n## Example 5\n### Snippet\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string encodeIntegerToChars(int value) {\n    if (value == 0) {\n        return std::string(1, static_cast<char>(63));\n    }\n\n    std::vector<char> encodedChars;\n\n    while (value > 0) {\n        // Extract the last 5 bits and add 63 to form the ASCII value\n        char chunk = static_cast<char>((value & 31) + 63);\n        value >>= 5; // Right shift by 5 bits\n\n        // If there are more chunks, set the continuation bit (6th bit)\n        if (value > 0) {\n            chunk |= 32; // Set the 6th bit to 1\n        }\n\n        // Add the chunk to the vector\n        encodedChars.push_back(chunk);\n    }\n\n    // Reverse the order of the characters to preserve the correct encoding order\n    std::reverse(encodedChars.begin(), encodedChars.end());\n\n    return std::string(encodedChars.begin(), encodedChars.end());\n}\n\n### Concepts\n5-bit chunk encoding with bitwise shifts, ASCII value manipulation, continuation bit signaling\n\n## Example 6\n### Snippet\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <cctype>\n#include <cassert>\n\nint parse_duration(const std::string& duration) {\n    if (duration.empty()) {\n        throw std::invalid_argument(\"Empty duration string\");\n    }\n\n    size_t index = 0;\n    while (index < duration.size() && std::isdigit(duration[index])) {\n        ++index;\n    }\n\n    if (index == 0 || index == duration.size()) {\n        throw std::invalid_argument(\"Invalid duration format\");\n    }\n\n    int value = std::stoi(duration.substr(0, index));\n    std::string unit = duration.substr(index);\n\n    if (unit == \"s\" || unit == \"sec\") {\n        return value;\n    } else if (unit == \"m\" || unit == \"min\") {\n        return value * 60;\n    } else if (unit == \"h\" || unit == \"hour\") {\n        return value * 3600;\n    } else if (unit == \"d\" || unit == \"day\") {\n        return value * 86400;\n    } else {\n        throw std::invalid_argument(\"Invalid time unit\");\n    }\n}\n\n### Concepts\nregular expression for pattern matching, dictionary lookup for suffix mapping, error handling with exceptions\n\n## Example 7\n### Snippet\n#include <vector>\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <memory>\n\n// HuffmanNode class definition\nclass HuffmanNode {\npublic:\n    char value; // Character value for leaf nodes\n    std::shared_ptr<HuffmanNode> left; // Left child\n    std::shared_ptr<HuffmanNode> right; // Right child\n\n    // Constructor for leaf nodes\n    HuffmanNode(char val) : value(val), left(nullptr), right(nullptr) {}\n\n    // Constructor for internal nodes\n    HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r) : value('\\0'), left(l), right(r) {}\n};\n\n// Function to decompress Huffman encoded data\nstd::string huffman_decompress(const std::vector<bool>& compressed_data, const std::shared_ptr<HuffmanNode>& huffman_tree) {\n    std::string decompressed_data;\n    auto current_node = huffman_tree;\n\n    for (bool bit : compressed_data) {\n        if (bit) {\n            current_node = current_node->right;\n        } else {\n            current_node = current_node->left;\n        }\n\n        // Check if we reached a leaf node\n        if (!current_node->left && !current_node->right) {\n            decompressed_data += current_node->value;\n            current_node = huffman_tree; // Reset to root for the next symbol\n        }\n    }\n\n    return decompressed_data;\n}\n\n### Concepts\ndecoding compressed data, binary tree traversal, byte array processing\n\n## Example 8\n### Snippet\n#include <cassert>\n#include <iostream>\n\n// Function to compute the ceiling of n / 2^b using bit manipulation\nint ceil_divide_without_div(int n, int b) {\n    // Assertions to ensure non-negative inputs\n    assert(n >= 0 && \"n must be a non-negative integer\");\n    assert(b >= 0 && \"b must be a non-negative integer\");\n\n    // If b is 0, 2^b is 1, and n / 2^b is just n\n    if (b == 0) {\n        return n;\n    }\n\n    // Compute the divisor as 2^b (left shift 1 by b positions)\n    int divisor = 1 << b;\n\n    // Add divisor - 1 to n, then right shift by b to compute the ceiling\n    return (n + divisor - 1) >> b;\n}\n\n### Concepts\nbitwise operation for division, ceiling without division or float, input validation with assertions, non-negative integer checks\n\n## Example 9\n### Snippet\nvoid p14(Node *h, char *c, int l, int s){\n\tNode *p = h;\n\tNode *pn[15];\n\twhile(p){\n\t\tint i;\n\t\tfor(i = 0; i < l; i ++){\n\t\t\tif( i == 0) pn[i] = p->next;\n\t\t\telse pn[i] = pn[i-1]->next;\n\n\t\t\tif(pn[i] == NULL || pn[i]->c != c[i]){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(i != l) {\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n//\t\tcout<<\"p14\"<<endl;\n\t\tNode *node = new Node(' ');\n\t\tpn[s] = insert(pn[s],node);\n\t\tp = pn[l-1];\n\t}\n}\n\n### Concepts", "fingerprint": null, "seed": "void p14(Node *h, char *c, int l, int s){\n\tNode *p = h;\n\tNode *pn[15];\n\twhile(p){\n\t\tint i;\n\t\tfor(i = 0; i < l; i ++){\n\t\t\tif( i == 0) pn[i] = p->next;\n\t\t\telse pn[i] = pn[i-1]->next;\n\n\t\t\tif(pn[i] == NULL || pn[i]->c != c[i]){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(i != l) {\n\t\t\tp = p->next;\n\t\t\tcontinue;\n\t\t}\n//\t\tcout<<\"p14\"<<endl;\n\t\tNode *node = new Node(' ');\n\t\tpn[s] = insert(pn[s],node);\n\t\tp = pn[l-1];\n\t}\n}", "id": 213, "concepts": ["linked list traversal", "insertion", "recursion", "backtracking"]}
